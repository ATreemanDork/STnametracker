{"version":3,"file":"index.js","mappings":";;;;;;;AAAa;;AAEb;AACA;AACA,cAAc,KAAwC,GAAG,sBAAiB,GAAG,CAAI;AACjF;AACA;AACA;AACA;AACA,gD;;;;;;;ACTa;;AAEb;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;;;;ACnFA;AACyG;AACjB;AACxF,8BAA8B,mFAA2B,CAAC,4FAAqC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,oFAAoF,MAAM,UAAU,OAAO,KAAK,YAAY,OAAO,KAAK,YAAY,aAAa,aAAa,OAAO,YAAY,MAAM,YAAY,aAAa,aAAa,WAAW,OAAO,KAAK,YAAY,aAAa,WAAW,YAAY,OAAO,YAAY,MAAM,YAAY,aAAa,aAAa,aAAa,WAAW,UAAU,OAAO,KAAK,UAAU,YAAY,aAAa,aAAa,aAAa,OAAO,KAAK,YAAY,OAAO,YAAY,MAAM,YAAY,aAAa,OAAO,KAAK,UAAU,YAAY,aAAa,aAAa,OAAO,KAAK,YAAY,aAAa,aAAa,OAAO,KAAK,UAAU,YAAY,OAAO,KAAK,YAAY,aAAa,OAAO,KAAK,YAAY,aAAa,aAAa,aAAa,aAAa,aAAa,OAAO,KAAK,YAAY,WAAW,MAAM,KAAK,YAAY,WAAW,MAAM,KAAK,YAAY,WAAW,MAAM,YAAY,MAAM,UAAU,YAAY,aAAa,OAAO,KAAK,YAAY,OAAO,KAAK,UAAU,YAAY,aAAa,aAAa,OAAO,KAAK,UAAU,UAAU,YAAY,aAAa,OAAO,MAAM,UAAU,YAAY,OAAO,KAAK,YAAY,aAAa,aAAa,aAAa,OAAO,KAAK,YAAY,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,OAAO,KAAK,YAAY,aAAa,WAAW,UAAU,YAAY,aAAa,aAAa,aAAa,OAAO,KAAK,UAAU,UAAU,UAAU,UAAU,OAAO,KAAK,UAAU,YAAY,aAAa,aAAa,OAAO,YAAY,MAAM,YAAY,aAAa,aAAa,aAAa,aAAa,WAAW,YAAY,WAAW,OAAO,KAAK,YAAY,aAAa,aAAa,OAAO,KAAK,YAAY,OAAO,KAAK,YAAY,OAAO,YAAY,MAAM,YAAY,WAAW,OAAO,KAAK,YAAY,WAAW,MAAM,KAAK,YAAY,aAAa,OAAO,KAAK,YAAY,aAAa,aAAa,WAAW,OAAO,YAAY,MAAM,YAAY,aAAa,WAAW,UAAU,YAAY,OAAO,YAAY,MAAM,UAAU,OAAO,KAAK,YAAY,OAAO,KAAK,YAAY,aAAa,OAAO,KAAK,UAAU,YAAY,aAAa,WAAW,YAAY,aAAa,aAAa,OAAO,YAAY,MAAM,UAAU,YAAY,OAAO,YAAY,MAAM,UAAU,MAAM,KAAK,UAAU,MAAM,YAAY,MAAM,UAAU,UAAU,YAAY,aAAa,aAAa,aAAa,OAAO,KAAK,YAAY,aAAa,OAAO,KAAK,UAAU,UAAU,YAAY,aAAa,aAAa,OAAO,KAAK,UAAU,YAAY,aAAa,OAAO,YAAY,MAAM,UAAU,YAAY,WAAW,YAAY,aAAa,aAAa,OAAO,KAAK,UAAU,OAAO,KAAK,YAAY,OAAO,KAAK,YAAY,OAAO,KAAK,YAAY,aAAa,aAAa,OAAO,YAAY,MAAM,KAAK,YAAY,OAAO,KAAK,UAAU,KAAK,MAAM,YAAY,MAAM,KAAK,UAAU,YAAY,MAAM,KAAK,UAAU,YAAY,MAAM,MAAM,KAAK,YAAY,OAAO,YAAY,MAAM,UAAU,YAAY,aAAa,OAAO,KAAK,YAAY,aAAa,aAAa,OAAO,KAAK,YAAY,aAAa,aAAa,aAAa,WAAW,YAAY,OAAO,KAAK,UAAU,YAAY,OAAO,KAAK,YAAY,OAAO,KAAK,YAAY,qGAAqG,qBAAqB,KAAK,6BAA6B,4BAA4B,KAAK,gCAAgC,yBAAyB,4BAA4B,0BAA0B,KAAK,4DAA4D,yDAAyD,uDAAuD,2BAA2B,sBAAsB,KAAK,8BAA8B,0BAA0B,0CAA0C,qBAAqB,2BAA2B,KAAK,8DAA8D,0BAA0B,yBAAyB,uDAAuD,2BAA2B,qBAAqB,wBAAwB,KAAK,iCAAiC,sBAAsB,4BAA4B,uDAAuD,2BAA2B,yDAAyD,KAAK,4CAA4C,yBAAyB,KAAK,qIAAqI,uCAAuC,kDAAkD,KAAK,2BAA2B,sBAAsB,uCAAuC,4BAA4B,2BAA2B,KAAK,yBAAyB,0BAA0B,yBAAyB,0CAA0C,KAAK,kCAAkC,uBAAuB,0BAA0B,KAAK,iCAAiC,2CAA2C,sCAAsC,KAAK,0BAA0B,8BAA8B,yBAAyB,2BAA2B,0BAA0B,0BAA0B,yBAAyB,KAAK,oCAAoC,kCAAkC,oBAAoB,KAAK,kCAAkC,+BAA+B,oBAAoB,KAAK,qCAAqC,kCAAkC,oBAAoB,KAAK,wEAAwE,sBAAsB,4BAA4B,0CAA0C,KAAK,yBAAyB,4BAA4B,KAAK,+BAA+B,uBAAuB,0BAA0B,2BAA2B,0CAA0C,KAAK,+BAA+B,uBAAuB,wBAAwB,2CAA2C,0BAA0B,KAAK,4DAA4D,oBAAoB,+BAA+B,KAAK,4BAA4B,yBAAyB,2CAA2C,2BAA2B,2BAA2B,KAAK,4BAA4B,8BAA8B,0BAA0B,yBAAyB,mDAAmD,uDAAuD,2BAA2B,+BAA+B,0BAA0B,2BAA2B,2CAA2C,KAAK,4BAA4B,0BAA0B,0CAA0C,sBAAsB,qBAAqB,mDAAmD,4DAA4D,2BAA2B,yBAAyB,KAAK,4BAA4B,sBAAsB,iBAAiB,wBAAwB,wBAAwB,KAAK,yCAAyC,gBAAgB,yBAAyB,0BAA0B,yBAAyB,KAAK,4DAA4D,mDAAmD,uDAAuD,wCAAwC,0BAA0B,2BAA2B,wBAAwB,kCAAkC,wBAAwB,KAAK,gCAAgC,gDAAgD,oCAAoC,iDAAiD,KAAK,iCAAiC,iCAAiC,KAAK,4BAA4B,6BAA6B,KAAK,+EAA+E,8BAA8B,uBAAuB,KAAK,6CAA6C,4BAA4B,oBAAoB,KAAK,8BAA8B,0BAA0B,yBAAyB,KAAK,6BAA6B,2CAA2C,2BAA2B,2BAA2B,sBAAsB,KAAK,mDAAmD,yDAAyD,4DAA4D,sBAAsB,wBAAwB,2BAA2B,KAAK,6CAA6C,sBAAsB,KAAK,yBAAyB,4BAA4B,KAAK,8BAA8B,0CAA0C,0BAA0B,KAAK,wBAAwB,uBAAuB,yBAAyB,yBAAyB,sBAAsB,iDAAiD,uCAAuC,2BAA2B,KAAK,gDAAgD,qBAAqB,4BAA4B,KAAK,2CAA2C,iBAAiB,KAAK,gBAAgB,gBAAgB,KAAK,4DAA4D,uBAAuB,sBAAsB,yDAAyD,uDAAuD,2BAA2B,2BAA2B,KAAK,+CAA+C,2BAA2B,0BAA0B,KAAK,8CAA8C,oBAAoB,qBAAqB,0CAA0C,4BAA4B,yBAAyB,KAAK,+CAA+C,qBAAqB,sDAAsD,oCAAoC,KAAK,0FAA0F,sBAAsB,yBAAyB,sBAAsB,0CAA0C,2BAA2B,yBAAyB,KAAK,qCAAqC,uBAAuB,KAAK,oCAAoC,2BAA2B,KAAK,+CAA+C,yBAAyB,KAAK,kCAAkC,0BAA0B,2CAA2C,0BAA0B,KAAK,mEAAmE,4BAA4B,mCAAmC,SAAS,iDAAiD,wBAAwB,SAAS,KAAK,iEAAiE,cAAc,uBAAuB,yCAAyC,SAAS,YAAY,uBAAuB,qCAAqC,SAAS,KAAK,qCAAqC,oCAAoC,KAAK,gEAAgE,sBAAsB,4BAA4B,0CAA0C,KAAK,iCAAiC,4BAA4B,2CAA2C,yBAAyB,KAAK,+BAA+B,yDAAyD,0CAA0C,uDAAuD,2BAA2B,sBAAsB,yBAAyB,KAAK,qCAAqC,sBAAsB,+CAA+C,KAAK,uCAAuC,yBAAyB,KAAK,8BAA8B,2BAA2B,KAAK,+BAA+B;AACn6X;AACA,iEAAe,uBAAuB,EAAC;;;;;;;;;;;;;;ACtZvC;AACA;AACA;AACA;AACA;AACqC;AACM;AAC3C;AACA,eAAe,iGAA8B;AAC7C;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,8DAAY;AAC3B;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS,IAAI,cAAc;AAC3B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,8DAAY;AAC3B;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS,IAAI,cAAc;AAC3B;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,iBAAiB;AAClC;AACA;AACA,eAAe,8DAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,eAAe,8DAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,eAAe,8DAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,aAAa;AAC9D,SAAS,IAAI,cAAc;AAC3B;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA,kEAAkE;AAClE,eAAe,8DAAY;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,mBAAmB,gBAAgB;AACxH,yDAAyD,kBAAkB;AAC3E,gEAAgE,kBAAkB;AAClF,kEAAkE,kBAAkB;AACpF,2EAA2E,kBAAkB;AAC7F,mEAAmE,kBAAkB;AACrF,uEAAuE,kBAAkB;AACzF;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC2C;AAC3C,iEAAe,kBAAkB,EAAC;;;;;;;;AClWrB;;AAEb;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACkB;AAG3C;AACkB;AACG;AACc;AAChE;AACA;AACA;AACA,qDAAqD,wEAAkB;AACvE,oDAAoD,wEAAiB;AACrE,mDAAmD,uEAAgB;AACnE;AACA;AACA;AACA;AACA;AACA,YAAY,4EAAkB;AAC9B;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iFAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC;AACO;AACP;AACA;AACA;AACA;AACA,WAAW,4EAAiB;AAC5B;AACA,wBAAwB,uDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,aAAa;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,eAAe;AACvD;AACA,wBAAwB,GAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,aAAa;AACzF,iDAAiD,aAAa;AAC9D;AACA;AACA;AACA,sFAAsF,aAAa;AACnG;AACA;AACA;AACA;AACA,8EAA8E,aAAa;AAC3F;AACA,4DAA4D,aAAa;AACzE;AACA,cAAc;AACd,mFAAmF,mCAAmC,UAAU;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,cAAc;AAC3E,cAAc;AACd;AACA,6DAA6D,cAAc;AAC3E;AACA;AACA;AACA,iDAAiD,aAAa,qCAAqC,eAAe;AAClH;AACA,UAAU;AACV;AACA;AACA,sBAAsB,uEAAgB,mCAAmC,cAAc;AACvF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,0CAA0C,IAAI,KAAK;AACnD,aAAa,iBAAiB;AAC9B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2BAA2B;AACzD;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA,kDAAkD,IAAI,KAAK;AAC3D;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,6BAA6B,QAAQ,kBAAkB;AACxG,cAAc;AACd,uDAAuD,UAAU;AACjE;AACA;AACA;AACA;AACA,iDAAiD,aAAa,UAAU,aAAa;AACrF;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA;AACA;AACA;AACA,wBAAwB;AACxB,uBAAuB;AACvB,2BAA2B;AAC3B,gCAAgC;AAChC,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,sBAAsB;AACtB,0BAA0B;AAC1B,uBAAuB;AACvB;AACA;AACA,qDAAqD,cAAc;AACnE;AACA;AACA,wBAAwB,uDAAS;AACjC,qCAAqC,8EAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,sBAAsB;AACvF,6DAA6D,oBAAoB;AACjF,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA,8DAA8D,mBAAmB;AACjF;AACA;AACA;AACA;AACA,qDAAqD,sBAAsB;AAC3E;AACA;AACA;AACA;AACA,mDAAmD,oBAAoB;AACvE;AACA;AACA;AACA;AACA,qDAAqD,wBAAwB;AAC7E;AACA;AACA;AACA;AACA,uDAAuD,qBAAqB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,IAAI;AAC3C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wEAAW;AACvC,qDAAqD,cAAc,IAAI,cAAc;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,0EAA0E,cAAc;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,KAAK,SAAS,qBAAqB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,qBAAqB;AACxE;AACA;AACA;AACA,kCAAkC,yEAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,cAAc;AACvF,uDAAuD,YAAY;AACnE,kDAAkD,gBAAgB;AAClE,4DAA4D,gBAAgB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,+CAA+C,cAAc,KAAK,0BAA0B;AAC5F;AACA,+DAA+D,eAAe,QAAQ,cAAc;AACpG,UAAU;AACV;AACA,2BAA2B,wEAAW;AACtC;AACA;AACA;AACA;AACA,oBAAoB;AACpB,mBAAmB;AACnB,gBAAgB;AAChB,qBAAqB,0BAA0B;AAC/C,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,cAAc,KAAK,0BAA0B;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,cAAc;AAClF,uDAAuD,OAAO;AAC9D,kDAAkD,gBAAgB;AAClE,4DAA4D,gBAAgB;AAC5E,qDAAqD,uBAAuB;AAC5E,sDAAsD,wBAAwB;AAC9E;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,kCAAkC;AAClC,uBAAuB;AACvB;AACA;AACA,kBAAkB,yEAAY;AAC9B;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,mBAAmB;AACnB,mBAAmB;AACnB,gBAAgB;AAChB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,+BAA+B;AAC/B,yBAAyB;AACzB,0BAA0B,0CAA0C;AACpE,yBAAyB,0CAA0C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,iBAAiB;AACjB,wBAAwB,0CAA0C,aAAa;AAC/E;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B,gCAAgC,yEAAY;AAC5C;AACA;AACA,sBAAsB,uEAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uDAAS;AACjC;AACA;AACA;AACA;AACA;AACA,yDAAyD,cAAc;AACvE,UAAU;AACV;AACA;AACA,yDAAyD,cAAc;AACvE,UAAU;AACV;AACA;AACA,iDAAiD,aAAa;AAC9D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,kBAAkB;AAC/B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,iBAAiB;AAC9B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,4EAA4E,cAAc;AAC1F;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,YAAY;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,cAAc;AAC/D;AACA;AACA,UAAU;AACV;AACA,4EAA4E,cAAc;AAC1F;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uDAAS;AACjC;AACA;AACA;AACA,qCAAqC,0EAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC32BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO,mDAAmD;AAC1D,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA,gEAAgE,MAAM;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sCAAsC;AAC5E,oCAAoC,oCAAoC;AACxE;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACO;AACP;AACA;AACA;AACA,4CAA4C,UAAU,IAAI,eAAe;AACzE,iDAAiD,kBAAkB;AACnE,iDAAiD,iBAAiB;AAClE,iDAAiD,mCAAmC;AACpF;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA,sDAAsD,kBAAkB;AACxE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,cAAc;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU,IAAI,OAAO;AAC/D,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,cAAc;AACzB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,UAAU,IAAI,uBAAuB;AAChG,aAAa;AACb;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACO;AACP,+BAA+B,WAAW,GAAG,wCAAwC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,WAAW;AACxF;AACA,SAAS;AACT;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,2EAA2E,WAAW;AACtF;AACA;AACA;;;AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACkB;AACQ;AACjC;AACE;AACe;AAK3B;AACrC;AACA,MAAM,SAAK,GAAG,oCAAkB;AAChC,MAAM,iBAAa,OAAO,wCAAmB;AAC7C;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,wCAAwC;AACxC;AACA,wCAAwC;AACxC;AACA;AACA;AACA,wCAAwC;AACxC;AACA,wCAAwC;AACxC;AACA;AACA;AACA,wCAAwC;AACxC;AACA,yCAAyC;AACzC;AACA;AACA,iCAAiC;AACjC,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iFAAiF;AAC7F;AACA,YAAY,gFAAgF;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAA+C;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS,oDAAoD;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,kDAAkD,MAAM;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO,kCAAkC,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kCAAkC,sBAAsB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,cAAc,GAAG,eAAe;AACjI;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,2BAA2B,sCAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACO;AACP,WAAW,oCAAiB;AAC5B,qCAAqC,sCAAY;AACjD;AACA;AACA,4CAA4C,eAAe;AAC3D;AACA;AACA,iEAAiE,iBAAiB,EAAE,oBAAoB;AACxG;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB,UAAU,yCAAyC;AACrH;AACA,UAAU;AACV;AACA,YAAY,iBAAa;AACzB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,iBAAiB;AAC9B;AACO;AACP,WAAW,oCAAiB;AAC5B,qCAAqC,sCAAY;AACjD;AACA;AACA,YAAY,SAAK;AACjB;AACA;AACA;AACA;AACA,4CAA4C,eAAe;AAC3D;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,+DAA+D,oBAAoB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAK;AACrB;AACA;AACA;AACA,YAAY,SAAK;AACjB;AACA,UAAU;AACV;AACA,YAAY,SAAK;AACjB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACO;AACP,WAAW,oCAAiB;AAC5B,iCAAiC,uCAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,iBAAiB;AACjF,4DAA4D,eAAe;AAC3E,8CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA,oEAAoE,cAAc;AAClF;AACA;AACA;AACA;AACA,2DAA2D,iBAAiB;AAC5E;AACA;AACA;AACA;AACA,yDAAyD,eAAe;AACxE;AACA;AACA;AACA;AACA,yDAAyD,mBAAmB;AAC5E;AACA;AACA;AACA;AACA,6DAA6D,gBAAgB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,IAAI;AAC/C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,EAAE;AACF;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACO;AACP,WAAW,oCAAiB;AAC5B,iCAAiC;AACjC;AACA;AACA,2CAA2C,IAAI;AAC/C;AACA;AACA;AACA,oCAAoC,sCAAY;AAChD,mCAAmC;AACnC;AACA;AACA,mEAAmE,iBAAiB;AACpF;AACA;AACA,gDAAgD,sBAAsB;AACtE;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,8BAA8B,sBAAS;AACvC;AACA,kBAAkB;AAClB,8DAA8D,cAAc;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,wBAAwB;AAC1F,sBAAsB;AACtB,kEAAkE,UAAU;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,mBAAmB;AAC5F;AACA,kBAAkB;AAClB;AACA,4EAA4E,0BAA0B;AACtG,kEAAkE,mBAAmB;AACrF,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,mBAAmB;AACrG;AACA,0BAA0B;AAC1B;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,mBAAmB;AACzF;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,sEAAsE,mBAAmB,wBAAwB,mBAAmB;AACpI;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,mBAAmB;AACtG;AACA,0BAA0B;AAC1B;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,mBAAmB,UAAU,0BAA0B;AAClI;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU,wBAAwB,mBAAmB;AACrG;AACA;AACA;AACA,6EAA6E,gCAAgC,EAAE,8BAA8B,qBAAqB,YAAY;AAC9K,0BAA0B;AAC1B,0EAA0E,UAAU;AACpF;AACA;AACA,uCAAuC;AACvC;AACA,kBAAkB;AAClB;AACA,qDAAqD,YAAY,SAAS,kBAAkB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,YAAY;AACzE;AACA,0BAA0B,+BAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,WAAW,qBAAqB,gBAAgB,uBAAuB,6BAA6B;AACzJ,gDAAgD,gBAAgB;AAChE;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,6DAA6D,cAAc;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,iBAAiB;AAC9B;AACO;AACP,WAAW,oCAAiB;AAC5B,wBAAwB,sBAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,wBAAwB,SAAK;AAC7B;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ,6CAA6C;AAChE,aAAa,iBAAiB;AAC9B;AACO;AACP,WAAW,oCAAiB;AAC5B,QAAQ,SAAK;AACb;AACA;AACA,wBAAwB,sBAAS;AACjC;AACA;AACA;AACA,sBAAsB,+BAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wBAAwB;AACtD;AACA;AACA,wDAAwD,QAAQ,GAAG,YAAY;AAC/E;AACA,8DAA8D,WAAW;AACzE,gEAAgE,aAAa;AAC7E,8DAA8D,WAAW;AACzE,qEAAqE,kBAAkB;AACvF,wEAAwE,UAAU;AAClF,+DAA+D,cAAc;AAC7E,+EAA+E,UAAU;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY,WAAW,kBAAkB;AAC3E,kCAAkC,YAAY,aAAa;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sCAAY;AACpD;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAK;AACrB;AACA;AACA;AACA,8BAA8B,+BAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA,sCAAsC,+BAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,iFAAiF;AACjF;AACA,6DAA6D,SAAS;AACtE;AACA;AACA;AACA,sBAAsB;AACtB;AACA,kCAAkC,+BAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,4DAA4D;AAC5D;AACA;AACA;AACA,8EAA8E,SAAS;AACvF,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,wDAAwD,QAAQ,GAAG,aAAa;AAChF;AACA;AACA;AACA;AACA,+EAA+E;AAC/E,wDAAwD,eAAe,OAAO,YAAY;AAC1F;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,aAAa;AACnE,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA,0BAA0B,+BAAgB;AAC1C;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,wBAAwB,+BAAgB,+CAA+C,aAAa;AACpG;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,iBAAiB;AAC9B;AACO;AACP,WAAW,oCAAiB;AAC5B,gCAAgC,sCAAY;AAC5C;AACA;AACA,sBAAsB,+BAAgB;AACtC;AACA;AACA,QAAQ,SAAK;AACb;AACA;AACA;AACA,2DAA2D;AAC3D,4EAA4E;AAC5E,QAAQ,SAAK;AACb;AACA;AACA;AACA;AACA,wCAAwC,yBAAyB;AACjE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,sBAAsB,+BAAgB,sBAAsB,oBAAoB;AAChF;AACA;AACA;AACA,QAAQ,SAAK;AACb,QAAQ,SAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,KAAK,IAAI,8BAA8B;AACtH,2BAA2B,KAAK,kBAAkB,aAAa,MAAM,SAAS;AAC9E,KAAK;AACL;AACA;AACA;AACA,kFAAkF,KAAK,IAAI,8BAA8B;AACzH,2BAA2B,KAAK,qBAAqB,aAAa,MAAM,SAAS;AACjF,KAAK;AACL;AACA;AACA,+DAA+D,IAAI;AACnE,8EAA8E,KAAK,IAAI,8BAA8B;AACrH,2BAA2B,KAAK,kBAAkB,aAAa,MAAM,SAAS;AAC9E,KAAK;AACL;AACA;AACA,iBAAiB;AACjB,kCAAkC,WAAW,IAAI;AACjD,oEAAoE,SAAS,IAAI,8BAA8B;AAC/G,iBAAiB,iBAAiB,aAAa,MAAM,SAAS;AAC9D,KAAK;AACL;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,kEAAkE,gBAAgB,KAAK,gBAAgB;AACvG,mBAAmB,QAAQ;AAC3B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,qCAAqC;AACrC;AACA;AACA,wCAAwC;AACxC;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B,KAAK;AACL;AACA;AACA;AACA,2EAA2E,KAAK;AAChF,2BAA2B,KAAK;AAChC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACO;AACP,WAAW,oCAAiB;AAC5B;AACA,gCAAgC,sCAAY;AAC5C,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+BAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+BAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA,qBAAqB;AACrB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,gBAAgB,KAAK,YAAY;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,uBAAuB;AACpG;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,qFAAqF,KAAK;AAC1F;AACA;AACA;AACA;AACA,iEAAiE,SAAS;AAC1E,0CAA0C;AAC1C,6CAA6C;AAC7C;AACA,qDAAqD,2CAA2C;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,8BAA8B,uBAAuB,KAAK;AAC3I,2CAA2C,KAAK,kBAAkB,aAAa,MAAM,SAAS;AAC9F,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oCAAoC;AACpE;AACA;AACA,gCAAgC,gCAAgC;AAChE,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,sBAAsB,+BAAgB;AACtC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,iBAAiB;AAC9B;AACO;AACP,WAAW,oCAAiB;AAC5B,gCAAgC,sCAAY;AAC5C,4DAA4D;AAC5D;AACA,wCAAwC;AACxC,wCAAwC;AACxC;AACA,QAAQ,SAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,8BAAU;AACnC;AACA;AACA;AACA,YAAY,SAAK;AACjB;AACA;AACA;AACA;AACA,mEAAmE,QAAQ,MAAM,IAAI;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,kBAAkB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,mBAAmB;AAC9E,YAAY,SAAK;AACjB,UAAU;AACV,YAAY,SAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAK;AACjB;AACA;AACA;AACA;AACA,QAAQ,SAAK,iCAAiC,cAAc;AAC5D,uDAAuD,sBAAsB,gBAAgB,mBAAmB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAK;AACrB;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oJAAoJ,MAAM;AAC1J;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ,SAAK;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA,IAAI,SAAK;AACT;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;ACp4Da;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,gDAAgD;AAChD;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,sFAAsF,qBAAqB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,iDAAiD,qBAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,sDAAsD,qBAAqB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;ACpFa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,cAAc;AACrE;AACA;AACA;AACA;AACA,E;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACqC;AACrC;AACA,eAAe,iGAA8B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,+DAA+D,WAAW;AAC1E;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;AACA,qFAAqF,WAAW;AAChG;AACA;AACA;AACA,cAAc;AACd,2DAA2D,WAAW;AACtE;AACA;AACA;AACA,qEAAqE,WAAW,YAAY,YAAY,GAAG,YAAY;AACvH,yDAAyD,WAAW,YAAY,YAAY,GAAG,YAAY;AAC3G,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kEAAkE,WAAW;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,WAAW;AACnE;AACA,cAAc;AACd,oDAAoD,WAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,6DAA6D,kBAAkB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,kBAAkB;AACnC;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6CAA6C,cAAc;AAC3D;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,mDAAmD,cAAc;AACjE;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA,qDAAqD,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA,0DAA0D,UAAU;AACpE;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA,yCAAyC,cAAc;AACvD;AACA;AACA,iDAAiD,eAAe;AAChE,UAAU;AACV,6CAA6C,eAAe;AAC5D;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0C;AACnC;AACP,sEAAe,4DAAY,IAAC;;;;;;;;ACrTf;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AAC2C;AACK;AACP;AACzC;AACA;AACA,cAAc,uEAAkB;AAChC;AACA;AACA;AACA;AACA,oCAAoC;AACpC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,WAAW,8DAAY;AACvB,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI,qBAAqB;AAC9B;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,WAAW,8DAAY;AACvB,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,WAAW,8DAAY;AACvB;AACA,6BAA6B,kDAAS;AACtC;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,WAAW,8DAAY;AACvB;AACA,6BAA6B,kDAAS;AACtC;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kDAAS;AAC3B,UAAU;AACV;AACA,yBAAyB;AACzB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,WAAW,8DAAY;AACvB;AACA,6BAA6B,kDAAS;AACtC;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,UAAU;AACV;AACA,qBAAqB;AACrB;AACA,KAAK,IAAI,sBAAsB;AAC/B;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,WAAW,8DAAY;AACvB;AACA,6BAA6B,kDAAS;AACtC;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kDAAS;AAC3B,UAAU;AACV;AACA,yBAAyB;AACzB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA,WAAW,8DAAY;AACvB;AACA;AACA,yCAAyC;AACzC,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,aAAa;AAC1B;AACA;AACA,WAAW,8DAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA,WAAW,8DAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,oCAAoC;AACpC,oCAAoC,KAAK;AACzC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB;AACA;AACA,WAAW,8DAAY;AACvB;AACA,6BAA6B,kDAAS;AACtC;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,2CAA2C,IAAI;AAC/C;AACA,YAAY,kDAAS;AACrB;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA;AAsBE;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3cF;AACA;AACA;AACA;AACA;AACA;AACA;AACoD;AACE;AACkB;AAI3C;AACmC;AAChE;AACA,cAAc,4EAAkB;AAChC,0BAA0B,iFAAmB;AAC7C;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS,iCAAiC,GAAG;AAC1D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB,QAAQ,wFAAuB;AACtE;AACA;AACA;AACA;AACA,+CAA+C,gBAAgB,gBAAgB,oBAAoB;AACnG;AACA;AACA,4CAA4C,gBAAgB,cAAc,oBAAoB;AAC9F;AACA,UAAU;AACV,gEAAgE,cAAc;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,SAAS,mCAAmC,GAAG;AAC5D;AACO;AACP;AACA;AACA,gBAAgB,sBAAsB,QAAQ,wFAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,KAAK;AAC7E;AACA;AACA;AACA,cAAc;AACd,qDAAqD,KAAK,IAAI,cAAc;AAC5E;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA,wCAAwC,UAAU,oBAAoB,eAAe;AACrF,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA,wCAAwC;AACxC,wCAAwC;AACxC;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB,+BAA+B,gBAAgB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,IAAI;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,aAAa,QAAQ,gBAAgB,MAAM,aAAa,QAAQ,gBAAgB;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB,IAAI,gBAAgB,IAAI,sBAAsB;AACjG;AACA,uCAAuC,IAAI,QAAQ,QAAQ;AAC3D;AACA;AACA;AACA;AACA,6BAA6B,sBAAsB,mBAAmB,uBAAuB;AAC7F;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sBAAsB,oBAAoB,gBAAgB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,gDAAgD,IAAI;AACpD;AACA;AACA;AACA,kCAAkC,4BAA4B,6BAA6B,kBAAkB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA,yCAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,KAAK,WAAW,KAAK;AAC3E,cAAc;AACd;AACA,sDAAsD,KAAK,WAAW,KAAK;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qBAAqB,UAAU,oBAAoB;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,wCAAwC;AACxC;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB,cAAc,UAAU;AACxB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,UAAU;AACxB,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,aAAa;AAC3B,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACO;AACP,WAAW,4EAAiB;AAC5B,4BAA4B,0EAAa;AACzC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,oBAAoB;AACjC;AACO;AACP,WAAW,4EAAiB;AAC5B,4BAA4B,0EAAa;AACzC;AACA;AACA;AACA,8CAA8C,KAAK,KAAK,wDAAwD;AAChH;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,6BAA6B;AAC1C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,IAAI,KAAK,wDAAwD;AACnH;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,6BAA6B;AAC1C;AACO;AACP,WAAW,4EAAiB;AAC5B,4BAA4B,0EAAa;AACzC;AACA,gCAAgC,uEAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,UAAU;AACvB;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM,cAAc,MAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,4EAA4E;AAC5E,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACO;AACP;AACA,oEAAoE,iBAAiB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,0CAA0C,kBAAkB,KAAK,2BAA2B,IAAI,MAAM,GAAG,6BAA6B,OAAO,OAAO;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,iBAAiB,IAAI,wBAAwB;AAC1G;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ,QAAQ,2BAA2B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ,cAAc,2BAA2B;AACxE;AACA,0CAA0C,8BAA8B;AACxE;AACA;AACA,sDAAsD,8BAA8B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,wBAAwB;AACrC;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA;AACA;AACA;AACA,oCAAoC,0EAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,iBAAiB;AAChG;AACA;AACA;AACA;AACA,6DAA6D,eAAe;AAC5E,oEAAoE,kBAAkB;AACtF;AACA;AACA;AACA,yEAAyE,cAAc;AACvF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yEAAY;AAC1B;AACA;AACA;AACA,cAAc,iEAAmB;AACjC;AACA;AACA;AACA,4FAA4F,wBAAwB;AACpH,UAAU;AACV,0DAA0D,0BAA0B;AACpF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,wBAAwB;AACrC;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA;AACA;AACA,oCAAoC,0EAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,cAAc,yEAAY;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B,4BAA4B,0EAAa;AACzC;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yEAAY;AAC1B,cAAc,4EAAe;AAC7B;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY,OAAO,WAAW;AACtE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yEAAY;AAC1B;AACA;AACA,cAAc,yEAAY;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACO;AACP,WAAW,4EAAiB;AAC5B,gCAAgC,yEAAY;AAC5C;AACA;AACA,sBAAsB,uEAAgB;AACtC;AACA;AACA;AACA;AACA,cAAc,yEAAY;AAC1B;AACA;AACA;AACA;AACA;AACA,8BAA8B,eAAe,EAAE,OAAO;AACtD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,wBAAwB;AACrC;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA,sBAAsB,uEAAgB;AACtC;AACA;AACA;AACA;AACA;AACA,kBAAkB,yEAAY;AAC9B,sBAAsB,uEAAgB,eAAe,YAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,YAAY;AAChE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACO;AACP,WAAW,4EAAiB;AAC5B,4BAA4B,0EAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8EAAiB,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA,wCAAwC,gBAAgB;AACxD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,aAAa,SAAS;AACtB;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA;AACA;AACA;AACA,4BAA4B,0EAAa;AACzC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,iBAAiB;AAC9B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA,KAAK;AACL;;;;;;;;AChqCa;;AAEb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AAC2C;AAC3C;AACA,eAAe,sGAA8B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,oDAAoD;AACpD,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,8CAA8C;AAC9C,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,oDAAoD;AACpD,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA,2CAA2C,IAAI,YAAY,EAAE,QAAQ;AACrE,0CAA0C,oBAAoB,iBAAiB;AAC/E,iDAAiD,aAAa,SAAS,SAAS,GAAG,4BAA4B;AAC/G;AACA,4CAA4C,iBAAiB,gBAAgB,IAAI,SAAS;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA,qCAAqC,WAAW;AAChD;AACA,4CAA4C,IAAI,QAAQ;AACxD,0CAA0C;AAC1C,uHAAuH,UAAU;AACjI,4GAA4G,UAAU;AACtH;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+B;AAC/B,iEAAe,aAAa,EAAC;;;;;;;;;;;;;AC9N7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY,GAAG,WAAW,IAAI,UAAU;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA,uBAAuB,WAAW,GAAG,UAAU;AAC/C;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA,uBAAuB,WAAW,GAAG,UAAU;AAC/C;AACA;AACA;AACA,mDAAmD,UAAU;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU,KAAK,oBAAoB;AACnF;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuB;AACvB;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA,iEAAe,WAAW,EAAC;;;;;;;;ACvLd;;AAEb;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wB;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AAC2C;AAC3C;AACA,eAAe,sGAA8B;AAC7C;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACO;AACP;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,UAAU;AACvB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,UAAU;AACvB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,SAAS;AACtB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA,oBAAoB,eAAe;AACnC,wBAAwB,eAAe;AACvC;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,KAAK;AACjC,6BAA6B,MAAM;AACnC,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxOF;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACkB;AAK3C;AACkB;AACE;AACe;AAC6E;AACjG;AAC4C;AACzC;AAC/C;AACA,cAAc,4EAAkB;AAChC,0BAA0B,iFAAmB;AAC7C;AACA;AACA;AACA,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0EAAa;AAC9C,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mCAAmC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oFAA0B;AAChE;AACA;AACA,wDAAwD,uEAAU,+BAA+B;AACjG;AACA;AACA;AACA,oEAAoE,uEAAU,iCAAiC,IAAI;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,uEAAU,0BAA0B;AAC/G;AACA;AACA,8BAA8B;AAC9B,8BAA8B,uEAAU;AACxC,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA,0FAA0F,uEAAU,0BAA0B;AAC9H;AACA;AACA,qFAAqF,4CAA4C,eAAe,uEAAU,0BAA0B;AACpL;AACA;AACA,4FAA4F,uEAAU,0BAA0B,WAAW,2CAA2C;AACtL,qDAAqD,8CAA8C;AACnG;AACA,2FAA2F,uEAAU,0BAA0B;AAC/H;AACA;AACA;AACA;AACA,sBAAsB;AACtB,sBAAsB;AACtB;AACA,4CAA4C,qBAAqB;AACjE,yCAAyC,YAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA,iCAAiC,0EAAa;AAC9C;AACA;AACA;AACA,qCAAqC,uEAAU;AAC/C,oCAAoC,uEAAU;AAC9C,kCAAkC,uEAAU;AAC5C;AACA,wBAAwB,uDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,oBAAoB;AAC/E;AACA;AACA;AACA,+CAA+C,eAAe,cAAc,eAAe,iBAAiB,gBAAgB,aAAa,gBAAgB;AACzJ;AACA;AACA;AACA;AACA,2DAA2D,eAAe,EAAE;AAC5E;AACA;AACA,yDAAyD;AACzD;AACA;AACA,6DAA6D;AAC7D;AACA;AACA,yDAAyD;AACzD;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B,iCAAiC,0EAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,WAAW,qCAAqC,sBAAsB;AAClH;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,sBAAsB,yEAAe;AACrC,gDAAgD,YAAY,OAAO,WAAW;AAC9E,cAAc;AACd;AACA;AACA,UAAU;AACV,iDAAiD,cAAc;AAC/D,UAAU;AACV;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4EAAkB;AACpC,wDAAwD,qBAAqB;AAC7E,UAAU;AACV,+DAA+D,cAAc;AAC7E,UAAU;AACV;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B,iCAAiC,0EAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4EAAkB;AACzD,4CAA4C,cAAc;AAC1D,UAAU;AACV,+DAA+D,cAAc;AAC7E,UAAU;AACV;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA,kCAAkC,uEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,kFAAkF,eAAe;AACjG,mGAAmG,uEAAU,gBAAgB;AAC7H,8CAA8C,kBAAkB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAU;AAC5B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB,uEAAU;AAC5B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B,+CAA+C,0EAAa,QAAQ;AACpE;AACA;AACA;AACA;AACA;AACA,4DAA4D,mCAAmC;AAC/F,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,6DAA6D,iBAAiB;AAC9E;AACA;AACA,uGAAuG,kBAAkB,oBAAoB,mBAAmB,iBAAiB;AACjL,yFAAyF,kBAAkB,oBAAoB,mBAAmB,iBAAiB;AACnK,0BAA0B,oFAA0B,kEAAkE,kBAAkB,oBAAoB,mBAAmB,iBAAiB;AAChM;AACA;AACA,qDAAqD,oCAAoC,gBAAgB,aAAa,uEAAU,0BAA0B;AAC1J;AACA;AACA;AACA,+CAA+C,eAAe,4CAA4C,gDAAgD,mBAAmB;AAC7K,sDAAsD;AACtD,8BAA8B,wEAAwE;AACtG,8BAA8B,uEAAU;AACxC,8BAA8B;AAC9B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,wBAAwB,kBAAkB;AACnF,kBAAkB;AAClB,8CAA8C,mBAAmB;AACjE,4HAA4H,mCAAmC;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uDAAS;AACjC,2EAA2E,gCAAgC;AAC3G,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sBAAsB,+EAAqB;AAC3C,cAAc;AACd,gEAAgE,cAAc;AAC9E,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kBAAkB,sEAAc;AAChC,SAAS;AACT;AACA;AACA;AACA;AACA,wCAAwC,yEAAY;AACpD;AACA;AACA,0BAA0B,yEAAY;AACtC;AACA,qEAAqE,KAAK;AAC1E;AACA,cAAc;AACd,8DAA8D,cAAc;AAC5E;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0BAA0B;AACrE;AACA;AACA;AACA,kFAAkF,wBAAwB;AAC1G,0CAA0C,0BAA0B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG,kCAAkC;AACvI;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc,sBAAsB,mDAAmD,IAAI;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,8CAA8C,kBAAkB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,cAAc;AAC9E;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA,+EAA+E,UAAU,WAAW,cAAc;AAClH,4BAA4B,OAAO;AACnC,wBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B,mCAAmC,uEAAU;AAC7C,cAAc,uEAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B,wBAAwB,uDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,iDAAiD,aAAa;AAC9D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA,kCAAkC,uEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA;AACA,kBAAkB,uEAAU;AAC5B;AACA,SAAS;AACT;AACA;AACA,kBAAkB,uEAAU;AAC5B;AACA,SAAS;AACT;AACA;AACA,kBAAkB,uEAAU;AAC5B;AACA,SAAS;AACT;AACA;AACA,kBAAkB,uEAAU;AAC5B,SAAS;AACT;AACA;AACA,kBAAkB,uEAAU;AAC5B,SAAS;AACT;AACA;AACA,kBAAkB,uEAAU;AAC5B,SAAS;AACT;AACA;AACA;AACA,sBAAsB,mEAAgB;AACtC;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,uEAAU;AAC5B,SAAS;AACT;AACA;AACA;AACA,kBAAkB,uEAAU;AAC5B,SAAS;AACT;AACA;AACA,kBAAkB,uEAAU;AAC5B,SAAS;AACT;AACA;AACA,kBAAkB,uEAAU;AAC5B,SAAS;AACT;AACA;AACA,kBAAkB,uEAAU;AAC5B,SAAS;AACT;AACA;AACA,kBAAkB,uEAAU;AAC5B,SAAS;AACT;AACA;AACA,kBAAkB,uEAAU;AAC5B,SAAS;AACT;AACA;AACA;AACA,sCAAsC,uEAAU;AAChD,kBAAkB,yEAAe;AACjC;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,wEAAc;AAChC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY,8EAAoB;AAChC;AACA,SAAS;AACT;AACA;AACA,oBAAoB,gBAAgB,QAAQ,wFAAyB;AACrE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW,4EAAiB;AAC5B,+BAA+B,yEAAY;AAC3C,iCAAiC,0EAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB,QAAQ,wFAAkB;AACvE,wBAAwB,YAAY,QAAQ,wFAA4B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,+CAA+C,8BAA8B,GAAG,iCAAiC;AACjH;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mEAAmE,iBAAiB,mBAAmB,iBAAiB;AACxH;AACA,iEAAiE,+BAA+B,qBAAqB;AACrH,+DAA+D,gBAAgB,IAAI,QAAQ;AAC3F;AACA;AACA,mEAAmE,eAAe;AAClF,oDAAoD,IAAI,IAAI;AAC5D,oDAAoD,IAAI,aAAa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gBAAgB,kCAAkC,qBAAqB;AACjH;AACA;AACA,6CAA6C,oBAAoB;AACjE,8CAA8C,eAAe,UAAU,2BAA2B,4BAA4B,kBAAkB;AAChJ,+FAA+F,gBAAgB,0BAA0B;AACzI,6FAA6F,gBAAgB,0BAA0B;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA,gDAAgD,oBAAoB;AACpE;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,wEAAwE,cAAc;AACtF;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW,4EAAiB;AAC5B;AACA,+BAA+B,uDAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,mBAAmB,gBAAgB;AAC/G;AACA;AACA,UAAU;AACV,iDAAiD,cAAc;AAC/D,2DAA2D,cAAc;AACzE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA,yDAAyD,uEAAU;AACnE,8DAA8D,uEAAU;AACxE,uDAAuD,uEAAU;AACjE,gDAAgD,uEAAU;AAC1D,qDAAqD,uEAAU;AAC/D,kDAAkD,uEAAU;AAC5D,0DAA0D,uEAAU;AACpE,uDAAuD,uEAAU;AACjE,oDAAoD,uEAAU;AAC9D,uDAAuD,uEAAU;AACjE,0DAA0D,uEAAU;AACpE,kEAAkE,uEAAU;AAC5E,4DAA4D,uEAAU;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;;;ACjnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACsD;AACkB;AACqC;AAC9D;AACiB;AAC6C;AACgE;AAC7F;AACb;AACnE;AACA,cAAc,4EAAkB;AAChC,0BAA0B,iFAAmB;AAC7C;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC;AACA;AACA,uEAAuE;AACvE,yCAAyC;AACzC,kDAAkD;AAClD;AACA;AACA,2CAA2C;AAC3C,wCAAwC;AACxC,wCAAwC;AACxC;AACA;AACA;AACA,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC;AACA;AACA,wCAAwC;AACxC,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yEAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA,cAAc;AACd,8EAA8E,kBAAkB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qEAAmB;AACpD;AACA,mCAAmC,2DAAmB;AACtD;AACA,mCAAmC,0EAAa;AAChD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,WAAW,4EAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4EAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,MAAM;AACzE;AACA;AACA;AACA;AACA;AACA,mCAAmC,+EAAqB;AACxD;AACA;AACA;AACA;AACA,kBAAkB,yEAAe;AACjC,kBAAkB,iEAAmB;AACrC;AACA,UAAU;AACV;AACA,yCAAyC,4EAAkB;AAC3D;AACA;AACA;AACA;AACA,sBAAsB,yEAAe;AACrC,sBAAsB,iEAAmB;AACzC;AACA,cAAc;AACd;AACA,2CAA2C,yEAAe;AAC1D;AACA,sBAAsB,iEAAmB;AACzC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACO;AACP;AACA,oDAAoD,iBAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,uCAAuC;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,uDAAuD,4BAA4B;AACnF,kDAAkD,uBAAuB;AACzE,sDAAsD,2BAA2B;AACjF,6DAA6D,gBAAgB;AAC7E;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,iBAAiB;AAC9B;AACO;AACP;AACA;AACA,8CAA8C,gBAAgB,uBAAuB,wBAAwB;AAC7G,sDAAsD,qCAAqC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iBAAiB;AAClE;AACA;AACA;AACA,uFAAuF,QAAQ;AAC/F;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,8EAA8E,QAAQ,IAAI,cAAc;AACxG,wDAAwD,qCAAqC;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,qCAAqC;AACvH,0BAA0B;AAC1B;AACA;AACA,4FAA4F,cAAc;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,yBAAyB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,gEAAgE,SAAS,IAAI,cAAc;AAC3F,wDAAwD,sCAAsC;AAC9F;AACA;AACA;AACA;AACA,UAAU;AACV,iDAAiD,cAAc;AAC/D;AACA;AACA;AACA;AACA,KAAK,IAAI,mGAAmG;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,KAAK;AAC9C;AACA;AACA;AACA,kDAAkD,gDAAgD;AAClG;AACA;AACA,wDAAwD,KAAK;AAC7D,sEAAsE,KAAK;AAC3E;AACA;AACA;AACA,6CAA6C,KAAK;AAClD,mDAAmD,uBAAuB;AAC1E;AACA;AACA,kEAAkE,KAAK;AACvE,0EAA0E,KAAK;AAC/E;AACA;AACA,gDAAgD,mDAAmD;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA;AACA,sDAAsD,4BAA4B,cAAc,GAAG,+BAA+B,gBAAgB;AAClJ,sCAAsC,8DAA8D;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,2BAA2B,UAAU,uBAAuB,KAAK,yCAAyC;AAChK,uBAAuB;AACvB;AACA;AACA;AACA,2DAA2D,2BAA2B,OAAO,uBAAuB,KAAK,yCAAyC;AAClK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,2BAA2B;AACzE;AACA;AACA;AACA;AACA;AACA,kDAAkD,4BAA4B;AAC9E;AACA;AACA;AACA;AACA,8CAA8C,2BAA2B;AACzE,mDAAmD,uBAAuB;AAC1E;AACA;AACA,mEAAmE,2BAA2B;AAC9F,0EAA0E,2BAA2B;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,2BAA2B;AAC/E;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO,4CAA4C,aAAa;AAC3E,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B,mBAAmB,yEAAY;AAC/B;AACA;AACA;AACA;AACA;AACA,gCAAgC,yEAAY;AAC5C;AACA,4BAA4B,uDAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,SAAS,WAAW,OAAO,eAAe,cAAc,gBAAgB,0BAA0B;AAC7J;AACA;AACA;AACA;AACA,sCAAsC,2DAAkB;AACxD;AACA;AACA;AACA,6DAA6D,gBAAgB,kBAAkB,uBAAuB,qBAAqB,gBAAgB;AAC3J,+CAA+C,qCAAqC;AACpF,sGAAsG,gBAAgB;AACtH;AACA;AACA,oCAAoC,yEAAsB;AAC1D;AACA,gDAAgD,0BAA0B,YAAY,eAAe;AACrG;AACA;AACA;AACA,gEAAgE,eAAe,IAAI,gBAAgB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yEAAsB;AAC3D,gCAAgC,MAAM,IAAI,aAAa,MAAM,OAAO;AACpE,aAAa;AACb;AACA,2CAA2C,gBAAgB,iBAAiB,yBAAyB;AACrG,4DAA4D,uBAAuB,WAAW,0BAA0B,QAAQ,uBAAuB,eAAe,gBAAgB;AACtL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,0BAA0B,cAAc,gBAAgB,YAAY,cAAc;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,gBAAgB;AACnF;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA,wEAAwE,MAAM,GAAG,eAAe;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,MAAM,GAAG,eAAe,aAAa,WAAW,GAAG,cAAc,GAAG,cAAc;AACjJ;AACA;AACA,iFAAiF,eAAe,GAAG,SAAS;AAC5G;AACA;AACA,kDAAkD,uEAAoB;AACtE;AACA;AACA,2CAA2C,kEAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,iEAAiE,MAAM,IAAI,cAAc;AACzF,oEAAoE,WAAW,GAAG,aAAa,eAAe,aAAa;AAC3H,4DAA4D,MAAM;AAClE;AACA,iDAAiD,OAAO,UAAU,cAAc;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB,GAAG;AAC1C,2BAA2B;AAC3B,kBAAkB,cAAc;AAChC;AACA,mEAAmE,kBAAkB,GAAG,gBAAgB,cAAc,eAAe,UAAU,uBAAuB;AACtK;AACA;AACA,mEAAmE,eAAe;AAClF,cAAc;AACd,mEAAmE,eAAe;AAClF;AACA;AACA;AACA;AACA,4CAA4C,yEAAY;AACxD,sBAAsB,yEAAY;AAClC,sBAAsB,yEAAY;AAClC;AACA;AACA;AACA,kBAAkB,qEAAmB;AACrC,kBAAkB,2DAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,0BAA0B;AACtE;AACA;AACA;AACA;AACA,0CAA0C,uEAAoB;AAC9D;AACA;AACA,mCAAmC,kEAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,4BAA4B;AAC/E;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA,oDAAoD,cAAc;AAClE,UAAU;AACV;AACA;AACA;AACA,4CAA4C,yEAAY;AACxD,sBAAsB,yEAAY;AAClC,sBAAsB,yEAAY;AAClC;AACA;AACA,kBAAkB,qEAAmB;AACrC,kBAAkB,2DAAmB;AACrC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B,mBAAmB,yEAAY,4BAA4B,yEAAY;AACvE;AACA;AACA;AACA,wBAAwB,uDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yEAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yEAAY;AAClC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,cAAc;AACd;AACA,sBAAsB,yEAAY;AAClC;AACA;AACA;AACA;AACA;AACA,kCAAkC,yEAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yEAAY;AAClC,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA,2EAA2E,UAAU,WAAW,kCAAkC,wCAAwC,gDAAgD,eAAe,qBAAqB,eAAe,iBAAiB;AAC9R;AACA;AACA,mDAAmD,cAAc;AACjE,yCAAyC,oBAAoB;AAC7D,6CAA6C;AAC7C,+GAA+G,oBAAoB,sBAAsB,kBAAkB;AAC3K;AACA,8CAA8C,kBAAkB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD,SAAS;AACT;AACA;AACA;AACA,sBAAsB,eAAe;AACrC,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAe,iBAAiB,iBAAiB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,kBAAkB,IAAI,8BAA8B,EAAE,eAAe;AACpH,uCAAuC,4BAA4B,QAAQ,gCAAgC,MAAM;AACjH,+BAA+B,QAAQ,SAAS,MAAM,kBAAkB,eAAe;AACvF,qGAAqG;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA;AACA,gBAAgB,qBAAqB,QAAQ,wFAAuB;AACpE;AACA;AACA;AACA,wBAAwB,uDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2DAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,eAAe,cAAc,YAAY;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,aAAa,GAAG,OAAO;AACjG;AACA;AACA,8CAA8C,uEAAoB;AAClE;AACA;AACA,uCAAuC,kEAAe;AACtD;AACA;AACA;AACA,0DAA0D,MAAM;AAChE;AACA;AACA;AACA;AACA;AACA,0DAA0D,MAAM;AAChE;AACA;AACA;AACA;AACA;AACA,0DAA0D,MAAM,yCAAyC,2BAA2B;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,wDAAwD,MAAM;AAC9D;AACA,6CAA6C,OAAO,UAAU,cAAc;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yEAAY;AAC1B;AACA;AACA,wCAAwC,yEAAY;AACpD,kBAAkB,yEAAY;AAC9B;AACA;AACA;AACA,cAAc,qEAAmB;AACjC,cAAc,2DAAmB;AACjC;AACA;AACA,iEAAiE,cAAc,aAAa,kBAAkB,GAAG,WAAW,sBAAsB,sBAAsB,YAAY,cAAc;AAClM;AACA;AACA;AACA;AACA;AACA,kEAAkE,gBAAgB;AAClF,UAAU;AACV,kEAAkE,gBAAgB;AAClF;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP,WAAW,4EAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wCAAwC;AAC1E,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;;;;;;UCtuCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA,mC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACCA,MAA8F;AAC9F,MAAoF;AACpF,MAA2F;AAC3F,MAA8G;AAC9G,MAAuG;AACvG,MAAuG;AACvG,MAAkG;AAClG;AACA;;AAEA;;AAEA,4BAA4B,6BAAmB;AAC/C,wBAAwB,0CAAa;AACrC,iBAAiB,+BAAa;AAC9B,iBAAiB,uBAAM;AACvB,6BAA6B,8BAAkB;;AAE/C,aAAa,kCAAG,CAAC,2BAAO;;;;AAI4C;AACpE,OAAO,4CAAe,2BAAO,IAAI,2BAAO,UAAU,2BAAO,mBAAmB,EAAC;;;;;;;;;;;;;;;;;;;;;;;ACxB7E;AACA;AACA;AACA;AACA;AACA;AACsB;AACtB;AACA;AAC0C;AACM;AACG;AACqC;AACxF;AACA;AACqD;AACc;AACnE;AACA;AAC2E;AACb;AAC9D;AAC4D;AACkD;AAC9G;AACA;AACA;AACA,mFAAmF,+BAAoB,EAAE,+BAAoB;AAC7H,oFAAoF,gCAAqB,EAAE,gCAAqB;AAChI,mFAAmF,+BAAoB,EAAE,+BAAoB;AAC7H,uEAAuE,mBAAQ,EAAE,mBAAQ;AACzF;AACA;AACA;AACA,8DAA8D,cAAc;AAC5E;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2DAA8B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,2BAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,4BAAa;AAC7B;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qBAAW,wBAAwB,+BAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,oBAAoB;AAC5G,gDAAgD,oBAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mCAAoB;AACtC;AACA;AACA;AACA,kBAAkB,oCAAqB;AACvC;AACA;AACA;AACA;AACA,kBAAkB,mCAAoB;AACtC;AACA;AACA;AACA;AACA,kBAAkB,uBAAQ;AAC1B;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wCAAiB;AACvC,aAAa;AACb;AACA;AACA;AACA,sBAAsB,wCAAiB;AACvC,aAAa;AACb;AACA;AACA;AACA;AACA,sBAAsB,gCAAW,GAAG,cAAc,4BAA4B;AAC9E,aAAa;AACb;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB,QAAQ,wFAAyB;AAC/E;AACA,aAAa;AACb;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2BAAY;AACpB;AACA,kBAAkB,2BAAY;AAC9B,YAAY,4BAAa;AACzB,yBAAyB;AACzB,SAAS;AACT;AACA;AACA,QAAQ,2BAAY;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,2BAAY;AACpB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA,qBAAqB,2BAAkB;AACvC,wBAAwB,kDAAkD,iCAAY,YAAY;AAClG,mBAAmB,qBAAW;AAC9B,oBAAoB,2BAAY;AAChC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe,2BAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAW;AACvB;AACA;AACA,SAAS,IAAI,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iCAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2BAAY;AACtC,wCAAwC,iCAAY;AACpD,wCAAwC,gCAAW;AACnD,yBAAyB,qBAAW;AACpC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,QAAQ,4BAAa;AACrB;AACA,CAAC;AACD;AACA,0CAAe,oEAAoB,IAAC","sources":["webpack://sillytavern-nametracker/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js","webpack://sillytavern-nametracker/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js","webpack://sillytavern-nametracker/./style.css","webpack://sillytavern-nametracker/./src/core/context.js","webpack://sillytavern-nametracker/./node_modules/style-loader/dist/runtime/styleTagTransform.js","webpack://sillytavern-nametracker/./src/modules/lorebook.js","webpack://sillytavern-nametracker/./tests/debug-parser.js","webpack://sillytavern-nametracker/./src/modules/llm.js","webpack://sillytavern-nametracker/./node_modules/css-loader/dist/runtime/api.js","webpack://sillytavern-nametracker/./node_modules/css-loader/dist/runtime/sourceMaps.js","webpack://sillytavern-nametracker/./src/core/errors.js","webpack://sillytavern-nametracker/./node_modules/style-loader/dist/runtime/insertStyleElement.js","webpack://sillytavern-nametracker/./src/core/settings.js","webpack://sillytavern-nametracker/./src/modules/characters.js","webpack://sillytavern-nametracker/./node_modules/style-loader/dist/runtime/insertBySelector.js","webpack://sillytavern-nametracker/./src/utils/notifications.js","webpack://sillytavern-nametracker/./src/core/debug.js","webpack://sillytavern-nametracker/./node_modules/style-loader/dist/runtime/styleDomAPI.js","webpack://sillytavern-nametracker/./src/utils/helpers.js","webpack://sillytavern-nametracker/./src/modules/ui.js","webpack://sillytavern-nametracker/./src/modules/processing.js","webpack://sillytavern-nametracker/webpack/bootstrap","webpack://sillytavern-nametracker/webpack/runtime/compat get default export","webpack://sillytavern-nametracker/webpack/runtime/define property getters","webpack://sillytavern-nametracker/webpack/runtime/hasOwnProperty shorthand","webpack://sillytavern-nametracker/webpack/runtime/nonce","webpack://sillytavern-nametracker/./style.css?f696","webpack://sillytavern-nametracker/./src/index.js"],"sourcesContent":["\"use strict\";\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce = typeof __webpack_nonce__ !== \"undefined\" ? __webpack_nonce__ : null;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;","\"use strict\";\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"./node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"./node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `/* Styles for the Name Tracker extension */\r\n\r\n.name-tracker-settings {\r\n    padding: 5px;\r\n}\r\n\r\n.name-tracker_block {\r\n    margin-bottom: 10px;\r\n}\r\n\r\n.name-tracker_block h4 {\r\n    margin-top: 10px;\r\n    margin-bottom: 10px;\r\n    font-weight: bold;\r\n}\r\n\r\n/* Status Display */\r\n.name-tracker-status-block {\r\n    background-color: var(--SmartThemeBlurTintColor);\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    border-radius: 5px;\r\n    padding: 10px;\r\n}\r\n\r\n.name-tracker-status {\r\n    font-weight: bold;\r\n    color: var(--SmartThemeBodyColor);\r\n    padding: 5px;\r\n    text-align: center;\r\n}\r\n\r\n/* Character List */\r\n.name-tracker-character-list {\r\n    max-height: 400px;\r\n    overflow-y: auto;\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    border-radius: 5px;\r\n    padding: 5px;\r\n    margin-top: 5px;\r\n}\r\n\r\n.name-tracker-character {\r\n    padding: 10px;\r\n    margin-bottom: 10px;\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    border-radius: 5px;\r\n    background-color: var(--SmartThemeBlurTintColor);\r\n}\r\n\r\n.name-tracker-character:last-child {\r\n    margin-bottom: 0;\r\n}\r\n\r\n/* Active/loaded character styling (characters that are loaded in SillyTavern) */\r\n.name-tracker-character.main-character {\r\n    border-left: 3px solid #4CAF50;\r\n    background-color: rgba(76, 175, 80, 0.05);\r\n}\r\n\r\n.character-header {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    margin-bottom: 5px;\r\n}\r\n\r\n.character-name {\r\n    font-weight: bold;\r\n    font-size: 1.1em;\r\n    color: var(--SmartThemeBodyColor);\r\n}\r\n\r\n.character-name .fa-user {\r\n    color: #4CAF50;\r\n    margin-right: 5px;\r\n}\r\n\r\n.character-name.ignored {\r\n    color: var(--SmartThemeQuoteColor);\r\n    text-decoration: line-through;\r\n}\r\n\r\n.character-badge {\r\n    display: inline-block;\r\n    padding: 2px 8px;\r\n    border-radius: 3px;\r\n    font-size: 0.75em;\r\n    font-weight: bold;\r\n    margin-left: 5px;\r\n}\r\n\r\n.character-badge.main-char {\r\n    background-color: #4CAF50;\r\n    color: #fff;\r\n}\r\n\r\n.character-badge.ignored {\r\n    background-color: #666;\r\n    color: #fff;\r\n}\r\n\r\n.character-badge.unresolved {\r\n    background-color: #ff9800;\r\n    color: #000;\r\n}\r\n\r\n/* Lorebook entry editor modal */\r\n.lorebook-entry-editor h3 {\r\n    margin-top: 0;\r\n    margin-bottom: 20px;\r\n    color: var(--SmartThemeBodyColor);\r\n}\r\n\r\n.editor-section {\r\n    margin-bottom: 15px;\r\n}\r\n\r\n.editor-section label {\r\n    display: block;\r\n    font-weight: bold;\r\n    margin-bottom: 5px;\r\n    color: var(--SmartThemeBodyColor);\r\n}\r\n\r\n.editor-section small {\r\n    display: block;\r\n    margin-top: 3px;\r\n    color: var(--SmartThemeQuoteColor);\r\n    font-size: 0.85em;\r\n}\r\n\r\n.editor-section input,\r\n.editor-section textarea {\r\n    width: 100%;\r\n    box-sizing: border-box;\r\n}\r\n\r\n.character-aliases {\r\n    font-size: 0.9em;\r\n    color: var(--SmartThemeQuoteColor);\r\n    margin-bottom: 8px;\r\n    font-style: italic;\r\n}\r\n\r\n.lorebook-entry-id {\r\n    display: inline-block;\r\n    margin-left: 10px;\r\n    padding: 2px 6px;\r\n    background: var(--SmartThemeBlurTintColor);\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    border-radius: 3px;\r\n    font-family: monospace;\r\n    font-size: 0.85em;\r\n    font-style: normal;\r\n    color: var(--SmartThemeQuoteColor);\r\n}\r\n\r\n.character-details {\r\n    font-size: 0.85em;\r\n    color: var(--SmartThemeBodyColor);\r\n    margin: 8px 0;\r\n    padding: 8px;\r\n    background: var(--SmartThemeBlurTintColor);\r\n    border-left: 2px solid var(--SmartThemeBorderColor);\r\n    border-radius: 3px;\r\n    line-height: 1.4;\r\n}\r\n\r\n.character-actions {\r\n    display: flex;\r\n    gap: 5px;\r\n    flex-wrap: wrap;\r\n    margin-top: 8px;\r\n}\r\n\r\n.character-actions .menu_button {\r\n    flex: 1;\r\n    min-width: 100px;\r\n    padding: 5px 10px;\r\n    font-size: 0.9em;\r\n}\r\n\r\n/* Character action buttons */\r\n.char-action-btn {\r\n    background: var(--SmartThemeBlurTintColor);\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    color: var(--SmartThemeEmColor);\r\n    padding: 6px 10px;\r\n    border-radius: 4px;\r\n    cursor: pointer;\r\n    transition: all 0.2s ease;\r\n    font-size: 14px;\r\n}\r\n\r\n.char-action-btn:hover {\r\n    background: var(--SmartThemeQuoteColor);\r\n    transform: translateY(-1px);\r\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\r\n}\r\n\r\n.char-action-btn:active {\r\n    transform: translateY(0);\r\n}\r\n\r\n.char-action-btn i {\r\n    pointer-events: none;\r\n}\r\n\r\n/* Red highlight for needs review */\r\n.char-action-btn.needs-review {\r\n    border-color: #dc3545;\r\n    color: #dc3545;\r\n}\r\n\r\n.char-action-btn.needs-review:hover {\r\n    background: #dc3545;\r\n    color: #fff;\r\n}\r\n\r\n.menu_button.compact {\r\n    padding: 5px 10px;\r\n    font-size: 0.9em;\r\n}\r\n\r\n.name-tracker-empty {\r\n    color: var(--SmartThemeQuoteColor);\r\n    font-style: italic;\r\n    text-align: center;\r\n    padding: 20px;\r\n}\r\n\r\n/* Ollama Settings */\r\n.ollama-settings {\r\n    background-color: var(--SmartThemeBlurTintColor);\r\n    border-left: 3px solid var(--SmartThemeBorderColor);\r\n    padding: 10px;\r\n    margin-top: 5px;\r\n    border-radius: 5px;\r\n}\r\n\r\n/* Merge Dialog */\r\n.merge-dialog {\r\n    padding: 15px;\r\n}\r\n\r\n.merge-dialog p {\r\n    margin-bottom: 10px;\r\n}\r\n\r\n.merge-dialog strong {\r\n    color: var(--SmartThemeBodyColor);\r\n    font-weight: bold;\r\n}\r\n\r\n.merge-warning {\r\n    color: #ff9800;\r\n    font-size: 0.9em;\r\n    margin-top: 10px;\r\n    padding: 10px;\r\n    background-color: rgba(255, 152, 0, 0.1);\r\n    border-left: 3px solid #ff9800;\r\n    border-radius: 3px;\r\n}\r\n\r\n/* Button states */\r\nbutton:disabled {\r\n    opacity: 0.5;\r\n    cursor: not-allowed;\r\n}\r\n\r\n/* Flex utilities */\r\n.flexGap5 {\r\n    gap: 5px;\r\n}\r\n\r\n.flex1 {\r\n    flex: 1;\r\n}\r\n\r\n/* Progress indicator */\r\n.name-tracker-progress {\r\n    margin: 10px 0;\r\n    padding: 10px;\r\n    background-color: var(--SmartThemeBlurTintColor);\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    border-radius: 5px;\r\n    text-align: center;\r\n}\r\n\r\n.name-tracker-progress .progress-text {\r\n    margin-bottom: 5px;\r\n    font-weight: bold;\r\n}\r\n\r\n.name-tracker-progress .progress-bar {\r\n    width: 100%;\r\n    height: 20px;\r\n    background-color: var(--black50a);\r\n    border-radius: 10px;\r\n    overflow: hidden;\r\n}\r\n\r\n.name-tracker-progress .progress-fill {\r\n    height: 100%;\r\n    background-color: var(--SmartThemeQuoteColor);\r\n    transition: width 0.3s ease;\r\n}\r\n\r\n/* Character details preview (for potential future use) */\r\n.character-details {\r\n    display: none;\r\n    margin-top: 10px;\r\n    padding: 10px;\r\n    background-color: var(--black30a);\r\n    border-radius: 5px;\r\n    font-size: 0.9em;\r\n}\r\n\r\n.character-details.expanded {\r\n    display: block;\r\n}\r\n\r\n.character-details-section {\r\n    margin-bottom: 8px;\r\n}\r\n\r\n.character-details-section:last-child {\r\n    margin-bottom: 0;\r\n}\r\n\r\n.character-details-label {\r\n    font-weight: bold;\r\n    color: var(--SmartThemeQuoteColor);\r\n    margin-right: 5px;\r\n}\r\n\r\n/* Responsive adjustments */\r\n@media (max-width: 768px) {\r\n    .character-actions {\r\n        flex-direction: column;\r\n    }\r\n    \r\n    .character-actions .menu_button {\r\n        width: 100%;\r\n    }\r\n}\r\n\r\n/* Animation for new characters */\r\n@keyframes fadeIn {\r\n    from {\r\n        opacity: 0;\r\n        transform: translateY(-10px);\r\n    }\r\n    to {\r\n        opacity: 1;\r\n        transform: translateY(0);\r\n    }\r\n}\r\n\r\n.name-tracker-character.new {\r\n    animation: fadeIn 0.3s ease;\r\n}\r\n\r\n/* System Prompt Editor */\r\n.system-prompt-editor h3 {\r\n    margin-top: 0;\r\n    margin-bottom: 10px;\r\n    color: var(--SmartThemeBodyColor);\r\n}\r\n\r\n.system-prompt-editor p {\r\n    margin-bottom: 10px;\r\n    color: var(--SmartThemeQuoteColor);\r\n    font-size: 0.9em;\r\n}\r\n\r\n#system_prompt_editor {\r\n    background-color: var(--SmartThemeBlurTintColor);\r\n    color: var(--SmartThemeBodyColor);\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    border-radius: 3px;\r\n    padding: 10px;\r\n    resize: vertical;\r\n}\r\n\r\n#system_prompt_editor:focus {\r\n    outline: none;\r\n    border-color: var(--SmartThemeEmColor);\r\n}\r\n\r\n.system-prompt-actions button {\r\n    min-width: 100px;\r\n}\r\n\r\n#system_prompt_reset {\r\n    margin-right: auto;\r\n}\r\n\r\n\r\n`, \"\",{\"version\":3,\"sources\":[\"webpack://./style.css\"],\"names\":[],\"mappings\":\"AAAA,0CAA0C;;AAE1C;IACI,YAAY;AAChB;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,gBAAgB;IAChB,mBAAmB;IACnB,iBAAiB;AACrB;;AAEA,mBAAmB;AACnB;IACI,gDAAgD;IAChD,8CAA8C;IAC9C,kBAAkB;IAClB,aAAa;AACjB;;AAEA;IACI,iBAAiB;IACjB,iCAAiC;IACjC,YAAY;IACZ,kBAAkB;AACtB;;AAEA,mBAAmB;AACnB;IACI,iBAAiB;IACjB,gBAAgB;IAChB,8CAA8C;IAC9C,kBAAkB;IAClB,YAAY;IACZ,eAAe;AACnB;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,8CAA8C;IAC9C,kBAAkB;IAClB,gDAAgD;AACpD;;AAEA;IACI,gBAAgB;AACpB;;AAEA,gFAAgF;AAChF;IACI,8BAA8B;IAC9B,yCAAyC;AAC7C;;AAEA;IACI,aAAa;IACb,8BAA8B;IAC9B,mBAAmB;IACnB,kBAAkB;AACtB;;AAEA;IACI,iBAAiB;IACjB,gBAAgB;IAChB,iCAAiC;AACrC;;AAEA;IACI,cAAc;IACd,iBAAiB;AACrB;;AAEA;IACI,kCAAkC;IAClC,6BAA6B;AACjC;;AAEA;IACI,qBAAqB;IACrB,gBAAgB;IAChB,kBAAkB;IAClB,iBAAiB;IACjB,iBAAiB;IACjB,gBAAgB;AACpB;;AAEA;IACI,yBAAyB;IACzB,WAAW;AACf;;AAEA;IACI,sBAAsB;IACtB,WAAW;AACf;;AAEA;IACI,yBAAyB;IACzB,WAAW;AACf;;AAEA,gCAAgC;AAChC;IACI,aAAa;IACb,mBAAmB;IACnB,iCAAiC;AACrC;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,cAAc;IACd,iBAAiB;IACjB,kBAAkB;IAClB,iCAAiC;AACrC;;AAEA;IACI,cAAc;IACd,eAAe;IACf,kCAAkC;IAClC,iBAAiB;AACrB;;AAEA;;IAEI,WAAW;IACX,sBAAsB;AAC1B;;AAEA;IACI,gBAAgB;IAChB,kCAAkC;IAClC,kBAAkB;IAClB,kBAAkB;AACtB;;AAEA;IACI,qBAAqB;IACrB,iBAAiB;IACjB,gBAAgB;IAChB,0CAA0C;IAC1C,8CAA8C;IAC9C,kBAAkB;IAClB,sBAAsB;IACtB,iBAAiB;IACjB,kBAAkB;IAClB,kCAAkC;AACtC;;AAEA;IACI,iBAAiB;IACjB,iCAAiC;IACjC,aAAa;IACb,YAAY;IACZ,0CAA0C;IAC1C,mDAAmD;IACnD,kBAAkB;IAClB,gBAAgB;AACpB;;AAEA;IACI,aAAa;IACb,QAAQ;IACR,eAAe;IACf,eAAe;AACnB;;AAEA;IACI,OAAO;IACP,gBAAgB;IAChB,iBAAiB;IACjB,gBAAgB;AACpB;;AAEA,6BAA6B;AAC7B;IACI,0CAA0C;IAC1C,8CAA8C;IAC9C,+BAA+B;IAC/B,iBAAiB;IACjB,kBAAkB;IAClB,eAAe;IACf,yBAAyB;IACzB,eAAe;AACnB;;AAEA;IACI,uCAAuC;IACvC,2BAA2B;IAC3B,wCAAwC;AAC5C;;AAEA;IACI,wBAAwB;AAC5B;;AAEA;IACI,oBAAoB;AACxB;;AAEA,mCAAmC;AACnC;IACI,qBAAqB;IACrB,cAAc;AAClB;;AAEA;IACI,mBAAmB;IACnB,WAAW;AACf;;AAEA;IACI,iBAAiB;IACjB,gBAAgB;AACpB;;AAEA;IACI,kCAAkC;IAClC,kBAAkB;IAClB,kBAAkB;IAClB,aAAa;AACjB;;AAEA,oBAAoB;AACpB;IACI,gDAAgD;IAChD,mDAAmD;IACnD,aAAa;IACb,eAAe;IACf,kBAAkB;AACtB;;AAEA,iBAAiB;AACjB;IACI,aAAa;AACjB;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,iCAAiC;IACjC,iBAAiB;AACrB;;AAEA;IACI,cAAc;IACd,gBAAgB;IAChB,gBAAgB;IAChB,aAAa;IACb,wCAAwC;IACxC,8BAA8B;IAC9B,kBAAkB;AACtB;;AAEA,kBAAkB;AAClB;IACI,YAAY;IACZ,mBAAmB;AACvB;;AAEA,mBAAmB;AACnB;IACI,QAAQ;AACZ;;AAEA;IACI,OAAO;AACX;;AAEA,uBAAuB;AACvB;IACI,cAAc;IACd,aAAa;IACb,gDAAgD;IAChD,8CAA8C;IAC9C,kBAAkB;IAClB,kBAAkB;AACtB;;AAEA;IACI,kBAAkB;IAClB,iBAAiB;AACrB;;AAEA;IACI,WAAW;IACX,YAAY;IACZ,iCAAiC;IACjC,mBAAmB;IACnB,gBAAgB;AACpB;;AAEA;IACI,YAAY;IACZ,6CAA6C;IAC7C,2BAA2B;AAC/B;;AAEA,yDAAyD;AACzD;IACI,aAAa;IACb,gBAAgB;IAChB,aAAa;IACb,iCAAiC;IACjC,kBAAkB;IAClB,gBAAgB;AACpB;;AAEA;IACI,cAAc;AAClB;;AAEA;IACI,kBAAkB;AACtB;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,iBAAiB;IACjB,kCAAkC;IAClC,iBAAiB;AACrB;;AAEA,2BAA2B;AAC3B;IACI;QACI,sBAAsB;IAC1B;;IAEA;QACI,WAAW;IACf;AACJ;;AAEA,iCAAiC;AACjC;IACI;QACI,UAAU;QACV,4BAA4B;IAChC;IACA;QACI,UAAU;QACV,wBAAwB;IAC5B;AACJ;;AAEA;IACI,2BAA2B;AAC/B;;AAEA,yBAAyB;AACzB;IACI,aAAa;IACb,mBAAmB;IACnB,iCAAiC;AACrC;;AAEA;IACI,mBAAmB;IACnB,kCAAkC;IAClC,gBAAgB;AACpB;;AAEA;IACI,gDAAgD;IAChD,iCAAiC;IACjC,8CAA8C;IAC9C,kBAAkB;IAClB,aAAa;IACb,gBAAgB;AACpB;;AAEA;IACI,aAAa;IACb,sCAAsC;AAC1C;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,kBAAkB;AACtB\",\"sourcesContent\":[\"/* Styles for the Name Tracker extension */\\r\\n\\r\\n.name-tracker-settings {\\r\\n    padding: 5px;\\r\\n}\\r\\n\\r\\n.name-tracker_block {\\r\\n    margin-bottom: 10px;\\r\\n}\\r\\n\\r\\n.name-tracker_block h4 {\\r\\n    margin-top: 10px;\\r\\n    margin-bottom: 10px;\\r\\n    font-weight: bold;\\r\\n}\\r\\n\\r\\n/* Status Display */\\r\\n.name-tracker-status-block {\\r\\n    background-color: var(--SmartThemeBlurTintColor);\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 5px;\\r\\n    padding: 10px;\\r\\n}\\r\\n\\r\\n.name-tracker-status {\\r\\n    font-weight: bold;\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n    padding: 5px;\\r\\n    text-align: center;\\r\\n}\\r\\n\\r\\n/* Character List */\\r\\n.name-tracker-character-list {\\r\\n    max-height: 400px;\\r\\n    overflow-y: auto;\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 5px;\\r\\n    padding: 5px;\\r\\n    margin-top: 5px;\\r\\n}\\r\\n\\r\\n.name-tracker-character {\\r\\n    padding: 10px;\\r\\n    margin-bottom: 10px;\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 5px;\\r\\n    background-color: var(--SmartThemeBlurTintColor);\\r\\n}\\r\\n\\r\\n.name-tracker-character:last-child {\\r\\n    margin-bottom: 0;\\r\\n}\\r\\n\\r\\n/* Active/loaded character styling (characters that are loaded in SillyTavern) */\\r\\n.name-tracker-character.main-character {\\r\\n    border-left: 3px solid #4CAF50;\\r\\n    background-color: rgba(76, 175, 80, 0.05);\\r\\n}\\r\\n\\r\\n.character-header {\\r\\n    display: flex;\\r\\n    justify-content: space-between;\\r\\n    align-items: center;\\r\\n    margin-bottom: 5px;\\r\\n}\\r\\n\\r\\n.character-name {\\r\\n    font-weight: bold;\\r\\n    font-size: 1.1em;\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n}\\r\\n\\r\\n.character-name .fa-user {\\r\\n    color: #4CAF50;\\r\\n    margin-right: 5px;\\r\\n}\\r\\n\\r\\n.character-name.ignored {\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n    text-decoration: line-through;\\r\\n}\\r\\n\\r\\n.character-badge {\\r\\n    display: inline-block;\\r\\n    padding: 2px 8px;\\r\\n    border-radius: 3px;\\r\\n    font-size: 0.75em;\\r\\n    font-weight: bold;\\r\\n    margin-left: 5px;\\r\\n}\\r\\n\\r\\n.character-badge.main-char {\\r\\n    background-color: #4CAF50;\\r\\n    color: #fff;\\r\\n}\\r\\n\\r\\n.character-badge.ignored {\\r\\n    background-color: #666;\\r\\n    color: #fff;\\r\\n}\\r\\n\\r\\n.character-badge.unresolved {\\r\\n    background-color: #ff9800;\\r\\n    color: #000;\\r\\n}\\r\\n\\r\\n/* Lorebook entry editor modal */\\r\\n.lorebook-entry-editor h3 {\\r\\n    margin-top: 0;\\r\\n    margin-bottom: 20px;\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n}\\r\\n\\r\\n.editor-section {\\r\\n    margin-bottom: 15px;\\r\\n}\\r\\n\\r\\n.editor-section label {\\r\\n    display: block;\\r\\n    font-weight: bold;\\r\\n    margin-bottom: 5px;\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n}\\r\\n\\r\\n.editor-section small {\\r\\n    display: block;\\r\\n    margin-top: 3px;\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n    font-size: 0.85em;\\r\\n}\\r\\n\\r\\n.editor-section input,\\r\\n.editor-section textarea {\\r\\n    width: 100%;\\r\\n    box-sizing: border-box;\\r\\n}\\r\\n\\r\\n.character-aliases {\\r\\n    font-size: 0.9em;\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n    margin-bottom: 8px;\\r\\n    font-style: italic;\\r\\n}\\r\\n\\r\\n.lorebook-entry-id {\\r\\n    display: inline-block;\\r\\n    margin-left: 10px;\\r\\n    padding: 2px 6px;\\r\\n    background: var(--SmartThemeBlurTintColor);\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 3px;\\r\\n    font-family: monospace;\\r\\n    font-size: 0.85em;\\r\\n    font-style: normal;\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n}\\r\\n\\r\\n.character-details {\\r\\n    font-size: 0.85em;\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n    margin: 8px 0;\\r\\n    padding: 8px;\\r\\n    background: var(--SmartThemeBlurTintColor);\\r\\n    border-left: 2px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 3px;\\r\\n    line-height: 1.4;\\r\\n}\\r\\n\\r\\n.character-actions {\\r\\n    display: flex;\\r\\n    gap: 5px;\\r\\n    flex-wrap: wrap;\\r\\n    margin-top: 8px;\\r\\n}\\r\\n\\r\\n.character-actions .menu_button {\\r\\n    flex: 1;\\r\\n    min-width: 100px;\\r\\n    padding: 5px 10px;\\r\\n    font-size: 0.9em;\\r\\n}\\r\\n\\r\\n/* Character action buttons */\\r\\n.char-action-btn {\\r\\n    background: var(--SmartThemeBlurTintColor);\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    color: var(--SmartThemeEmColor);\\r\\n    padding: 6px 10px;\\r\\n    border-radius: 4px;\\r\\n    cursor: pointer;\\r\\n    transition: all 0.2s ease;\\r\\n    font-size: 14px;\\r\\n}\\r\\n\\r\\n.char-action-btn:hover {\\r\\n    background: var(--SmartThemeQuoteColor);\\r\\n    transform: translateY(-1px);\\r\\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\\r\\n}\\r\\n\\r\\n.char-action-btn:active {\\r\\n    transform: translateY(0);\\r\\n}\\r\\n\\r\\n.char-action-btn i {\\r\\n    pointer-events: none;\\r\\n}\\r\\n\\r\\n/* Red highlight for needs review */\\r\\n.char-action-btn.needs-review {\\r\\n    border-color: #dc3545;\\r\\n    color: #dc3545;\\r\\n}\\r\\n\\r\\n.char-action-btn.needs-review:hover {\\r\\n    background: #dc3545;\\r\\n    color: #fff;\\r\\n}\\r\\n\\r\\n.menu_button.compact {\\r\\n    padding: 5px 10px;\\r\\n    font-size: 0.9em;\\r\\n}\\r\\n\\r\\n.name-tracker-empty {\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n    font-style: italic;\\r\\n    text-align: center;\\r\\n    padding: 20px;\\r\\n}\\r\\n\\r\\n/* Ollama Settings */\\r\\n.ollama-settings {\\r\\n    background-color: var(--SmartThemeBlurTintColor);\\r\\n    border-left: 3px solid var(--SmartThemeBorderColor);\\r\\n    padding: 10px;\\r\\n    margin-top: 5px;\\r\\n    border-radius: 5px;\\r\\n}\\r\\n\\r\\n/* Merge Dialog */\\r\\n.merge-dialog {\\r\\n    padding: 15px;\\r\\n}\\r\\n\\r\\n.merge-dialog p {\\r\\n    margin-bottom: 10px;\\r\\n}\\r\\n\\r\\n.merge-dialog strong {\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n    font-weight: bold;\\r\\n}\\r\\n\\r\\n.merge-warning {\\r\\n    color: #ff9800;\\r\\n    font-size: 0.9em;\\r\\n    margin-top: 10px;\\r\\n    padding: 10px;\\r\\n    background-color: rgba(255, 152, 0, 0.1);\\r\\n    border-left: 3px solid #ff9800;\\r\\n    border-radius: 3px;\\r\\n}\\r\\n\\r\\n/* Button states */\\r\\nbutton:disabled {\\r\\n    opacity: 0.5;\\r\\n    cursor: not-allowed;\\r\\n}\\r\\n\\r\\n/* Flex utilities */\\r\\n.flexGap5 {\\r\\n    gap: 5px;\\r\\n}\\r\\n\\r\\n.flex1 {\\r\\n    flex: 1;\\r\\n}\\r\\n\\r\\n/* Progress indicator */\\r\\n.name-tracker-progress {\\r\\n    margin: 10px 0;\\r\\n    padding: 10px;\\r\\n    background-color: var(--SmartThemeBlurTintColor);\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 5px;\\r\\n    text-align: center;\\r\\n}\\r\\n\\r\\n.name-tracker-progress .progress-text {\\r\\n    margin-bottom: 5px;\\r\\n    font-weight: bold;\\r\\n}\\r\\n\\r\\n.name-tracker-progress .progress-bar {\\r\\n    width: 100%;\\r\\n    height: 20px;\\r\\n    background-color: var(--black50a);\\r\\n    border-radius: 10px;\\r\\n    overflow: hidden;\\r\\n}\\r\\n\\r\\n.name-tracker-progress .progress-fill {\\r\\n    height: 100%;\\r\\n    background-color: var(--SmartThemeQuoteColor);\\r\\n    transition: width 0.3s ease;\\r\\n}\\r\\n\\r\\n/* Character details preview (for potential future use) */\\r\\n.character-details {\\r\\n    display: none;\\r\\n    margin-top: 10px;\\r\\n    padding: 10px;\\r\\n    background-color: var(--black30a);\\r\\n    border-radius: 5px;\\r\\n    font-size: 0.9em;\\r\\n}\\r\\n\\r\\n.character-details.expanded {\\r\\n    display: block;\\r\\n}\\r\\n\\r\\n.character-details-section {\\r\\n    margin-bottom: 8px;\\r\\n}\\r\\n\\r\\n.character-details-section:last-child {\\r\\n    margin-bottom: 0;\\r\\n}\\r\\n\\r\\n.character-details-label {\\r\\n    font-weight: bold;\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n    margin-right: 5px;\\r\\n}\\r\\n\\r\\n/* Responsive adjustments */\\r\\n@media (max-width: 768px) {\\r\\n    .character-actions {\\r\\n        flex-direction: column;\\r\\n    }\\r\\n    \\r\\n    .character-actions .menu_button {\\r\\n        width: 100%;\\r\\n    }\\r\\n}\\r\\n\\r\\n/* Animation for new characters */\\r\\n@keyframes fadeIn {\\r\\n    from {\\r\\n        opacity: 0;\\r\\n        transform: translateY(-10px);\\r\\n    }\\r\\n    to {\\r\\n        opacity: 1;\\r\\n        transform: translateY(0);\\r\\n    }\\r\\n}\\r\\n\\r\\n.name-tracker-character.new {\\r\\n    animation: fadeIn 0.3s ease;\\r\\n}\\r\\n\\r\\n/* System Prompt Editor */\\r\\n.system-prompt-editor h3 {\\r\\n    margin-top: 0;\\r\\n    margin-bottom: 10px;\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n}\\r\\n\\r\\n.system-prompt-editor p {\\r\\n    margin-bottom: 10px;\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n    font-size: 0.9em;\\r\\n}\\r\\n\\r\\n#system_prompt_editor {\\r\\n    background-color: var(--SmartThemeBlurTintColor);\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 3px;\\r\\n    padding: 10px;\\r\\n    resize: vertical;\\r\\n}\\r\\n\\r\\n#system_prompt_editor:focus {\\r\\n    outline: none;\\r\\n    border-color: var(--SmartThemeEmColor);\\r\\n}\\r\\n\\r\\n.system-prompt-actions button {\\r\\n    min-width: 100px;\\r\\n}\\r\\n\\r\\n#system_prompt_reset {\\r\\n    margin-right: auto;\\r\\n}\\r\\n\\r\\n\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","/**\r\n * SillyTavern context abstraction layer for Name Tracker extension\r\n * Provides a thin wrapper around SillyTavern.getContext() with error handling\r\n */\r\n\r\nimport debugLogger from './debug.js';\r\nimport { errorHandler } from './errors.js';\r\n\r\nconst logger = debugLogger.createModuleLogger('Context');\r\n\r\nclass SillyTavernContext {\r\n    constructor() {\r\n        this._context = null;\r\n        this._lastUpdate = 0;\r\n        this._updateInterval = 1000; // Cache context for 1 second\r\n    }\r\n\r\n    /**\r\n     * Get fresh SillyTavern context\r\n     * @returns {Object} SillyTavern context object\r\n     */\r\n    getContext() {\r\n        const now = Date.now();\r\n        if (!this._context || (now - this._lastUpdate) > this._updateInterval) {\r\n            try {\r\n                this._context = SillyTavern.getContext();\r\n                this._lastUpdate = now;\r\n            } catch (error) {\r\n                logger.error('Failed to get SillyTavern context:', error);\r\n                throw new Error('SillyTavern context not available');\r\n            }\r\n        }\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * Get current chat\r\n     * @returns {Array} Current chat messages\r\n     */\r\n    getChat() {\r\n        return this.getContext().chat || [];\r\n    }\r\n\r\n    /**\r\n     * Get current chat metadata\r\n     * @returns {Object} Chat metadata object\r\n     */\r\n    getChatMetadata() {\r\n        return this.getContext().chatMetadata || {};\r\n    }\r\n\r\n    /**\r\n     * Get current chat ID\r\n     * @returns {string|null} Chat identifier\r\n     */\r\n    getChatId() {\r\n        return this.getContext().chatId || null;\r\n    }\r\n\r\n    /**\r\n     * Get current character ID\r\n     * @returns {number|null} Character index\r\n     */\r\n    getCharacterId() {\r\n        return this.getContext().characterId;\r\n    }\r\n\r\n    /**\r\n     * Get characters list\r\n     * @returns {Array} Available characters\r\n     */\r\n    getCharacters() {\r\n        return this.getContext().characters || [];\r\n    }\r\n\r\n    /**\r\n     * Get user name (name1)\r\n     * @returns {string} User's persona name\r\n     */\r\n    getUserName() {\r\n        return this.getContext().name1 || 'User';\r\n    }\r\n\r\n    /**\r\n     * Get extension settings object\r\n     * @returns {Object} Extension settings\r\n     */\r\n    getExtensionSettings() {\r\n        return this.getContext().extensionSettings || {};\r\n    }\r\n\r\n    /**\r\n     * Save extension settings\r\n     * @returns {Promise<void>}\r\n     */\r\n    async saveExtensionSettings() {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            if (context.saveSettingsDebounced) {\r\n                context.saveSettingsDebounced();\r\n            } else {\r\n                logger.warn('saveSettingsDebounced not available');\r\n            }\r\n        }, { silent: true });\r\n    }\r\n\r\n    /**\r\n     * Save chat metadata\r\n     * @returns {Promise<void>}\r\n     */\r\n    async saveMetadata() {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            // SillyTavern context provides saveChatMetadata() method\r\n            if (context.saveChatMetadata) {\r\n                await context.saveChatMetadata();\r\n            } else {\r\n                logger.warn('saveChatMetadata not available on SillyTavern context');\r\n            }\r\n        }, { silent: true });\r\n    }\r\n\r\n    /**\r\n     * Generate quiet prompt (background LLM call)\r\n     * @param {Object} options - Generation options\r\n     * @returns {Promise<string>} Generated text\r\n     */\r\n    async generateQuietPrompt(options) {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            if (!context.generateQuietPrompt) {\r\n                throw new Error('generateQuietPrompt not available');\r\n            }\r\n            return await context.generateQuietPrompt(options);\r\n        }, { retries: 1 });\r\n    }\r\n\r\n    /**\r\n     * Load world info (lorebook)\r\n     * Direct passthrough to SillyTavern API - no error boundary wrapping\r\n     * to prevent Promise contamination in structuredClone operations\r\n     * @param {string} lorebookName - Name of lorebook\r\n     * @returns {Promise<Object|null>} Lorebook data\r\n     */\r\n    async loadWorldInfo(lorebookName) {\r\n        try {\r\n            const context = this.getContext();\r\n            if (!context.loadWorldInfo) {\r\n                throw new Error('loadWorldInfo not available');\r\n            }\r\n            return await context.loadWorldInfo(lorebookName);\r\n        } catch (error) {\r\n            console.error('[NT-Context] loadWorldInfo error:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Save world info (lorebook)\r\n     * Direct passthrough to SillyTavern API - no error boundary wrapping\r\n     * to prevent Promise contamination in structuredClone operations\r\n     * @param {string} lorebookName - Name of lorebook\r\n     * @param {Object} data - Lorebook data\r\n     * @param {boolean} create - Create if doesn't exist\r\n     * @returns {Promise<void>}\r\n     */\r\n    async saveWorldInfo(lorebookName, data, create = false) {\r\n        try {\r\n            const context = this.getContext();\r\n            if (!context.saveWorldInfo) {\r\n                throw new Error('saveWorldInfo not available');\r\n            }\r\n            return await context.saveWorldInfo(lorebookName, data, create);\r\n        } catch (error) {\r\n            console.error('[NT-Context] saveWorldInfo error:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Save world info entry\r\n     * @param {string} lorebookName - Lorebook name\r\n     * @param {Object} entryData - Entry data\r\n     * @returns {Promise<void>}\r\n     */\r\n    async saveWorldInfoEntry(lorebookName, entryData) {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            if (!context.saveWorldInfoEntry) {\r\n                throw new Error('saveWorldInfoEntry not available');\r\n            }\r\n            return await context.saveWorldInfoEntry(lorebookName, entryData);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set the chat's selected world info book (makes it active for the chat)\r\n     * @param {string} lorebookName - Name of lorebook to select\r\n     * @returns {Promise<void>}\r\n     */\r\n    async setSelectedWorldInfo(lorebookName) {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n\r\n            // First method: Use saveSelectedWorldInfo if available\r\n            if (context.saveSelectedWorldInfo && typeof context.saveSelectedWorldInfo === 'function') {\r\n                await context.saveSelectedWorldInfo(lorebookName);\r\n                return;\r\n            }\r\n\r\n            // Second method: Set the world_info directly in chat metadata\r\n            if (!context.chatMetadata) {\r\n                throw new Error('Chat metadata not available');\r\n            }\r\n\r\n            context.chatMetadata.world_info = lorebookName;\r\n\r\n            // Save the metadata using SillyTavern's saveChatMetadata method\r\n            if (context.saveChatMetadata && typeof context.saveChatMetadata === 'function') {\r\n                await context.saveChatMetadata();\r\n            }\r\n\r\n            logger.debug(`Selected world info: ${lorebookName}`);\r\n        }, { silent: true });\r\n    }\r\n\r\n    /**\r\n     * Get event source for listening to SillyTavern events\r\n     * @returns {Object} Event source object\r\n     */\r\n    getEventSource() {\r\n        const context = this.getContext();\r\n        return context.eventSource;\r\n    }\r\n\r\n    /**\r\n     * Get event types constants\r\n     * @returns {Object} Event types\r\n     */\r\n    getEventTypes() {\r\n        const context = this.getContext();\r\n        return context.event_types;\r\n    }\r\n\r\n    /**\r\n     * Call generic popup\r\n     * @param {string} content - HTML content\r\n     * @param {number} type - Popup type\r\n     * @param {string} input - Input placeholder\r\n     * @param {Object} options - Additional options\r\n     * @returns {Promise<any>} Popup result\r\n     */\r\n    async callGenericPopup(content, type, input = '', options = {}) {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            if (!context.callGenericPopup) {\r\n                throw new Error('callGenericPopup not available');\r\n            }\r\n            return await context.callGenericPopup(content, type, input, options);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if SillyTavern context is available\r\n     * @returns {boolean} Context availability\r\n     */\r\n    isContextAvailable() {\r\n        try {\r\n            return !!this.getContext();\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear cached context (force refresh on next access)\r\n     */\r\n    clearCache() {\r\n        this._context = null;\r\n        this._lastUpdate = 0;\r\n        logger.debug('Cleared context cache');\r\n    }\r\n\r\n    /**\r\n     * Get context status information for debugging\r\n     * @returns {Object} Context status\r\n     */\r\n    getStatus() {\r\n        return {\r\n            available: this.isContextAvailable(),\r\n            cached: !!this._context,\r\n            lastUpdate: this._lastUpdate,\r\n            chatId: this.getChatId(),\r\n            characterId: this.getCharacterId(),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Dump entire context object to console for debugging\r\n     * Shows all properties and their values in a readable format\r\n     */\r\n    dumpContextToConsole() {\r\n        try {\r\n            const context = this.getContext();\r\n\r\n            // Create a formatted dump\r\n            const dump = {\r\n                timestamp: new Date().toISOString(),\r\n                availableProperties: Object.keys(context),\r\n                fullContext: context,\r\n                detailedBreakdown: {},\r\n            };\r\n\r\n            // Add detailed breakdown of key properties\r\n            const keyProps = [\r\n                'maxContext', 'maxTokens', 'amount_gen', 'token_limit',\r\n                'extensionSettings', 'settings', 'chat', 'chatMetadata',\r\n                'characters', 'world_info', 'botId', 'characterId', 'chatId',\r\n                'impersonate', 'groups',\r\n            ];\r\n\r\n            for (const prop of keyProps) {\r\n                if (prop in context) {\r\n                    dump.detailedBreakdown[prop] = {\r\n                        type: typeof context[prop],\r\n                        value: context[prop],\r\n                        isNull: context[prop] === null,\r\n                        isUndefined: context[prop] === undefined,\r\n                    };\r\n                }\r\n            }\r\n\r\n            // Log to console with formatting\r\n            console.group('%c[Name Tracker] COMPLETE CONTEXT DUMP', 'color: #00ff00; font-weight: bold; font-size: 14px;');\r\n            console.log('%cTimestamp:', 'color: #ffaa00; font-weight: bold;', dump.timestamp);\r\n            console.log('%cTotal Properties:', 'color: #ffaa00; font-weight: bold;', dump.availableProperties.length);\r\n            console.log('%cAll Property Names:', 'color: #00aaff; font-weight: bold;', dump.availableProperties.join(', '));\r\n            console.log('%cDetailed Property Breakdown:', 'color: #ff00ff; font-weight: bold;', dump.detailedBreakdown);\r\n            console.log('%cFull Context Object:', 'color: #00ff00; font-weight: bold;', context);\r\n            console.log('%cJSON Dump (for copying):', 'color: #ffff00; font-weight: bold;', JSON.stringify(dump, null, 2));\r\n            console.groupEnd();\r\n\r\n            return dump;\r\n        } catch (error) {\r\n            console.error('[Name Tracker] ERROR dumping context:', error);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n\r\n// Create singleton instance\r\nconst sillyTavernContext = new SillyTavernContext();\r\n\r\nexport { sillyTavernContext as stContext };\r\nexport default sillyTavernContext;\r\n","\"use strict\";\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;","/**\r\n * Lorebook Management Module\r\n *\r\n * Handles chat-level lorebook creation, entry formatting, and SillyTavern integration\r\n * for the Name Tracker extension.\r\n */\r\n\r\n// Early debugging\r\nconsole.log('[LOREBOOK] Starting module load...');\r\n\r\nimport { createModuleLogger } from '../core/debug.js';\r\nimport { withErrorBoundary, NameTrackerError } from '../core/errors.js';\r\nimport {\r\n    get_settings, getCharacters, getCharacter, setCharacter, getLorebookConfig,\r\n} from '../core/settings.js';\r\nimport { stContext } from '../core/context.js';\r\nimport { generateUID } from '../utils/helpers.js';\r\nimport { NotificationManager } from '../utils/notifications.js';\r\n\r\n// Post-import debugging\r\nconsole.log('[LOREBOOK] Imports completed. Types:');\r\nconsole.log('[LOREBOOK] createModuleLogger:', typeof createModuleLogger);\r\nconsole.log('[LOREBOOK] withErrorBoundary:', typeof withErrorBoundary);\r\nconsole.log('[LOREBOOK] NameTrackerError:', typeof NameTrackerError);\r\n\r\n// Try to create debug logger with explicit error handling\r\nlet debug;\r\ntry {\r\n    console.log('[LOREBOOK] About to call createModuleLogger...');\r\n    debug = createModuleLogger('lorebook');\r\n    console.log('[LOREBOOK] Debug logger created successfully:', debug);\r\n} catch (error) {\r\n    console.error('[LOREBOOK] Failed to create debug logger:', error);\r\n    console.error('[LOREBOOK] Error stack:', error.stack);\r\n    // Create fallback logger\r\n    debug = {\r\n        log: console.log.bind(console, '[LOREBOOK]'),\r\n        error: console.error.bind(console, '[LOREBOOK]'),\r\n        warn: console.warn.bind(console, '[LOREBOOK]'),\r\n        debug: console.debug.bind(console, '[LOREBOOK]'),\r\n    };\r\n}\r\nconst notifications = new NotificationManager('Lorebook Management');\r\n\r\n// Lorebook state\r\nlet lorebookName = null;\r\n\r\n/**\r\n * Initialize or get the lorebook for this chat\r\n * @returns {Promise<string|null>} Lorebook name if successful, null if no chat\r\n */\r\nexport async function initializeLorebook() {\r\n    console.log('[NT-Lorebook] ');\r\n    console.log('[NT-Lorebook]  initializeLorebook() CALLED');\r\n    console.log('[NT-Lorebook] ');\r\n\r\n    return withErrorBoundary('initializeLorebook', async () => {\r\n        console.log('[NT-Lorebook]  Inside withErrorBoundary, getting context...');\r\n        const context = stContext.getContext();\r\n        console.log('[NT-Lorebook]  Got context:', !!context);\r\n        console.log('[NT-Lorebook]  context.chatId:', context?.chatId);\r\n\r\n        if (!context.chatId) {\r\n            console.warn('[NT-Lorebook]    NO ACTIVE CHAT - Aborting initialization');\r\n            debug.log('No active chat, skipping lorebook initialization');\r\n            lorebookName = null;\r\n            return null;\r\n        }\r\n\r\n        console.log('[NT-Lorebook]  Active chat detected, proceeding...');\r\n        const METADATA_KEY = 'world_info';\r\n        const chatMetadata = context.chatMetadata;\r\n        console.log('[NT-Lorebook]  chatMetadata exists?:', !!chatMetadata);\r\n\r\n        if (!chatMetadata) {\r\n            console.warn('[NT-Lorebook]    NO CHAT METADATA - Aborting initialization');\r\n            debug.log('No chat metadata available, skipping lorebook initialization');\r\n            lorebookName = null;\r\n            return null;\r\n        }\r\n\r\n        console.log('[NT-Lorebook]  Checking for existing bound lorebook...');\r\n        console.log('[NT-Lorebook]  chatMetadata[world_info]:', chatMetadata[METADATA_KEY]);\r\n\r\n        // Check if chat already has a bound lorebook\r\n        if (chatMetadata[METADATA_KEY]) {\r\n            lorebookName = chatMetadata[METADATA_KEY];\r\n            console.log('[NT-Lorebook] ');\r\n            console.log('[NT-Lorebook]   EXISTING LOREBOOK FOUND');\r\n            console.log('[NT-Lorebook] ');\r\n            console.log('[NT-Lorebook]  Lorebook Name:', lorebookName);\r\n            console.log('[NT-Lorebook]  Module Variable Set: YES');\r\n            console.log('[NT-Lorebook] ');\r\n            debug.log(`Using existing chat lorebook: ${lorebookName}`);\r\n\r\n            // Load the lorebook in the editor and make it active (ST API)\r\n            if (typeof context.reloadWorldInfoEditor === 'function') {\r\n                context.reloadWorldInfoEditor(lorebookName, true);\r\n            }\r\n            return lorebookName;\r\n        }\r\n\r\n        // Create a new chat-bound lorebook name\r\n        const bookName = `NameTracker_${context.chatId}`\r\n            .replace(/[^a-z0-9 -]/gi, '_')\r\n            .replace(/_{2,}/g, '_')\r\n            .substring(0, 64);\r\n\r\n        console.log('[NT-Lorebook] ');\r\n        console.log('[NT-Lorebook]   CREATING NEW LOREBOOK');\r\n        console.log('[NT-Lorebook] ');\r\n        console.log('[NT-Lorebook]  Generated Name:', bookName);\r\n        console.log('[NT-Lorebook]  Chat ID:', context.chatId);\r\n        console.log('[NT-Lorebook] ');\r\n        debug.log(`Creating new chat lorebook: ${bookName}`);\r\n        lorebookName = bookName;\r\n        console.log('[NT-Lorebook]  Module variable lorebookName SET TO:', lorebookName);\r\n\r\n        // Bind it to the chat metadata\r\n        chatMetadata[METADATA_KEY] = lorebookName;\r\n\r\n        // Save chat metadata using context API\r\n        try {\r\n            await context.saveMetadata();\r\n            console.log(`[NT-Lorebook]  Bound lorebook to chat metadata: ${lorebookName}`);\r\n            debug.log(`Bound lorebook to chat: ${lorebookName}`);\r\n\r\n            // CRITICAL: Actually SELECT the lorebook so it's active for the chat\r\n            await context.setSelectedWorldInfo(lorebookName);\r\n            console.log(`[NT-Lorebook]  Selected lorebook as active for this chat: ${lorebookName}`);\r\n\r\n            // Ensure the lorebook file exists (create empty if needed)\r\n            const worldInfo = await context.loadWorldInfo(lorebookName);\r\n            if (!worldInfo) {\r\n                console.log(`[NT-Lorebook]  Creating empty lorebook file: ${lorebookName}`);\r\n                debug.log();\r\n                await context.saveWorldInfo(lorebookName, { entries: {} }, true);\r\n                console.log('[NT-Lorebook]  Lorebook file created successfully');\r\n            } else {\r\n                console.log(`[NT-Lorebook]   Lorebook file already exists with ${Object.keys(worldInfo.entries || {}).length} entries`);\r\n            }\r\n\r\n            // Load the new lorebook in the editor and make it active (ST API)\r\n            if (typeof context.reloadWorldInfoEditor === 'function') {\r\n                context.reloadWorldInfoEditor(lorebookName, true);\r\n            }\r\n\r\n            // Refresh the lorebook dropdown list so user can see new lorebook immediately\r\n            // This is a global ST function, not on context object\r\n            if (typeof window.updateWorldInfoList === 'function') {\r\n                await window.updateWorldInfoList();\r\n                debug.log(` Lorebook dropdown refreshed - ${lorebookName} now visible`);\r\n            } else if (typeof context.updateWorldInfoList === 'function') {\r\n                await context.updateWorldInfoList();\r\n                debug.log(` Lorebook dropdown refreshed - ${lorebookName} now visible`);\r\n            }\r\n\r\n            // Notify user\r\n            notifications.info(`Chat lorebook \"${lorebookName}\" created and bound to this chat`, { timeOut: 5000 });\r\n            console.log('[NT-Lorebook]  Chat lorebook initialization complete');\r\n        } catch (error) {\r\n            console.error('Failed to initialize lorebook:', error);\r\n            lorebookName = null;\r\n            throw new NameTrackerError(`Failed to initialize lorebook: ${error.message}`);\r\n        }\r\n\r\n        return lorebookName;\r\n    });\r\n}\r\n\r\n/**\r\n * REC-15: Load characters from lorebook entries on chat change\r\n * Parses automation ID format: NT-AUTO-${uid}|||${JSON}\r\n * @returns {Promise<Object>} Characters object indexed by preferredName\r\n */\r\nexport async function loadCharactersFromLorebook() {\r\n    return withErrorBoundary('loadCharactersFromLorebook', async () => {\r\n        const context = stContext.getContext();\r\n        if (!context) {\r\n            debug.log(' Context not available - cannot load characters from lorebook');\r\n            return {};\r\n        }\r\n\r\n        const currentLorebookName = await initializeLorebook();\r\n        if (!currentLorebookName) {\r\n            debug.log(' No lorebook available - returning empty characters');\r\n            return {};\r\n        }\r\n\r\n        const worldInfo = await context.loadWorldInfo(currentLorebookName);\r\n        if (!worldInfo || !worldInfo.entries) {\r\n            debug.log(' No lorebook entries found');\r\n            return {};\r\n        }\r\n\r\n        const characters = {};\r\n        let loadedCount = 0;\r\n        let failedCount = 0;\r\n\r\n        // Filter entries managed by NameTracker extension\r\n        const nameTrackerEntries = Object.values(worldInfo.entries).filter(\r\n            entry => entry.automationId === 'NameTracker',\r\n        );\r\n\r\n        debug.log(` Found ${nameTrackerEntries.length} NameTracker entries in lorebook`);\r\n\r\n        for (const entry of nameTrackerEntries) {\r\n            try {\r\n                if (!entry.comment || !entry.comment.startsWith('NT-AUTO-')) {\r\n                    debug.log(` Skipping entry ${entry.uid} - invalid comment format`);\r\n                    continue;\r\n                }\r\n\r\n                // Parse automation ID: NT-AUTO-${uid}|||${JSON}\r\n                const parts = entry.comment.split('|||');\r\n                if (parts.length !== 2) {\r\n                    debug.log(` Skipping entry ${entry.uid} - malformed automation ID`);\r\n                    continue;\r\n                }\r\n\r\n                const characterData = JSON.parse(parts[1]);\r\n                \r\n                // Validate required fields\r\n                if (!characterData.preferredName || !characterData.uid) {\r\n                    debug.log(` Skipping entry ${entry.uid} - missing required fields`);\r\n                    continue;\r\n                }\r\n\r\n                // Store indexed by preferredName\r\n                characters[characterData.preferredName] = characterData;\r\n                loadedCount++;\r\n\r\n                debug.log(` Loaded character: ${characterData.preferredName} (UID: ${characterData.uid})`);\r\n            } catch (error) {\r\n                debug.error(` Failed to parse entry ${entry.uid}:`, error);\r\n                failedCount++;\r\n            }\r\n        }\r\n\r\n        debug.log(` Character load complete: ${loadedCount} loaded, ${failedCount} failed`);\r\n        return characters;\r\n    });\r\n}\r\n\r\n/**\r\n * Update or create lorebook entry for a character\r\n * @param {Object} character - Character data\r\n * @param {string} characterName - Character name\r\n * @returns {Promise<void>}\r\n */\r\nexport async function updateLorebookEntry(character, characterName) {\r\n    return withErrorBoundary('updateLorebookEntry', async () => {\r\n        console.log(`[NT-Lorebook] \r\n updateLorebookEntry CALLED\r\n\r\n CRITICAL: Checking lorebookName variable\r\n lorebookName value: ${lorebookName}\r\n lorebookName type: ${typeof lorebookName}\r\n lorebookName is null?: ${lorebookName === null}\r\n lorebookName is undefined?: ${lorebookName === undefined}\r\n lorebookName is falsy?: ${!lorebookName}\r\n`);\r\n\r\n        if (!lorebookName) {\r\n            console.error(`[NT-Lorebook] \r\n  CRITICAL ERROR: NO LOREBOOK INITIALIZED!\r\n\r\n lorebookName is: ${lorebookName}\r\n Character: ${characterName}\r\n SKIPPING LOREBOOK ENTRY UPDATE\r\n`);\r\n            debug.log('No lorebook initialized, skipping entry update');\r\n            return;\r\n        }\r\n\r\n        console.log(`[NT-Lorebook] \r\n  Lorebook IS initialized\r\n\r\n Character Name: ${characterName}\r\n Character Object: ${JSON.stringify(character, null, 2)}\r\n Has lorebookEntryId?: ${!!character.lorebookEntryId}\r\n Existing Entry ID: ${character.lorebookEntryId || 'NONE'}\r\n`);\r\n\r\n        debug.log(`updateLorebookEntry called for: ${characterName}`);\r\n        debug.log('  Character data:', character);\r\n\r\n        const context = stContext.getContext();\r\n        const lorebookConfig = await getLorebookConfig();\r\n\r\n        // Build the entry content in a readable format\r\n        const contentParts = [];\r\n\r\n        // Physical Age / Mental Age\r\n        if (character.physicalAge || character.mentalAge) {\r\n            const ageInfo = [];\r\n            if (character.physicalAge) ageInfo.push(`Physical: ${character.physicalAge}`);\r\n            if (character.mentalAge) ageInfo.push(`Mental: ${character.mentalAge}`);\r\n            contentParts.push(`**Age:** ${ageInfo.join(', ')}`);\r\n        }\r\n\r\n        // Physical (consolidated body description)\r\n        if (character.physical) {\r\n            contentParts.push(`\\n**Physical Description:**\\n${character.physical}`);\r\n        }\r\n\r\n        // Personality (consolidated traits, likes, dislikes)\r\n        if (character.personality) {\r\n            contentParts.push(`\\n**Personality:**\\n${character.personality}`);\r\n        }\r\n\r\n        // Sexuality\r\n        if (character.sexuality) {\r\n            contentParts.push(`\\n**Sexuality:**\\n${character.sexuality}`);\r\n        }\r\n\r\n        // Race/Ethnicity\r\n        if (character.raceEthnicity) {\r\n            contentParts.push(`**Race/Ethnicity:** ${character.raceEthnicity}`);\r\n        }\r\n\r\n        // Role & Skills\r\n        if (character.roleSkills) {\r\n            contentParts.push(`\\n**Role & Skills:**\\n${character.roleSkills}`);\r\n        }\r\n\r\n        // Relationships\r\n        if (character.relationships && character.relationships.length > 0) {\r\n            contentParts.push('\\n**Relationships:**');\r\n            character.relationships.forEach(rel => {\r\n                contentParts.push(`- ${rel}`);\r\n            });\r\n        }\r\n\r\n        const content = contentParts.join('\\n');\r\n\r\n        // Build the keys array (name + aliases)\r\n        const keys = [character.preferredName];\r\n        if (character.aliases) {\r\n            keys.push(...character.aliases);\r\n        }\r\n\r\n        // Ensure character has a UID (required for REC-15 chat lifecycle)\r\n        if (!character.uid) {\r\n            character.uid = generateUID();\r\n            debug.log(`Generated UID for character ${characterName}: ${character.uid}`);\r\n        }\r\n\r\n        // Load the world info to check if entry exists\r\n        let worldInfo = await context.loadWorldInfo(lorebookName);\r\n\r\n        if (!worldInfo) {\r\n            debug.log();\r\n            // Match SillyTavern's world info structure\r\n            worldInfo = {\r\n                entries: {},\r\n            };\r\n        }\r\n\r\n        // Clean up orphaned entries for this character\r\n        // Remove any entries that match this character's name/aliases but aren't the current entry ID\r\n        console.log(`[NT-Lorebook]  Cleaning up orphaned entries for: ${characterName}`);\r\n        const orphanedUids = [];\r\n        for (const [uid, entry] of Object.entries(worldInfo.entries)) {\r\n            if (!entry.key || !Array.isArray(entry.key)) continue;\r\n\r\n            // Check if any of this entry's keys match our character's primary name or aliases\r\n            const hasMatchingKey = entry.key.some(k =>\r\n                k.toLowerCase() === characterName.toLowerCase() ||\r\n                (character.aliases && character.aliases.some(alias =>\r\n                    k.toLowerCase() === alias.toLowerCase(),\r\n                )),\r\n            );\r\n\r\n            // If this entry has matching keys but isn't our current entry, mark it for removal\r\n            if (hasMatchingKey && uid !== character.lorebookEntryId) {\r\n                console.log(`[NT-Lorebook]    Removing orphaned entry: ${uid} (keys: ${entry.key.join(', ')})`);\r\n                orphanedUids.push(uid);\r\n            }\r\n        }\r\n\r\n        // Remove orphaned entries\r\n        for (const uid of orphanedUids) {\r\n            delete worldInfo.entries[uid];\r\n        }\r\n\r\n        if (orphanedUids.length > 0) {\r\n            console.log(`[NT-Lorebook]  Removed ${orphanedUids.length} orphaned entries`);\r\n        }\r\n\r\n        // Calculate dynamic cooldown\r\n        const messageFreq = await get_settings('messageFrequency', 10);\r\n        const calculatedCooldown = Math.max(1, Math.floor(messageFreq * 0.75));\r\n\r\n\r\n        let existingUid = null;\r\n\r\n        // Check if this character already has a lorebook entry\r\n        if (character.lorebookEntryId && worldInfo.entries && worldInfo.entries[character.lorebookEntryId]) {\r\n            // Update existing entry\r\n            existingUid = character.lorebookEntryId;\r\n            const existingEntry = worldInfo.entries[existingUid];\r\n\r\n            console.log(`[NT-Lorebook]  Updating existing entry for: ${characterName}`);\r\n            console.log(`[NT-Lorebook]    Entry UID: ${existingUid}`);\r\n            console.log(`[NT-Lorebook]    Keys: ${keys.join(', ')}`);\r\n            console.log(`[NT-Lorebook]    Content length: ${content.length} chars`);\r\n\r\n            existingEntry.key = keys;\r\n            existingEntry.content = content;\r\n            existingEntry.enabled = lorebookConfig.enabled;\r\n            existingEntry.position = lorebookConfig.position;\r\n            existingEntry.probability = lorebookConfig.probability;\r\n            existingEntry.depth = lorebookConfig.depth;\r\n            existingEntry.scanDepth = lorebookConfig.scanDepth;\r\n            existingEntry.cooldown = calculatedCooldown;\r\n            \r\n            // REC-15: Store full character JSON in comment for chat lifecycle persistence\r\n            existingEntry.automationId = 'NameTracker'; // Constant for filtering extension-managed entries\r\n            existingEntry.comment = `NT-AUTO-${character.uid}|||${JSON.stringify(character)}`;\r\n\r\n            debug.log(` Updated automation ID for character ${characterName} (UID: ${character.uid})`);\r\n        } else {\r\n            // Create new entry\r\n            const newUid = generateUID();\r\n\r\n            console.log(`[NT-Lorebook] \r\n CREATING NEW ENTRY\r\n\r\n Character Name: ${characterName}\r\n Generated UID: ${newUid}\r\n Keys Array: ${JSON.stringify(keys)}\r\n Content Preview: ${content.substring(0, 200)}...\r\n Content Length: ${content.length} characters\r\n`);\r\n\r\n            const newEntry = {\r\n                uid: newUid,\r\n                key: keys,\r\n                keysecondary: [],\r\n                comment: `NT-AUTO-${character.uid}|||${JSON.stringify(character)}`, // REC-15: Full JSON for chat lifecycle\r\n                content: content,\r\n                constant: false,\r\n                selective: true,\r\n                contextConfig: {\r\n                    prefix: '',\r\n                    suffix: '',\r\n                    tokenBudget: 0,\r\n                    reservedTokens: 0,\r\n                    budgetPriority: 400,\r\n                    trimDirection: 'doNotTrim',\r\n                    insertionOrder: 0,\r\n                    maximumTrimType: 'sentence',\r\n                    insertionPosition: 'before',\r\n                },\r\n                enabled: lorebookConfig.enabled,\r\n                position: lorebookConfig.position,\r\n                excludeRecursion: false,\r\n                preventRecursion: false,\r\n                delayUntilRecursion: false,\r\n                probability: lorebookConfig.probability,\r\n                useProbability: true,\r\n                depth: lorebookConfig.depth,\r\n                selectiveLogic: 0,\r\n                group: '',\r\n                scanDepth: lorebookConfig.scanDepth,\r\n                caseSensitive: null,\r\n                matchWholeWords: null,\r\n                useGroupScoring: null,\r\n                automationId: 'NameTracker', // REC-15: Constant for filtering extension-managed entries\r\n                role: 0,\r\n                vectorized: false,\r\n                sticky: 0,\r\n                cooldown: calculatedCooldown,\r\n                delay: 0,\r\n            };\r\n\r\n            // World info entries are stored as an object with UID as key\r\n            worldInfo.entries[newUid] = newEntry;\r\n            character.lorebookEntryId = newUid;\r\n\r\n            console.log(`[NT-Lorebook]  Creating new entry for: ${characterName}`);\r\n            console.log(`[NT-Lorebook]    Entry UID: ${newUid}`);\r\n            console.log(`[NT-Lorebook]    Keys: ${keys.join(', ')}`);\r\n            console.log(`[NT-Lorebook]    Content length: ${content.length} chars`);\r\n            console.log(`[NT-Lorebook]    Enabled: ${lorebookConfig.enabled}`);\r\n            console.log(`[NT-Lorebook]    Position: ${lorebookConfig.position}`);\r\n\r\n            // Save the character with the new lorebook entry ID\r\n            console.log(`[NT-Lorebook] \r\n SAVING CHARACTER WITH ENTRY ID\r\n\r\n Character Name: ${characterName}\r\n Character Object BEFORE save: ${JSON.stringify(character, null, 2)}\r\n Lorebook Entry ID: ${newUid}\r\n`);\r\n\r\n            await setCharacter(characterName, character);\r\n\r\n            console.log(`[NT-Lorebook] \r\n CHARACTER SAVE COMPLETE\r\n\r\n Character Name: ${characterName}\r\n Entry ID Saved: ${character.lorebookEntryId}\r\n`);\r\n\r\n            debug.log();\r\n        }\r\n\r\n        // Save the lorebook\r\n        try {\r\n            const worldInfoStructure = {\r\n                entryCount: Object.keys(worldInfo.entries).length,\r\n                entryKeys: Object.keys(worldInfo.entries),\r\n                sampleEntry: Object.values(worldInfo.entries)[0] ? {\r\n                    uid: Object.values(worldInfo.entries)[0].uid,\r\n                    key: Object.values(worldInfo.entries)[0].key,\r\n                    contentLength: Object.values(worldInfo.entries)[0].content.length,\r\n                } : 'NONE',\r\n            };\r\n            console.log(`[NT-Lorebook] \r\n SAVING LOREBOOK TO DISK\r\n\r\n Lorebook Name: ${lorebookName}\r\n Total Entries: ${Object.keys(worldInfo.entries).length}\r\n Entry UIDs: ${Object.keys(worldInfo.entries).join(', ')}\r\n WorldInfo Structure: ${JSON.stringify(worldInfoStructure, null, 2)}\r\n`);\r\n\r\n            // Sanitize worldInfo to prevent Promise contamination in structuredClone\r\n            const sanitizedWorldInfo = JSON.parse(JSON.stringify(worldInfo));\r\n            await context.saveWorldInfo(lorebookName, sanitizedWorldInfo, true);\r\n\r\n            console.log(`[NT-Lorebook] \r\n LOREBOOK SAVE COMPLETE\r\n\r\n Lorebook Name: ${lorebookName}\r\n Save Successful: YES\r\n`);\r\n\r\n            // Verify the save worked by reloading\r\n            console.log(`[NT-Lorebook] \r\n VERIFYING LOREBOOK SAVE\r\n\r\n Reloading: ${lorebookName}\r\n`);\r\n\r\n            const verifyWorldInfo = await context.loadWorldInfo(lorebookName);\r\n            const targetUid = existingUid || character.lorebookEntryId;\r\n\r\n            console.log(`[NT-Lorebook] \r\n VERIFICATION RESULTS\r\n\r\n Target UID: ${targetUid}\r\n Verification Data Loaded?: ${!!verifyWorldInfo}\r\n Has Entries Object?: ${!!verifyWorldInfo?.entries}\r\n Available Entry UIDs: ${Object.keys(verifyWorldInfo?.entries || {}).join(', ')}\r\n Target Entry Found?: ${!!(verifyWorldInfo?.entries?.[targetUid])}`);\r\n\r\n            if (verifyWorldInfo && verifyWorldInfo.entries && verifyWorldInfo.entries[targetUid]) {\r\n                const entryData = {\r\n                    uid: verifyWorldInfo.entries[targetUid].uid,\r\n                    key: verifyWorldInfo.entries[targetUid].key,\r\n                    enabled: verifyWorldInfo.entries[targetUid].enabled,\r\n                    contentLength: verifyWorldInfo.entries[targetUid].content.length,\r\n                };\r\n                console.log(`[NT-Lorebook]   VERIFICATION: SUCCESS\r\n Entry Data: ${JSON.stringify(entryData, null, 2)}\r\n`);\r\n                debug.log();\r\n            } else {\r\n                console.log(`[NT-Lorebook]   VERIFICATION: FAILED\r\n Entry NOT found in reloaded lorebook!\r\n`);\r\n                console.error(`[NT-Lorebook]  WARNING: Lorebook verification failed - entries may not have been saved!\r\n   Target UID: ${targetUid}\r\n   Available entries: ${Object.keys(verifyWorldInfo?.entries || {}).join(', ')}`);\r\n                console.error('[Name Tracker] WARNING: Lorebook verification failed - entries may not have been saved!');\r\n            }\r\n\r\n            debug.log();\r\n        } catch (error) {\r\n            console.error('[NT-Lorebook]  Error saving lorebook:', error);\r\n            console.error('[NT-Lorebook]    Lorebook name:', lorebookName);\r\n            console.error('[NT-Lorebook]    Error details:', error.message);\r\n            console.error('[Name Tracker] Error saving lorebook:', error);\r\n            debug.log();\r\n            throw error; // Re-throw so caller knows it failed\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Create lorebook content from character data (JSON format)\r\n * @param {Object} character - Character data\r\n * @returns {string} JSON string representation\r\n */\r\nexport function createLorebookContent(character) {\r\n    return withErrorBoundary('createLorebookContent', () => {\r\n        const content = {\r\n            name: character.preferredName,\r\n            aliases: character.aliases,\r\n            physical: character.physical,\r\n            mental: character.mental,\r\n            relationships: character.relationships,\r\n        };\r\n\r\n        return JSON.stringify(content, null, 2);\r\n    });\r\n}\r\n\r\n/**\r\n * View character in lorebook editor\r\n * @param {string} characterName - Name of character to view\r\n * @returns {Promise<void>}\r\n */\r\nexport async function viewInLorebook(characterName) {\r\n    return withErrorBoundary('viewInLorebook', async () => {\r\n        const character = await getCharacter(characterName);\r\n\r\n        if (!character) {\r\n            throw new NameTrackerError('Character not found');\r\n        }\r\n\r\n        if (!lorebookName) {\r\n            notifications.warning('No active chat or lorebook');\r\n            return;\r\n        }\r\n\r\n        // Import the world info functions from context\r\n        const context = stContext.getContext();\r\n\r\n        // Open the lorebook editor and make this chat's lorebook active\r\n        if (typeof context.reloadWorldInfoEditor === 'function') {\r\n            // Use reloadWorldInfoEditor to ensure the chat lorebook is active in the editor\r\n            context.reloadWorldInfoEditor(lorebookName, true);\r\n            notifications.success(`Opened lorebook for ${characterName}`);\r\n        } else if (typeof context.openWorldInfoEditor === 'function') {\r\n            // Fallback to openWorldInfoEditor\r\n            await context.openWorldInfoEditor(lorebookName);\r\n            notifications.success(`Opened lorebook for ${characterName}`);\r\n        } else {\r\n            // Final fallback: show the world info panel\r\n            $('#WorldInfo').click();\r\n            notifications.info(`Please select \"${lorebookName}\" from the World Info panel`);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Delete a character's lorebook entry\r\n * @param {Object} character - Character data\r\n * @returns {Promise<boolean>} True if deleted successfully\r\n */\r\nexport async function deleteLorebookEntry(character) {\r\n    return withErrorBoundary('deleteLorebookEntry', async () => {\r\n        if (!lorebookName || !character.lorebookEntryId) {\r\n            debug.log();\r\n            return false;\r\n        }\r\n\r\n        const context = stContext.getContext();\r\n\r\n        try {\r\n            const worldInfo = await context.loadWorldInfo(lorebookName);\r\n            if (worldInfo && worldInfo.entries && worldInfo.entries[character.lorebookEntryId]) {\r\n                delete worldInfo.entries[character.lorebookEntryId];\r\n                const sanitizedWorldInfo = JSON.parse(JSON.stringify(worldInfo));\r\n                await context.saveWorldInfo(lorebookName, sanitizedWorldInfo, true);\r\n\r\n                debug.log();\r\n                return true;\r\n            }\r\n        } catch (error) {\r\n            console.error('Error deleting lorebook entry:', error);\r\n            return false;\r\n        }\r\n\r\n        return false;\r\n    });\r\n}\r\n\r\n/**\r\n * Purge all tracked character entries from lorebook\r\n * @param {Array} characters - Array of character objects to purge\r\n * @returns {Promise<number>} Number of entries deleted\r\n */\r\nexport async function purgeLorebookEntries(characters) {\r\n    return withErrorBoundary('purgeLorebookEntries', async () => {\r\n        if (!lorebookName) {\r\n            debug.log();\r\n            return 0;\r\n        }\r\n\r\n        const context = stContext.getContext();\r\n        let deletedCount = 0;\r\n\r\n        try {\r\n            const worldInfo = await context.loadWorldInfo(lorebookName);\r\n\r\n            if (worldInfo && worldInfo.entries) {\r\n                // Get all entry IDs from our tracked characters\r\n                const entryIds = characters\r\n                    .map(char => char.lorebookEntryId)\r\n                    .filter(id => id !== undefined && id !== null);\r\n\r\n                // Delete each entry\r\n                for (const entryId of entryIds) {\r\n                    if (worldInfo.entries[entryId]) {\r\n                        delete worldInfo.entries[entryId];\r\n                        deletedCount++;\r\n                        debug.log();\r\n                    }\r\n                }\r\n\r\n                // Save the lorebook\r\n                const sanitizedWorldInfo = JSON.parse(JSON.stringify(worldInfo));\r\n                await context.saveWorldInfo(lorebookName, sanitizedWorldInfo, true);\r\n            }\r\n        } catch (error) {\r\n            console.error('Error purging lorebook entries:', error);\r\n            throw new NameTrackerError(`Failed to purge lorebook entries: ${error.message}`);\r\n        }\r\n\r\n        return deletedCount;\r\n    });\r\n}\r\n\r\n/**\r\n * Adopt existing lorebook entries into character cache\r\n * This allows manual entries or previous data to be imported\r\n * @returns {Promise<number>} Number of entries adopted\r\n */\r\nexport async function adoptExistingEntries() {\r\n    return withErrorBoundary('adoptExistingEntries', async () => {\r\n        if (!lorebookName) {\r\n            debug.log();\r\n            return 0;\r\n        }\r\n\r\n        const context = stContext.getContext();\r\n        let adoptedCount = 0;\r\n\r\n        try {\r\n            const worldInfo = await context.loadWorldInfo(lorebookName);\r\n\r\n            if (!worldInfo || !worldInfo.entries) {\r\n                debug.log();\r\n                return 0;\r\n            }\r\n\r\n            const characters = await getCharacters();\r\n\r\n            // Look for entries that might belong to our extension\r\n            for (const [entryId, entry] of Object.entries(worldInfo.entries)) {\r\n                if (!entry.key || !Array.isArray(entry.key) || entry.key.length === 0) {\r\n                    continue;\r\n                }\r\n\r\n                const primaryName = entry.key[0];\r\n\r\n                // Check if this entry represents a character we should track\r\n                const managedByExtension = entry.comment?.includes('Auto-generated entry for')\r\n                    || entry.comment === primaryName\r\n                    || entry.comment === `Auto-generated entry for ${primaryName}`;\r\n\r\n                if (!characters[primaryName] && managedByExtension) {\r\n                    // Try to parse the content to recreate character data\r\n                    const character = {\r\n                        preferredName: primaryName,\r\n                        aliases: entry.key.slice(1),\r\n                        physical: '',\r\n                        personality: '',\r\n                        sexuality: '',\r\n                        raceEthnicity: '',\r\n                        roleSkills: '',\r\n                        relationships: [],\r\n                        ignored: false,\r\n                        confidence: 50,\r\n                        lorebookEntryId: entryId,\r\n                        lastUpdated: Date.now(),\r\n                        isMainChar: false,\r\n                    };\r\n\r\n                    // Store the adopted character\r\n                    await setCharacter(primaryName, character);\r\n                    adoptedCount++;\r\n\r\n                    debug.log();\r\n                }\r\n            }\r\n\r\n            if (adoptedCount > 0) {\r\n                notifications.success(`Adopted ${adoptedCount} existing lorebook entries`);\r\n            }\r\n\r\n        } catch (error) {\r\n            console.error('Error adopting existing entries:', error);\r\n            throw new NameTrackerError(`Failed to adopt existing entries: ${error.message}`);\r\n        }\r\n\r\n        return adoptedCount;\r\n    });\r\n}\r\n\r\n/**\r\n * Get the current lorebook name\r\n * @returns {string|null} Current lorebook name\r\n */\r\nexport function getCurrentLorebookName() {\r\n    return lorebookName;\r\n}\r\n\r\n/**\r\n * Reset lorebook state (called on chat change)\r\n */\r\nexport function resetLorebookState() {\r\n    lorebookName = null;\r\n    debug.log();\r\n}\r\n\r\n/**\r\n * Get lorebook statistics\r\n * @returns {Promise<Object>} Lorebook statistics\r\n */\r\nexport async function getLorebookStats() {\r\n    return withErrorBoundary('getLorebookStats', async () => {\r\n        if (!lorebookName) {\r\n            return {\r\n                name: null,\r\n                entryCount: 0,\r\n                trackedEntries: 0,\r\n                orphanedEntries: 0,\r\n            };\r\n        }\r\n\r\n        const context = stContext.getContext();\r\n\r\n        try {\r\n            const worldInfo = await context.loadWorldInfo(lorebookName);\r\n            const characters = await getCharacters();\r\n\r\n            if (!worldInfo || !worldInfo.entries) {\r\n                return {\r\n                    name: lorebookName,\r\n                    entryCount: 0,\r\n                    trackedEntries: 0,\r\n                    orphanedEntries: 0,\r\n                };\r\n            }\r\n\r\n            const totalEntries = Object.keys(worldInfo.entries).length;\r\n            const trackedIds = Object.values(characters)\r\n                .map(char => char.lorebookEntryId)\r\n                .filter(id => id);\r\n            const trackedEntries = trackedIds.length;\r\n            const orphanedEntries = totalEntries - trackedEntries;\r\n\r\n            return {\r\n                name: lorebookName,\r\n                entryCount: totalEntries,\r\n                trackedEntries,\r\n                orphanedEntries,\r\n            };\r\n        } catch (error) {\r\n            console.error('Error getting lorebook stats:', error);\r\n            return {\r\n                name: lorebookName,\r\n                entryCount: 0,\r\n                trackedEntries: 0,\r\n                orphanedEntries: 0,\r\n                error: error.message,\r\n            };\r\n        }\r\n    });\r\n}\r\n","/**\r\n * JSON Parsing Debug Utilities for Name Tracker Extension\r\n * \r\n * This module provides console-based debugging tools to trace LLM response\r\n * transformations through the parsing pipeline. All logs use filterable prefixes\r\n * for easy grep analysis.\r\n * \r\n * Usage in console:\r\n *   grep \"\\[NT-DEBUG-RAW\\]\"     - See full LLM responses\r\n *   grep \"\\[NT-DEBUG-PARSE\\]\"   - See parsing transformation steps\r\n *   grep \"\\[NT-DEBUG-FLOW\\]\"    - See overall flow tracking\r\n * \r\n * @module tests/debug-parser\r\n */\r\n\r\n/**\r\n * Log raw LLM response before any processing\r\n * @param {string} response - Raw response from LLM API\r\n * @param {string} source - Source identifier ('SillyTavern' or 'Ollama')\r\n */\r\nexport function logRawResponse(response, source = 'Unknown') {\r\n    console.log('[NT-DEBUG-RAW] ========================================');\r\n    console.log('[NT-DEBUG-RAW] Source:', source);\r\n    console.log('[NT-DEBUG-RAW] Type:', typeof response);\r\n    console.log('[NT-DEBUG-RAW] Length:', response?.length || 0);\r\n    console.log('[NT-DEBUG-RAW] First 500 chars:', response?.substring(0, 500) || 'null/undefined');\r\n    console.log('[NT-DEBUG-RAW] Last 500 chars:', response?.substring(Math.max(0, (response?.length || 0) - 500)) || 'null/undefined');\r\n    console.log('[NT-DEBUG-RAW] Full response:');\r\n    console.log(response);\r\n    console.log('[NT-DEBUG-RAW] ========================================');\r\n}\r\n\r\n/**\r\n * Log parsing attempt with transformation details\r\n * @param {string} stage - Current parsing stage\r\n * @param {string} text - Text at current stage\r\n * @param {Object} metadata - Additional context\r\n */\r\nexport function logParseAttempt(stage, text, metadata = {}) {\r\n    console.log(`[NT-DEBUG-PARSE] ======= ${stage} =======`);\r\n    console.log('[NT-DEBUG-PARSE] Length:', text?.length || 0);\r\n    \r\n    if (metadata.previousLength !== undefined) {\r\n        const delta = (text?.length || 0) - metadata.previousLength;\r\n        console.log('[NT-DEBUG-PARSE] Delta:', delta >= 0 ? `+${delta}` : delta);\r\n        \r\n        // Alert on suspicious length changes\r\n        if (Math.abs(delta) > (metadata.previousLength * 0.9)) {\r\n            console.warn('[NT-DEBUG-PARSE]  SUSPICIOUS LENGTH CHANGE! Lost', \r\n                Math.abs(delta), 'characters (', \r\n                ((Math.abs(delta) / metadata.previousLength) * 100).toFixed(1), '% of original)');\r\n        }\r\n    }\r\n    \r\n    if (text && typeof text === 'string') {\r\n        console.log('[NT-DEBUG-PARSE] First 300 chars:', text.substring(0, 300));\r\n        console.log('[NT-DEBUG-PARSE] Last 200 chars:', text.substring(Math.max(0, text.length - 200)));\r\n        \r\n        // Check for common issues\r\n        const issues = [];\r\n        if (text.includes('```')) issues.push('Contains markdown code blocks');\r\n        if (text.includes('<think>') || text.includes('</think>')) issues.push('Contains XML thinking tags');\r\n        if (!text.trim().startsWith('{')) issues.push('Does not start with {');\r\n        if (!text.trim().endsWith('}')) issues.push('Does not end with }');\r\n        if (text.includes('\\\\n') || text.includes('\\\\\"')) issues.push('Contains escaped characters');\r\n        \r\n        if (issues.length > 0) {\r\n            console.log('[NT-DEBUG-PARSE] Issues detected:', issues.join(', '));\r\n        }\r\n    } else {\r\n        console.log('[NT-DEBUG-PARSE] Text is not a string or is null/undefined');\r\n    }\r\n    \r\n    if (metadata.action) {\r\n        console.log('[NT-DEBUG-PARSE] Action:', metadata.action);\r\n    }\r\n    \r\n    console.log('[NT-DEBUG-PARSE] =====================================');\r\n}\r\n\r\n/**\r\n * Log transformation pipeline with before/after comparison\r\n * @param {Array<Object>} transformations - Array of transformation steps\r\n */\r\nexport function logTransformations(transformations) {\r\n    console.log('[NT-DEBUG-FLOW] ========== TRANSFORMATION PIPELINE ==========');\r\n    \r\n    transformations.forEach((transform, index) => {\r\n        console.log(`[NT-DEBUG-FLOW] Step ${index + 1}: ${transform.name}`);\r\n        console.log(`[NT-DEBUG-FLOW]   Before: ${transform.before} chars`);\r\n        console.log(`[NT-DEBUG-FLOW]   After:  ${transform.after} chars`);\r\n        console.log(`[NT-DEBUG-FLOW]   Delta:  ${transform.after - transform.before}`);\r\n        \r\n        if (transform.regex) {\r\n            console.log(`[NT-DEBUG-FLOW]   Regex:  ${transform.regex}`);\r\n        }\r\n        \r\n        if (transform.matches !== undefined) {\r\n            console.log(`[NT-DEBUG-FLOW]   Matches: ${transform.matches}`);\r\n        }\r\n    });\r\n    \r\n    const initialLength = transformations[0]?.before || 0;\r\n    const finalLength = transformations[transformations.length - 1]?.after || 0;\r\n    const totalDelta = finalLength - initialLength;\r\n    const percentChange = initialLength > 0 ? ((totalDelta / initialLength) * 100).toFixed(1) : 0;\r\n    \r\n    console.log('[NT-DEBUG-FLOW] ================================================');\r\n    console.log('[NT-DEBUG-FLOW] Initial length:', initialLength);\r\n    console.log('[NT-DEBUG-FLOW] Final length:', finalLength);\r\n    console.log('[NT-DEBUG-FLOW] Total delta:', totalDelta, `(${percentChange}%)`);\r\n    \r\n    if (Math.abs(totalDelta) > (initialLength * 0.5)) {\r\n        console.warn('[NT-DEBUG-FLOW]  CRITICAL: Lost more than 50% of content through transformations!');\r\n    }\r\n    \r\n    console.log('[NT-DEBUG-FLOW] ================================================');\r\n}\r\n\r\n/**\r\n * Compare regex extraction results\r\n * @param {string} original - Original text\r\n * @param {string} pattern - Regex pattern used\r\n * @param {string} extracted - Extracted result\r\n */\r\nexport function logRegexExtraction(original, pattern, extracted) {\r\n    console.log('[NT-DEBUG-PARSE] ========== REGEX EXTRACTION ==========');\r\n    console.log('[NT-DEBUG-PARSE] Pattern:', pattern);\r\n    console.log('[NT-DEBUG-PARSE] Original length:', original?.length || 0);\r\n    console.log('[NT-DEBUG-PARSE] Extracted length:', extracted?.length || 0);\r\n    \r\n    if ((original?.length || 0) > 0) {\r\n        const percentExtracted = ((extracted?.length || 0) / original.length * 100).toFixed(1);\r\n        console.log('[NT-DEBUG-PARSE] Extraction efficiency:', percentExtracted, '%');\r\n        \r\n        if (percentExtracted < 10) {\r\n            console.error('[NT-DEBUG-PARSE]  EXTRACTION FAILURE: Extracted less than 10% of original content!');\r\n        }\r\n    }\r\n    \r\n    console.log('[NT-DEBUG-PARSE] Original (first 200 chars):', original?.substring(0, 200));\r\n    console.log('[NT-DEBUG-PARSE] Extracted (first 200 chars):', extracted?.substring(0, 200));\r\n    console.log('[NT-DEBUG-PARSE] =======================================');\r\n}\r\n\r\n/**\r\n * Log JSON repair attempt details\r\n * @param {string} original - Text before repair\r\n * @param {string} repaired - Text after repair\r\n * @param {Array<string>} repairsApplied - List of repair operations\r\n */\r\nexport function logRepairAttempt(original, repaired, repairsApplied = []) {\r\n    console.log('[NT-DEBUG-PARSE] ========== JSON REPAIR ==========');\r\n    console.log('[NT-DEBUG-PARSE] Original length:', original?.length || 0);\r\n    console.log('[NT-DEBUG-PARSE] Repaired length:', repaired?.length || 0);\r\n    console.log('[NT-DEBUG-PARSE] Repairs applied:', repairsApplied.length);\r\n    \r\n    repairsApplied.forEach((repair, index) => {\r\n        console.log(`[NT-DEBUG-PARSE]   ${index + 1}. ${repair}`);\r\n    });\r\n    \r\n    if (original !== repaired) {\r\n        console.log('[NT-DEBUG-PARSE] Repair changed the text');\r\n        \r\n        // Show diff in critical areas\r\n        if (original.substring(0, 100) !== repaired.substring(0, 100)) {\r\n            console.log('[NT-DEBUG-PARSE] Beginning differs:');\r\n            console.log('[NT-DEBUG-PARSE]   Before:', original.substring(0, 100));\r\n            console.log('[NT-DEBUG-PARSE]   After:', repaired.substring(0, 100));\r\n        }\r\n        \r\n        if (original.substring(original.length - 100) !== repaired.substring(repaired.length - 100)) {\r\n            console.log('[NT-DEBUG-PARSE] Ending differs:');\r\n            console.log('[NT-DEBUG-PARSE]   Before:', original.substring(original.length - 100));\r\n            console.log('[NT-DEBUG-PARSE]   After:', repaired.substring(repaired.length - 100));\r\n        }\r\n    } else {\r\n        console.log('[NT-DEBUG-PARSE] No changes made during repair');\r\n    }\r\n    \r\n    console.log('[NT-DEBUG-PARSE] =================================');\r\n}\r\n\r\n/**\r\n * Log final parse result or error\r\n * @param {boolean} success - Whether parsing succeeded\r\n * @param {Object|Error} result - Parsed object or error\r\n * @param {string} finalText - Final text that was parsed (or failed to parse)\r\n */\r\nexport function logParseResult(success, result, finalText) {\r\n    console.log('[NT-DEBUG-FLOW] ========== PARSE RESULT ==========');\r\n    console.log('[NT-DEBUG-FLOW] Success:', success);\r\n    \r\n    if (success) {\r\n        console.log('[NT-DEBUG-FLOW] Result type:', typeof result);\r\n        console.log('[NT-DEBUG-FLOW] Has characters array:', Array.isArray(result?.characters));\r\n        console.log('[NT-DEBUG-FLOW] Character count:', result?.characters?.length || 0);\r\n        \r\n        if (result?.characters && Array.isArray(result.characters)) {\r\n            result.characters.forEach((char, index) => {\r\n                console.log(`[NT-DEBUG-FLOW]   Character ${index + 1}: ${char.name || 'unnamed'}`);\r\n            });\r\n        }\r\n    } else {\r\n        console.error('[NT-DEBUG-FLOW]  Parse failed');\r\n        console.error('[NT-DEBUG-FLOW] Error type:', result?.name || typeof result);\r\n        console.error('[NT-DEBUG-FLOW] Error message:', result?.message || String(result));\r\n        \r\n        if (result?.stack) {\r\n            console.error('[NT-DEBUG-FLOW] Stack trace:', result.stack);\r\n        }\r\n        \r\n        console.error('[NT-DEBUG-FLOW] Final text that failed to parse (first 300 chars):');\r\n        console.error(finalText?.substring(0, 300));\r\n        console.error('[NT-DEBUG-FLOW] Final text that failed to parse (last 200 chars):');\r\n        console.error(finalText?.substring(Math.max(0, (finalText?.length || 0) - 200)));\r\n    }\r\n    \r\n    console.log('[NT-DEBUG-FLOW] ==================================');\r\n}\r\n\r\n/**\r\n * Create a complete parsing session log\r\n * @returns {Object} Session object with methods to track parsing flow\r\n */\r\nexport function createParsingSession() {\r\n    const sessionId = `parse-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n    const transformations = [];\r\n    \r\n    return {\r\n        sessionId,\r\n        \r\n        logStart(source, rawResponse) {\r\n            console.log(`[NT-DEBUG-FLOW] ========== PARSING SESSION START: ${sessionId} ==========`);\r\n            logRawResponse(rawResponse, source);\r\n        },\r\n        \r\n        logTransform(name, before, after, details = {}) {\r\n            const transform = {\r\n                name,\r\n                before: before?.length || 0,\r\n                after: after?.length || 0,\r\n                ...details\r\n            };\r\n            transformations.push(transform);\r\n            \r\n            logParseAttempt(name, after, {\r\n                previousLength: before?.length || 0,\r\n                action: details.action || name\r\n            });\r\n        },\r\n        \r\n        logEnd(success, result, finalText) {\r\n            logTransformations(transformations);\r\n            logParseResult(success, result, finalText);\r\n            console.log(`[NT-DEBUG-FLOW] ========== PARSING SESSION END: ${sessionId} ==========`);\r\n        }\r\n    };\r\n}\r\n","/**\r\n * LLM Integration Module\r\n *\r\n * Handles LLM API calls to SillyTavern and Ollama for character analysis.\r\n * Includes conservative parameter settings, token management, context window handling,\r\n * and JSON parsing for deterministic character extraction.\r\n */\r\n\r\nimport { createModuleLogger } from '../core/debug.js';\r\nimport { withErrorBoundary, NameTrackerError } from '../core/errors.js';\r\nimport { get_settings, getCharacters, getLLMConfig } from '../core/settings.js';\r\nimport { stContext } from '../core/context.js';\r\nimport { simpleHash } from '../utils/helpers.js';\r\nimport { NotificationManager } from '../utils/notifications.js';\r\nimport {\r\n    logRawResponse,\r\n    logRegexExtraction,\r\n    createParsingSession,\r\n} from '../../tests/debug-parser.js';\r\n\r\nconst debug = createModuleLogger('llm');\r\nconst notifications = new NotificationManager('LLM Integration');\r\n\r\n// ============================================================================\r\n// DEBUG CONFIGURATION\r\n// ============================================================================\r\nconst DEBUG_LOGGING = false; // Default off to reduce console noise\r\n\r\nfunction debugLog(message, data = null) {\r\n    if (DEBUG_LOGGING) {\r\n        console.log(`[NT-LLM] ${message}`, data || '');\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// CONFIGURATION CONSTANTS - Conservative parameters for deterministic output\r\n// ============================================================================\r\n// These hardcoded values ensure reliable JSON extraction with minimal hallucination.\r\n// They override user chat settings specifically for character analysis operations.\r\n\r\n// Generation Parameters (Anti-hallucination configuration)\r\nconst GENERATION_TEMPERATURE = 0.2;     // Very low for deterministic output\r\nconst GENERATION_TOP_P = 0.85;          // Slightly reduced nucleus sampling\r\nconst GENERATION_TOP_K = 25;            // Standard focused sampling\r\nconst GENERATION_REP_PEN = 1.1;         // Slight repetition penalty\r\n\r\n// Context Window Management\r\n// Reserved for future dynamic context management\r\n// eslint-disable-next-line no-unused-vars\r\nconst RESPONSE_BUFFER_PERCENT = 25;     // Reserve 25% for response generation\r\n// eslint-disable-next-line no-unused-vars\r\nconst SAFETY_MARGIN_PERCENT = 10;       // Reserve 10% safety margin\r\n// eslint-disable-next-line no-unused-vars\r\nconst MIN_RESPONSE_TOKENS = 1000;       // Minimum tokens allowed for response\r\n\r\n// Ollama-Specific Parameters\r\n// eslint-disable-next-line no-unused-vars\r\nconst OLLAMA_MIN_PREDICT = 500;         // Minimum tokens to predict\r\n// eslint-disable-next-line no-unused-vars\r\nconst OLLAMA_MAX_PREDICT = 4000;        // Maximum tokens to predict\r\n\r\n// Cache Configuration\r\n// eslint-disable-next-line no-unused-vars\r\nconst CACHE_MAX_ENTRIES = 50;           // Maximum cached analysis results\r\n// eslint-disable-next-line no-unused-vars\r\nconst CACHE_INVALIDATION_TIME = 3600000; // 1 hour cache duration\r\n\r\n// LLM state management\r\nconst analysisCache = new Map(); // Cache for LLM analysis results\r\nlet ollamaModels = []; // Available Ollama models\r\n\r\n// Session telemetry tracking (reset on chat change)\r\nconst sessionTelemetry = {\r\n    budgetingMethod: [], // 'NER' or 'fallback'\r\n    entityCounts: [],\r\n    rosterSizes: [],\r\n    calculatedBudgets: [],\r\n    actualResponseTokens: [],\r\n    totalCalls: 0,\r\n    nerSuccesses: 0,\r\n    nerFailures: 0,\r\n};\r\n\r\n/**\r\n * Reset session telemetry (call on chat change)\r\n */\r\nexport function resetSessionTelemetry() {\r\n    sessionTelemetry.budgetingMethod = [];\r\n    sessionTelemetry.entityCounts = [];\r\n    sessionTelemetry.rosterSizes = [];\r\n    sessionTelemetry.calculatedBudgets = [];\r\n    sessionTelemetry.actualResponseTokens = [];\r\n    sessionTelemetry.totalCalls = 0;\r\n    sessionTelemetry.nerSuccesses = 0;\r\n    sessionTelemetry.nerFailures = 0;\r\n    console.log('[NT-Telemetry] Session telemetry reset');\r\n}\r\n\r\n/**\r\n * Log session telemetry summary\r\n */\r\nexport function logSessionTelemetry() {\r\n    if (sessionTelemetry.totalCalls === 0) {\r\n        console.log('[NT-Telemetry] No LLM calls this session');\r\n        return;\r\n    }\r\n\r\n    console.log('[NT-Telemetry] ========== Session Summary ==========');\r\n    console.log('[NT-Telemetry] Total LLM calls:', sessionTelemetry.totalCalls);\r\n    console.log('[NT-Telemetry] NER successes:', sessionTelemetry.nerSuccesses,\r\n        `(${((sessionTelemetry.nerSuccesses / sessionTelemetry.totalCalls) * 100).toFixed(1)}%)`);\r\n    console.log('[NT-Telemetry] NER failures (fallback used):', sessionTelemetry.nerFailures,\r\n        `(${((sessionTelemetry.nerFailures / sessionTelemetry.totalCalls) * 100).toFixed(1)}%)`);\r\n\r\n    if (sessionTelemetry.calculatedBudgets.length > 0) {\r\n        const avgBudget = sessionTelemetry.calculatedBudgets.reduce((a, b) => a + b, 0) / sessionTelemetry.calculatedBudgets.length;\r\n        console.log('[NT-Telemetry] Average calculated budget:', Math.round(avgBudget), 'tokens');\r\n    }\r\n\r\n    if (sessionTelemetry.actualResponseTokens.length > 0) {\r\n        const avgActual = sessionTelemetry.actualResponseTokens.reduce((a, b) => a + b, 0) / sessionTelemetry.actualResponseTokens.length;\r\n        console.log('[NT-Telemetry] Average actual response:', Math.round(avgActual), 'tokens');\r\n\r\n        // Calculate efficiency\r\n        if (sessionTelemetry.calculatedBudgets.length === sessionTelemetry.actualResponseTokens.length) {\r\n            let totalEfficiency = 0;\r\n            for (let i = 0; i < sessionTelemetry.calculatedBudgets.length; i++) {\r\n                totalEfficiency += (sessionTelemetry.actualResponseTokens[i] / sessionTelemetry.calculatedBudgets[i]) * 100;\r\n            }\r\n            const avgEfficiency = totalEfficiency / sessionTelemetry.calculatedBudgets.length;\r\n            console.log('[NT-Telemetry] Average efficiency:', avgEfficiency.toFixed(1) + '%');\r\n        }\r\n    }\r\n\r\n    console.log('[NT-Telemetry] ========================================');\r\n}\r\n\r\n/**\r\n * Calculate response token budget using NER with fallback\r\n * @param {string} messageText - Messages to analyze for entity count\r\n * @param {number} rosterSize - Number of existing characters in lorebook\r\n * @returns {Promise<{budget: number, method: string, entityCount: number}>}\r\n */\r\n// eslint-disable-next-line no-unused-vars\r\nasync function calculateResponseBudget(messageText, rosterSize) {\r\n    const settings = await get_settings();\r\n    const maxResponseTokens = settings.maxResponseTokens || 5000;\r\n\r\n    let entityCount = 0;\r\n    let method = 'fallback';\r\n\r\n    // Try NER-based entity extraction\r\n    try {\r\n        // Attempt to use SillyTavern transformers for NER\r\n        // This is the proper way to access transformers in ST extensions\r\n        const context = stContext.getContext();\r\n        if (context?.ai?.transformers?.pipeline) {\r\n            const ner = await context.ai.transformers.pipeline('ner');\r\n            const entities = await ner(messageText);\r\n\r\n            // Count unique entities (people)\r\n            const uniqueEntities = new Set();\r\n            for (const entity of entities) {\r\n                if (entity.entity_group === 'PER' || entity.entity.startsWith('B-PER') || entity.entity.startsWith('I-PER')) {\r\n                    uniqueEntities.add(entity.word.toLowerCase());\r\n                }\r\n            }\r\n\r\n            entityCount = uniqueEntities.size;\r\n            method = 'NER';\r\n            sessionTelemetry.nerSuccesses++;\r\n\r\n            console.log('[NT-Budget] NER detected', entityCount, 'entities');\r\n        } else {\r\n            throw new Error('Transformers pipeline not available');\r\n        }\r\n    } catch (error) {\r\n        // Fallback to character count estimation\r\n        console.log('[NT-Budget] NER unavailable, using fallback estimation:', error.message);\r\n        method = 'fallback';\r\n        sessionTelemetry.nerFailures++;\r\n\r\n        // Estimate: characterCount  300 + 1000\r\n        const characterCount = messageText.length;\r\n        entityCount = Math.ceil(characterCount / 1000); // Rough estimate for logging\r\n    }\r\n\r\n    // Calculate budget based on method\r\n    let budget;\r\n    if (method === 'NER') {\r\n        // NER-based: entityCount + rosterSize, scaled by 300 tokens per character\r\n        const totalCharacters = entityCount + rosterSize;\r\n        budget = (totalCharacters * 300) + 1000; // Base 1000 + scaling\r\n    } else {\r\n        // Fallback: character count  300 + 1000\r\n        budget = (messageText.length * 300) + 1000;\r\n    }\r\n\r\n    // Apply cap\r\n    budget = Math.min(budget, maxResponseTokens);\r\n\r\n    console.log('[NT-Budget] Method:', method);\r\n    console.log('[NT-Budget] Entity count:', entityCount);\r\n    console.log('[NT-Budget] Roster size:', rosterSize);\r\n    console.log('[NT-Budget] Calculated budget:', budget, 'tokens');\r\n    console.log('[NT-Budget] Max cap:', maxResponseTokens, 'tokens');\r\n\r\n    // Track telemetry\r\n    sessionTelemetry.totalCalls++;\r\n    sessionTelemetry.budgetingMethod.push(method);\r\n    sessionTelemetry.entityCounts.push(entityCount);\r\n    sessionTelemetry.rosterSizes.push(rosterSize);\r\n    sessionTelemetry.calculatedBudgets.push(budget);\r\n\r\n    return { budget, method, entityCount };\r\n}\r\n\r\n/**\r\n * Default system prompt for character analysis\r\n */\r\nconst DEFAULT_SYSTEM_PROMPT = `Extract character information from messages and return ONLY a JSON object.\r\n\r\n/nothink\r\n\r\n[CURRENT LOREBOOK ENTRIES]\r\nThe following characters have already been identified. Their information is shown in lorebook format (keys + content).\r\nIf a character appears in the new messages with additional/changed information, include them in your response.\r\nIf a character is NOT mentioned or has no new information, do NOT include them in your response.\r\n\r\n{{CHARACTER_ROSTER}}\r\n\r\n REQUIRED: Always include the user character ({{user}}) in your response, even if minimal details\r\nFor other characters from Current Lorebook Entries: only include if NEW information appears in these messages\r\nReturning only the user character is valid when no other character updates exist\r\n\r\n CRITICAL INSTRUCTION: Only include characters with NEW information in these specific messages. If a character from the lorebook appears but provides no new details, DO NOT include them in your response.\r\n\r\nExample: Alice from lorebook says 'Hi' in message 5  No new info  Omit Alice from response\r\nExample: {{user}} always appears  Always include {{user}} with any available details\r\n\r\nCRITICAL JSON REQUIREMENTS:\r\n STRICT JSON FORMATTING - PARSING WILL FAIL IF NOT FOLLOWED \r\n\r\n ABSOLUTELY NO XML TAGS: Do not use <think>, </think>, <thinking>, or any XML tags\r\n PURE JSON ONLY: Your response must be immediately parseable JSON with no wrappers\r\n\r\nMANDATORY SYNTAX RULES:\r\n- Your ENTIRE response must be valid JSON starting with { and ending with }\r\n- ALL property names MUST use double quotes: \"name\", \"aliases\", etc.\r\n- ALL string values MUST use double quotes and escape internal quotes: \"He said \\\\\"hello\\\\\"\"\r\n- NEVER output unquoted text in any field: \"roleSkills\": observed symptoms  WRONG\r\n- CORRECT: \"roleSkills\": \"observed symptoms\"  or \"roleSkills\": null \r\n- NO control characters (line breaks, tabs) inside string values\r\n- NO trailing commas before } or ]\r\n- EVERY property must have a colon: \"name\": \"value\" (not \"name\" \"value\")\r\n- NO markdown, NO explanations, NO text before or after the JSON\r\n\r\n ABSOLUTELY FORBIDDEN PATTERNS THAT BREAK PARSING:\r\n <think>reasoning</think> or </think> or any XML tags\r\n Code blocks: \\\\\\`\\\\\\`\\\\\\`json { \"characters\": [...] } \\\\\\`\\\\\\`\\\\\\`\r\n \"name\": \"John\", \"He is tall and strong\", \"age\": 25\r\n   (orphaned description without property name)\r\n \"physical\" \"brown hair and blue eyes\"\r\n   (missing colon)\r\n \"aliases\": [\"John\", \"Scout\",]\r\n   (trailing comma)\r\n Here's the analysis: { \"characters\": [...] }\r\n   (text before JSON)\r\n\r\n CORRECT FORMAT ONLY:\r\n{\r\n  \"characters\": [\r\n    {\r\n      \"name\": \"Full Name\",\r\n      \"physical\": \"description here\",\r\n      \"aliases\": [\"nick1\", \"nick2\"]\r\n    }\r\n  ]\r\n}\r\n\r\n VALIDATION CHECK: Before responding, verify:\r\n1. Starts with { immediately (no text before)\r\n2. Every string has opening AND closing quotes\r\n3. Every property has a colon after the name\r\n4. No orphaned text without property names\r\n5. Ends with } immediately (no text after)\r\n\r\nONLY include characters mentioned in these specific messages or with new information\r\nDO NOT repeat unchanged characters from the Current Lorebook Entries\r\n\r\nDO NOT include:\r\n- Any text before the JSON\r\n- Any text after the JSON\r\n- Code block markers like \\\\\\`\\\\\\`\\\\\\`json\r\n- Explanations, commentary, or thinking tags\r\n- XML tags like <think> or </think> (these break JSON parsing)\r\n\r\nREQUIRED JSON structure (copy this exact format):\r\n{\r\n  \"characters\": [\r\n    {\r\n      \"name\": \"Full character name (SINGLE NAME ONLY - never include aliases here)\",\r\n      \"aliases\": [\"Alternative names for THIS SAME person - nicknames, shortened names, titles\"],\r\n      \"physicalAge\": \"Age if mentioned\",\r\n      \"mentalAge\": \"Mental age if different\",\r\n      \"physical\": \"Physical description\",\r\n      \"personality\": \"Personality traits\",\r\n      \"sexuality\": \"Sexual orientation if mentioned\",\r\n      \"raceEthnicity\": \"Race/ethnicity if mentioned\",\r\n      \"roleSkills\": \"Job/role/skills (MUST be quoted string or null, never unquoted text)\",\r\n      \"relationships\": [\"currentchar, otherchar, relationship\"],\r\n      \"confidence\": 75\r\n    }\r\n  ]\r\n}\r\n\r\nCRITICAL FIELD SPECIFICATIONS:\r\n\r\nNAME FIELD RULES:\r\n- Use the MOST COMPLETE proper name mentioned (e.g., \"John Blackwood\")\r\n- NEVER include commas, slashes, or multiple names in the name field\r\n- NEVER combine name + alias ( \"John Blackwood, John\"  \"John/Scout\")\r\n- If only a first name is known, use just that (\"John\")\r\n\r\nALIASES FIELD RULES:\r\n- Include ALL other ways this character is referred to\r\n- Nicknames, shortened names, titles, alternative spellings\r\n- Examples: [\"John\", \"Scout\", \"JB\", \"Mr. Blackwood\"]\r\n\r\nRELATIONSHIPS FIELD - NATURAL LANGUAGE FORMAT:\r\n CRITICAL: ONLY use this format: \"Character A is to Character B: relationship1, relationship2\"\r\n\r\n FORBIDDEN FORMATS:\r\n- \"Character, Other, relationship\" (OLD TRIPLET FORMAT - DO NOT USE)\r\n- \"Character A, Character B, relationship\" (OLD TRIPLET FORMAT - DO NOT USE)\r\n\r\n MANDATORY FORMAT: \"Character A is to Character B: relationship1, relationship2\"\r\n\r\n CRITICAL NAMING REQUIREMENTS:\r\n- ALWAYS use the character's CANONICAL/PREFERRED name in relationships\r\n- If \"John Blackwood\" is the main name, use \"John Blackwood\" NOT \"John\"\r\n- Maintain name consistency across ALL relationship entries\r\n- Multiple relationships for same pair: separate with commas\r\n\r\n CORRECT examples:\r\n- \"Dora is to John Blackwood: lover, submissive\"\r\n- \"Maya is to Sarah Chen: sister, gymnastics partner\"\r\n- \"John Blackwood is to Julia Martinez: son\"\r\n- \"Sarah Chen is to John Blackwood: rival, former colleague\"\r\n\r\n FORBIDDEN patterns:\r\n- \"Dora, John, lover\" (OLD FORMAT - NEVER USE)\r\n- \"Dora, John Blackwood, lover\" (OLD FORMAT - NEVER USE)\r\n- \"John, Jasmine, friend\" (OLD FORMAT - NEVER USE)\r\n- \"Dora is to John: lover\" + \"Dora is to John Blackwood: lover\" (inconsistent naming)\r\n- Narrative text: \"Living in luxury penthouse since age 17\"\r\n- Actions/events: \"Takes charge of organizing rescue mission\"\r\n\r\n RELATIONSHIP FORMAT - DIRECTIONALITY IS CRITICAL:\r\n MANDATORY FORMAT: \"[CurrentCharacter] is to [TargetCharacter]: [role]\"\r\n\r\nDIRECTIONALITY EXAMPLES (notice the direction matters!):\r\n CORRECT:\r\n- \"John Blackwood is to Julia Chen: son\" (John is Julia's son)\r\n- \"Julia Chen is to John Blackwood: mother\" (Julia is John's mother)\r\n- \"Emma is to David: wife\" (Emma is David's wife)\r\n- \"David is to Emma: husband\" (David is Emma's husband)\r\n\r\n WRONG - These lose directionality:\r\n- \"John, Julia, son\"  NO! Ambiguous direction\r\n- \"Julia is to John: son\"  NO! Julia is not John's son\r\n\r\nALLOWED CORE RELATIONSHIP TYPES ONLY:\r\nFAMILY: parent, mother, father, child, son, daughter, sibling, brother, sister, spouse, husband, wife\r\n**Standardized Relationships (Directional Dynamics):**\r\n\r\nRelationships MUST follow this specific string format: \"[CurrentCharacterName] is to [TargetCharacterName]: [Role1], [Role2]\"\r\n\r\n**Directionality is Critical:** The first name MUST be the character defined in the current JSON entry. The second name is the target.\r\n\r\n**Multi-Faceted Roles:** Include all applicable dynamics.\r\nExample: \"John is to Jasmine: Friend, Lab Partner, Lover, Rival\"\r\n\r\n**Depth Requirement:** Capture real social, professional, romantic, or power dynamics.\r\n\r\n**ALLOWED (Examples, not exhaustive):** Friend, Lover, Spouse, Rival, Boss, Employee, Captor, Prisoner, Illicit Affair Partner, Sexual Dominant, Submissive, Mentor, Protg, Parent, Child, Sibling, Cousin, Uncle, Aunt, Neighbor, Landlord, Tenant, Doctor, Patient, Teacher, Student, etc.\r\n\r\n**FORBIDDEN:** Do not use situational \"concepts\" or passive states like \"Witness,\" \"Bystander,\" \"Observer,\" \"Listener,\" or \"Interviewer.\" If no real dynamic exists beyond \"witnessing,\" do not include the relationship.\r\n\r\n**Strict Constraint:** Do NOT include actions, events, or history (e.g., \"John met Julia at a bar\" or \"John is angry at Julia\"). Only include the core social or familial standing.\r\n\r\n**No History/Actions:** Do not include events (e.g., \"John is to Jasmine: Person who saved her life\"). Focus strictly on the current standing/role.\r\n\r\n CRITICAL FORMAT RULES:\r\n1. ALWAYS use \"[Name] is to [Name]: [role]\" format\r\n2. Use CANONICAL character names from lorebook (never aliases)\r\n3. Direction matters: \"A is to B: parent\"  \"B is to A: parent\"\r\n4. Multiple roles allowed per relationship: \"A is to B: Friend, Colleague, Rival\"\r\n\r\nRules:\r\n- One entry per distinct person. NEVER combine two different people into one entry.\r\n- If the same person is referred by variants (\"John\", \"John Blackwell\", \"Scout\"), make ONE entry with name = best full name (\"John Blackwell\") and put other names in aliases.\r\n- Do NOT create names like \"Jade/Jesse\" or \"Sarah and Maya\". Instead, create separate entries: [{\"name\":\"Jade\"}, {\"name\":\"Jesse\"}].\r\n- Only extract clearly named speaking characters.\r\n- Skip generic references (\"the waiter\", \"a woman\").\r\n- Use most recent information for conflicts.\r\n- Empty array if no clear characters: {\"characters\":[]}\r\n- Confidence: 90+ (explicit), 70-89 (clear), 50-69 (mentioned), <50 (vague).\r\n\r\nFIELD EXAMPLES:\r\n\r\nNAME EXAMPLES:\r\n \"John Blackwood\" (not \"John Blackwood, John\")\r\n \"Maria Santos\" (not \"Maria/Marie\")\r\n \"Alex\" (when full name unknown)\r\n\r\nALIAS EXAMPLES:\r\n [\"John\", \"Scout\", \"JB\"]\r\n [\"Marie\", \"Maria\"]\r\n [\"Mom\", \"Mother\", \"Sarah\"]\r\n\r\nRELATIONSHIP EXAMPLES:\r\n [\"Dora is to John Blackwood: lover, submissive\", \"Maya is to Sarah Chen: sister, gymnastics partner\"]\r\n [\"Lives in penthouse\", \"Writing novels\", \"Leading group\", \"Met at bar\"]\r\n [\"Dora, John, lover\", \"John, Jasmine, friend\"] (OLD TRIPLET FORMAT - NEVER USE)\r\n [\"Dora is to John: lover\", \"Dora is to John Blackwood: submissive\"] (split relationships)\r\n\r\n FINAL REMINDER - CRITICAL FOR SUCCESS:\r\nYour response must start with { immediately and end with } immediately.\r\nNO text, explanations, or markers before or after the JSON.\r\nEvery description must have a property name: \"physical\": \"tall\", not just \"tall\".\r\nValidate your JSON syntax before responding - missing colons or orphaned strings will cause parsing failure.\r\n\r\nYour response must start with { immediately.`;\r\n\r\n/**\r\n * Get the system prompt for analysis\r\n * @returns {string} System prompt text\r\n */\r\nasync function getSystemPrompt() {\r\n    const settings = await get_settings();\r\n    const prompt = settings?.systemPrompt || DEFAULT_SYSTEM_PROMPT;\r\n    // Ensure we return a string, not a Promise or object\r\n    return typeof prompt === 'string' ? prompt : DEFAULT_SYSTEM_PROMPT;\r\n}\r\n\r\n/**\r\n * Load available Ollama models from the configured endpoint and cache them.\r\n * @returns {Promise<Array>} Array of available models\r\n */\r\nexport async function loadOllamaModels() {\r\n    return withErrorBoundary('loadOllamaModels', async () => {\r\n        const ollamaEndpoint = await get_settings('ollamaEndpoint', 'http://localhost:11434');\r\n\r\n        try {\r\n            const response = await fetch(`${ollamaEndpoint}/api/tags`);\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`Failed to load Ollama models: ${response.status} ${response.statusText}`);\r\n            }\r\n\r\n            const data = await response.json();\r\n            ollamaModels = Array.isArray(data?.models) ? data.models : [];\r\n            debugLog(`[OllamaModels] Found ${ollamaModels.length} models: ${ollamaModels.map(m => m.name).join(', ')}`);\r\n            return [...ollamaModels];\r\n        } catch (error) {\r\n            console.error('Error loading Ollama models:', error);\r\n            notifications.error('Failed to load Ollama models. Check endpoint and try again.');\r\n            throw error;\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Get cached Ollama models\r\n * @returns {Array} Array of available models\r\n */\r\nexport function getOllamaModels() {\r\n    return [...ollamaModels];\r\n}\r\n\r\n/**\r\n * Get Ollama model context size\r\n * @param {string} modelName - Name of the Ollama model\r\n * @returns {Promise<number>} Context size in tokens, or default 4096\r\n */\r\nexport async function getOllamaModelContext(modelName) {\r\n    return withErrorBoundary('getOllamaModelContext', async () => {\r\n        const ollamaEndpoint = await get_settings('ollamaEndpoint', 'http://localhost:11434');\r\n\r\n        if (!modelName) {\r\n            debug.log();\r\n            return 4096;\r\n        }\r\n\r\n        try {\r\n            const response = await fetch(`${ollamaEndpoint}/api/show`, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                },\r\n                body: JSON.stringify({\r\n                    name: modelName,\r\n                }),\r\n            });\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`Failed to fetch model info: ${response.statusText}`);\r\n            }\r\n\r\n            const data = await response.json();\r\n\r\n            // Look for num_ctx in parameters array\r\n            if (data.parameters && Array.isArray(data.parameters)) {\r\n                for (const param of data.parameters) {\r\n                    const match = param.match(/num_ctx\\\\s+(\\\\d+)/);\r\n                    if (match) {\r\n                        const contextSize = parseInt(match[1]);\r\n                        debug.log();\r\n                        return contextSize;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Fallback: check if it's in model details\r\n            if (data.model_info && data.model_info.num_ctx) {\r\n                const contextSize = parseInt(data.model_info.num_ctx);\r\n                debug.log();\r\n                return contextSize;\r\n            }\r\n\r\n            debug.log();\r\n            return 4096;\r\n        } catch (error) {\r\n            console.error('Error fetching Ollama model context:', error);\r\n            debug.log();\r\n            return 4096;\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Build a roster of known characters in lorebook format for context\r\n * Returns keys and formatted content fields to support incremental updates\r\n * @returns {string} Formatted roster text with lorebook entries\r\n */\r\nexport async function buildCharacterRoster() {\r\n    return withErrorBoundary('buildCharacterRoster', async () => {\r\n        const characters = await getCharacters();\r\n        const characterNames = Object.keys(characters);\r\n\r\n        if (characterNames.length === 0) {\r\n            return '(None - this is the first analysis)';\r\n        }\r\n\r\n        const entries = characterNames.map(name => {\r\n            const char = characters[name];\r\n\r\n            // Build keys array (name + aliases)\r\n            const keys = [char.preferredName || name];\r\n            if (char.aliases && char.aliases.length > 0) {\r\n                keys.push(...char.aliases);\r\n            }\r\n\r\n            // Build formatted content (same format as lorebook)\r\n            const contentParts = [];\r\n\r\n            // Age info\r\n            if (char.physicalAge || char.mentalAge) {\r\n                const ageInfo = [];\r\n                if (char.physicalAge) ageInfo.push(`Physical: ${char.physicalAge}`);\r\n                if (char.mentalAge) ageInfo.push(`Mental: ${char.mentalAge}`);\r\n                contentParts.push(`**Age:** ${ageInfo.join(', ')}`);\r\n            }\r\n\r\n            // Physical\r\n            if (char.physical) {\r\n                contentParts.push(`\\\\n**Physical Description:**\\\\n${char.physical}`);\r\n            }\r\n\r\n            // Personality\r\n            if (char.personality) {\r\n                contentParts.push(`\\\\n**Personality:**\\\\n${char.personality}`);\r\n            }\r\n\r\n            // Sexuality\r\n            if (char.sexuality) {\r\n                contentParts.push(`\\\\n**Sexuality:**\\\\n${char.sexuality}`);\r\n            }\r\n\r\n            // Race/Ethnicity\r\n            if (char.raceEthnicity) {\r\n                contentParts.push(`**Race/Ethnicity:** ${char.raceEthnicity}`);\r\n            }\r\n\r\n            // Role & Skills\r\n            if (char.roleSkills) {\r\n                contentParts.push(`\\\\n**Role & Skills:**\\\\n${char.roleSkills}`);\r\n            }\r\n\r\n            // Relationships\r\n            if (char.relationships && char.relationships.length > 0) {\r\n                contentParts.push('\\\\n**Relationships:**');\r\n                char.relationships.forEach(rel => {\r\n                    contentParts.push(`- ${rel}`);\r\n                });\r\n            }\r\n\r\n            const content = contentParts.join('\\\\n');\r\n\r\n            return `\r\n---\r\nKEYS: ${keys.join(', ')}\r\nCONTENT:\r\n${content}\r\n`;\r\n        }).join('\\\\n');\r\n\r\n        return entries;\r\n    });\r\n}\r\n\r\n/**\r\n * Get the maximum safe prompt length based on API context window\r\n * Uses actual token counts from messages when available\r\n * @returns {Promise<number>} Maximum prompt length in tokens\r\n */\r\nexport async function getMaxPromptLength() {\r\n    return withErrorBoundary('getMaxPromptLength', async () => {\r\n        const detectionLog = []; // Track detection attempts\r\n        const logEntry = (msg) => {\r\n            detectionLog.push(msg);\r\n            console.log(`[NT-MaxContext] ${msg}`);\r\n        };\r\n\r\n        try {\r\n            const llmConfig = await getLLMConfig();\r\n            let maxContext = 8192; // Default minimum context\r\n            let detectionMethod = 'fallback';\r\n\r\n            logEntry(`Starting context detection for LLM source: ${llmConfig.source}`);\r\n\r\n            if (llmConfig.source === 'ollama' && llmConfig.ollamaModel) {\r\n                logEntry(`Using Ollama model: ${llmConfig.ollamaModel}`);\r\n                // Get Ollama model's context size\r\n                maxContext = await getOllamaModelContext(llmConfig.ollamaModel);\r\n                detectionMethod = 'ollama';\r\n            } else {\r\n                logEntry('Using SillyTavern context');\r\n                // Use SillyTavern's context\r\n                let context = null;\r\n\r\n                try {\r\n                    context = stContext.getContext();\r\n                    logEntry('Successfully retrieved SillyTavern context');\r\n                } catch (error) {\r\n                    logEntry(`ERROR: Failed to get context: ${error.message}`);\r\n                    context = null;\r\n                }\r\n\r\n                // Debug: Log all context properties\r\n                if (context) {\r\n                    try {\r\n                        const contextKeys = Object.keys(context);\r\n                        const relevantKeys = contextKeys.filter(k =>\r\n                            k.toLowerCase().includes('max') ||\r\n                            k.toLowerCase().includes('context') ||\r\n                            k.toLowerCase().includes('token') ||\r\n                            k.toLowerCase().includes('prompt'),\r\n                        );\r\n                        logEntry(`Available context properties: ${relevantKeys.join(', ')}`);\r\n                    } catch (e) {\r\n                        logEntry(`Error analyzing context keys: ${e.message}`);\r\n                    }\r\n                }\r\n\r\n                // Try multiple possible paths for max context\r\n                let detectedMaxContext = null;\r\n\r\n                // Method 1: Direct maxContext property (PRIMARY)\r\n                logEntry('Method 1: Checking context.maxContext...');\r\n                if (context && typeof context.maxContext === 'number' && context.maxContext > 0) {\r\n                    detectedMaxContext = context.maxContext;\r\n                    logEntry(` Method 1 SUCCESS: context.maxContext = ${detectedMaxContext}`);\r\n                    detectionMethod = 'context.maxContext';\r\n                } else {\r\n                    const reason = !context ? 'context is null' :\r\n                        typeof context.maxContext !== 'number' ? `type is ${typeof context.maxContext}` :\r\n                            context.maxContext <= 0 ? `value is ${context.maxContext}` : 'unknown';\r\n                    logEntry(` Method 1 FAILED: ${reason}`);\r\n                }\r\n\r\n                // Method 2: extensionSettings.common.maxContext path (REMOVED - API doesn't exist)\r\n                // This property path was incorrect and has been removed.\r\n                // Use getMaxContextSize() instead.\r\n\r\n                // Method 3: chat.maxContextSize path\r\n                if (!detectedMaxContext) {\r\n                    logEntry('Method 3: Checking context.chat.maxContextSize...');\r\n                    if (context?.chat && typeof context.chat === 'object' && !Array.isArray(context.chat)) {\r\n                        if (typeof context.chat.maxContextSize === 'number' && context.chat.maxContextSize > 0) {\r\n                            detectedMaxContext = context.chat.maxContextSize;\r\n                            logEntry(` Method 3 SUCCESS: chat.maxContextSize = ${detectedMaxContext}`);\r\n                            detectionMethod = 'chat.maxContextSize';\r\n                        } else {\r\n                            logEntry(' Method 3 FAILED: chat exists but maxContextSize is invalid');\r\n                        }\r\n                    } else {\r\n                        logEntry(' Method 3 FAILED: chat path does not exist or is an array');\r\n                    }\r\n                }\r\n\r\n                // Method 4: token_limit\r\n                if (!detectedMaxContext) {\r\n                    logEntry('Method 4: Checking context.token_limit...');\r\n                    if (context && typeof context.token_limit === 'number' && context.token_limit > 0) {\r\n                        detectedMaxContext = context.token_limit;\r\n                        logEntry(` Method 4 SUCCESS: token_limit = ${detectedMaxContext}`);\r\n                        detectionMethod = 'token_limit';\r\n                    } else {\r\n                        logEntry(' Method 4 FAILED: token_limit is not valid');\r\n                    }\r\n                }\r\n\r\n                // Method 5: amount_gen (maximum generation tokens)\r\n                if (!detectedMaxContext) {\r\n                    logEntry('Method 5: Checking context.amount_gen (fallback)...');\r\n                    if (context && typeof context.amount_gen === 'number' && context.amount_gen > 0) {\r\n                        // amount_gen is typically small (generation limit), not context size\r\n                        // Use as indicator if no other value found\r\n                        detectedMaxContext = context.amount_gen * 4; // Rough estimate\r\n                        logEntry(` Method 5 FALLBACK: amount_gen = ${context.amount_gen}, estimated context = ${detectedMaxContext}`);\r\n                        detectionMethod = 'amount_gen_estimate';\r\n                    } else {\r\n                        logEntry(' Method 5 FAILED: amount_gen is not valid');\r\n                    }\r\n                }\r\n\r\n                // Method 6: Check settings object directly\r\n                if (!detectedMaxContext) {\r\n                    logEntry('Method 6: Checking context.settings.max_context...');\r\n                    if (context && typeof context.settings === 'object') {\r\n                        if (typeof context.settings.max_context === 'number' && context.settings.max_context > 0) {\r\n                            detectedMaxContext = context.settings.max_context;\r\n                            logEntry(` Method 6 SUCCESS: settings.max_context = ${detectedMaxContext}`);\r\n                            detectionMethod = 'settings.max_context';\r\n                        } else {\r\n                            logEntry(' Method 6 FAILED: settings exists but max_context is invalid');\r\n                        }\r\n                    } else {\r\n                        logEntry(' Method 6 FAILED: settings path does not exist');\r\n                    }\r\n                }\r\n\r\n                // Final check: is detected value reasonable?\r\n                if (detectedMaxContext && (typeof detectedMaxContext !== 'number' || detectedMaxContext < 100)) {\r\n                    logEntry(`WARNING: Detected maxContext is not valid: ${detectedMaxContext}, type: ${typeof detectedMaxContext}`);\r\n                    detectedMaxContext = null;\r\n                }\r\n\r\n                // Check if context is fully loaded\r\n                if (!context || !detectedMaxContext) {\r\n                    logEntry('WARNING: Could not detect maxContext from any path, using fallback (8192)');\r\n                    logEntry(`Context exists: ${!!context}, detectedMaxContext: ${detectedMaxContext}`);\r\n                    if (context) {\r\n                        try {\r\n                            const allKeys = Object.keys(context).sort();\r\n                            logEntry(`Full context object keys (first 20): ${allKeys.slice(0, 20).join(', ')}${allKeys.length > 20 ? `... (${allKeys.length - 20} more)` : ''}`);\r\n                        } catch (e) {\r\n                            logEntry(`Could not enumerate context keys: ${e.message}`);\r\n                        }\r\n                    }\r\n                    maxContext = 8192; // Use minimum required context as fallback\r\n                    detectionMethod = 'fallback';\r\n                } else {\r\n                    maxContext = Math.floor(detectedMaxContext);\r\n                    logEntry(`Detected maxContext: ${maxContext} (type: ${typeof maxContext})`);\r\n                    // detectionMethod already set correctly\r\n                }\r\n            }\r\n\r\n            // Validate minimum context requirement (8K minimum)\r\n            if (maxContext < 8192) {\r\n                const errorMsg = `Model context too small: ${maxContext} tokens. Minimum required: 8192 tokens. Please use a model with larger context.`;\r\n                logEntry(errorMsg);\r\n                throw new NameTrackerError(errorMsg);\r\n            }\r\n\r\n            // Use generous context allocation for prompts (60% for prompt, 40% for response)\r\n            // Remove artificial 50K ceiling to use full available context\r\n            const tokensForPrompt = Math.floor(maxContext * 0.6);\r\n\r\n            logEntry(`Token allocation: maxContext=${maxContext}, promptAllocation=${tokensForPrompt}, responseAllocation=${maxContext - tokensForPrompt}`);\r\n            logEntry(`Final detection method: ${detectionMethod}`);\r\n\r\n            const finalValue = Math.max(1000, tokensForPrompt);\r\n            logEntry(`Returning maxPromptLength: ${finalValue}`);\r\n\r\n            // Return object with detection details\r\n            return {\r\n                maxPrompt: finalValue,\r\n                detectionMethod: detectionMethod,\r\n                maxContext: maxContext,\r\n                debugLog: detectionLog.join('\\n'),\r\n            };\r\n        } catch (error) {\r\n            const errorMsg = `ERROR in getMaxPromptLength: ${error.message}`;\r\n            logEntry(errorMsg);\r\n            console.error('[NT-MaxContext] Stack:', error.stack);\r\n            // Return conservative fallback on any error with details\r\n            return {\r\n                maxPrompt: 4915, // Based on 8192 minimum context with 60% allocation\r\n                detectionMethod: 'error',\r\n                maxContext: 8192, // Minimum required context\r\n                debugLog: detectionLog.join('\\n') + '\\nFATAL ERROR: ' + error.message,\r\n            };\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Calculate total token count for a batch of messages\r\n * Uses pre-calculated token counts from SillyTavern when available\r\n * @param {Array} messages - Array of chat message objects\r\n * @returns {Promise<number>} Total token count\r\n */\r\nexport async function calculateMessageTokens(messages) {\r\n    return withErrorBoundary('calculateMessageTokens', async () => {\r\n        const context = stContext.getContext();\r\n        let totalTokens = 0;\r\n\r\n        // Try to use pre-calculated token counts from message objects\r\n        for (const msg of messages) {\r\n            if (msg && typeof msg === 'object' && msg.extra && typeof msg.extra.token_count === 'number') {\r\n                // SillyTavern stores token count in extra.token_count\r\n                totalTokens += msg.extra.token_count;\r\n            } else {\r\n                // Fallback: use getTokenCountAsync for the message text\r\n                const text = msg?.mes || msg?.message || String(msg);\r\n                if (text && context.getTokenCountAsync) {\r\n                    try {\r\n                        const count = await context.getTokenCountAsync(text);\r\n                        totalTokens += count;\r\n                    // eslint-disable-next-line no-unused-vars\r\n                    } catch (_error) {\r\n                        debug.log();\r\n                        // Final fallback: rough estimate (4 chars per token)\r\n                        totalTokens += Math.ceil(text.length / 4);\r\n                    }\r\n                } else {\r\n                    // Character-based estimate\r\n                    totalTokens += Math.ceil(text.length / 4);\r\n                }\r\n            }\r\n        }\r\n\r\n        return totalTokens;\r\n    });\r\n}\r\n\r\n/**\r\n * Call SillyTavern's LLM using systemPrompt + prompt structure\r\n * Works in both Chat Completion and Text Completion modes\r\n * Retries up to 3 times with 2s delay on parse failures\r\n * @param {string} systemPrompt - System-level instructions\r\n * @param {string} prompt - User data/instructions to analyze\r\n * @param {string} prefill - Optional response prefill (e.g., \"{\" to force JSON)\r\n * @returns {Promise<Object>} Parsed JSON response\r\n */\r\nexport async function callSillyTavern(systemPrompt, prompt, prefill = '', interactive = false) {\r\n    return withErrorBoundary('callSillyTavern', async () => {\r\n        debug.log();\r\n\r\n        // Use SillyTavern.getContext() as recommended in official docs\r\n        const context = stContext.getContext();\r\n\r\n        // Check if we have an active API connection\r\n        if (!context.onlineStatus) {\r\n            throw new NameTrackerError('No API connection available. Please connect to an API first.');\r\n        }\r\n\r\n        if (DEBUG_LOGGING) {\r\n            console.log('[NT-ST-Call] Starting SillyTavern LLM call');\r\n            console.log('[NT-ST-Call] System prompt length:', systemPrompt.length, 'characters');\r\n            console.log('[NT-ST-Call] User prompt length:', prompt.length, 'characters');\r\n            if (prefill) console.log('[NT-ST-Call] Prefill:', prefill);\r\n            console.log('[NT-ST-Call] ========== PROMPT STRUCTURE START ==========');\r\n            console.log('SYSTEM:', systemPrompt);\r\n            console.log('USER:', prompt);\r\n            if (prefill) console.log('PREFILL:', prefill);\r\n            console.log('[NT-ST-Call] ========== PROMPT STRUCTURE END ==========');\r\n        }\r\n\r\n        // Calculate token counts separately for better tracking\r\n        const maxContext = context.maxContext || 8192;\r\n        let systemTokens, userTokens, totalPromptTokens;\r\n\r\n        try {\r\n            systemTokens = await context.getTokenCountAsync(systemPrompt);\r\n            const userPromptText = prompt + (prefill ? '\\n' + prefill : '');\r\n            userTokens = await context.getTokenCountAsync(userPromptText);\r\n            totalPromptTokens = systemTokens + userTokens;\r\n        } catch (_error) {\r\n            if (DEBUG_LOGGING) console.log('[NT-ST-Call] Token count failed, estimating:', _error.message);\r\n            // Fallback to character-based estimation\r\n            systemTokens = Math.ceil(systemPrompt.length / 4);\r\n            const userPromptText = prompt + (prefill ? '\\n' + prefill : '');\r\n            userTokens = Math.ceil(userPromptText.length / 4);\r\n            totalPromptTokens = systemTokens + userTokens;\r\n        }\r\n\r\n        // Calculate response length with 20% buffer\r\n        const bufferTokens = Math.ceil(maxContext * 0.20); // 20% buffer\r\n        const calculatedResponseLength = Math.max(1024, maxContext - totalPromptTokens - bufferTokens);\r\n\r\n        // Log context usage tracking\r\n        console.log('[NT-CONTEXT] ========== Context Usage Tracking ==========');\r\n        console.log('[NT-CONTEXT] maxContext:', maxContext);\r\n        console.log('[NT-CONTEXT] systemTokens:', systemTokens);\r\n        console.log('[NT-CONTEXT] userTokens:', userTokens);\r\n        console.log('[NT-CONTEXT] totalPromptTokens:', totalPromptTokens);\r\n        console.log('[NT-CONTEXT] bufferTokens (20%):', bufferTokens);\r\n        console.log('[NT-CONTEXT] calculatedResponseLength:', calculatedResponseLength);\r\n        console.log('[NT-CONTEXT] contextUtilization:', ((totalPromptTokens / maxContext) * 100).toFixed(1) + '%');\r\n\r\n        const maxTokens = calculatedResponseLength;\r\n        debug.log();\r\n\r\n        // Retry logic: attempt up to 2 times with a short delay\r\n        const MAX_RETRIES = 2;\r\n        const RETRY_DELAY_MS = 2000;\r\n        let lastError = null;\r\n\r\n        for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {\r\n            try {\r\n                if (DEBUG_LOGGING) {\r\n                    console.log(`[NT-ST-Call] Attempt ${attempt}/${MAX_RETRIES}`);\r\n                    console.log('[NT-ST-Call]  DEBUG: Token allocation details:');\r\n                    console.log(`[NT-ST-Call] - maxContext: ${maxContext}`);\r\n                    console.log(`[NT-ST-Call] - systemTokens: ${systemTokens}`);\r\n                    console.log(`[NT-ST-Call] - userTokens: ${userTokens}`);\r\n                    console.log(`[NT-ST-Call] - totalPromptTokens: ${totalPromptTokens}`);\r\n                    console.log(`[NT-ST-Call] - calculated maxTokens: ${maxTokens}`);\r\n                    console.log(`[NT-ST-Call] - buffer used: ${bufferTokens} tokens (20%)`);\r\n                    console.log(`[NT-ST-Call] - actual responseLength param: ${maxTokens}`);\r\n                    console.log('[NT-ST-Call] Calling generateRaw with params:', {\r\n                        temperature: GENERATION_TEMPERATURE,\r\n                        top_p: GENERATION_TOP_P,\r\n                        top_k: GENERATION_TOP_K,\r\n                        rep_pen: GENERATION_REP_PEN,\r\n                        responseLength: maxTokens,\r\n                    });\r\n                }\r\n\r\n                // Add /nothink suffix to instruct model to avoid thinking contamination\r\n                // Escalate suffix on retries after contamination detection\r\n                let promptWithSuffix = prompt + '\\n\\n/nothink';\r\n                if (attempt > 1 && lastError?.code === 'THINKING_CONTAMINATION') {\r\n                    // Use stronger prompt on retry after contamination\r\n                    promptWithSuffix = prompt + '\\n\\n/nothink\\n\\nCRITICAL: OUTPUT ONLY VALID JSON - NO THINKING OR COMMENTARY';\r\n                    console.log('[NT-ST-Call] Using escalated anti-thinking prompt on retry', attempt);\r\n                }\r\n\r\n                const result = await context.generateRaw({\r\n                    systemPrompt,\r\n                    prompt: promptWithSuffix,\r\n                    prefill,\r\n                    temperature: GENERATION_TEMPERATURE,\r\n                    top_p: GENERATION_TOP_P,\r\n                    top_k: GENERATION_TOP_K,\r\n                    rep_pen: GENERATION_REP_PEN,\r\n                    responseLength: maxTokens, // Use all available tokens for response (no 2048 limit)\r\n                });\r\n\r\n                if (DEBUG_LOGGING) {\r\n                    console.log('[NT-ST-Call] ========== RAW API RESPONSE START ==========');\r\n                    console.log('[NT-ST-Call] Response type:', typeof result);\r\n                    console.log(JSON.stringify(result, null, 2));\r\n                    console.log('[NT-ST-Call] ========== RAW API RESPONSE END ==========');\r\n\r\n                    console.log('[NT-ST-Call] Raw result type:', typeof result);\r\n                    console.log('[NT-ST-Call] Raw result object:', JSON.stringify(result).substring(0, 500));\r\n                }\r\n\r\n                // Extract text from chat completion response\r\n                // Chat format: { choices: [{ message: { content: \"...\" } }] }\r\n                // Text format: { choices: [{ text: \"...\" }] }\r\n                let resultText = result;\r\n\r\n                if (typeof result === 'object' && result.choices && Array.isArray(result.choices)) {\r\n                    // Try chat completion format first\r\n                    if (result.choices[0]?.message?.content) {\r\n                        if (DEBUG_LOGGING) console.log('[NT-ST-Call] Detected chat completion format, extracting from choices[0].message.content');\r\n                        resultText = result.choices[0].message.content;\r\n                    }\r\n                    // Fall back to text completion format\r\n                    else if (result.choices[0]?.text) {\r\n                        if (DEBUG_LOGGING) console.log('[NT-ST-Call] Detected text completion format, extracting from choices[0].text');\r\n                        resultText = result.choices[0].text;\r\n                    }\r\n                }\r\n\r\n                if (DEBUG_LOGGING) {\r\n                    console.log('[NT-ST-Call] Extracted text type:', typeof resultText);\r\n                    console.log('[NT-ST-Call] Extracted text length:', resultText ? resultText.length : 'null');\r\n                    if (resultText && typeof resultText === 'string') {\r\n                        console.log('[NT-ST-Call] Extracted text preview:', resultText.substring(0, 300));\r\n                    }\r\n                    console.log('[NT-ST-Call] ========== EXTRACTED TEXT START ==========');\r\n                    console.log(resultText);\r\n                    console.log('[NT-ST-Call] ========== EXTRACTED TEXT END ==========');\r\n                }\r\n\r\n                // Log raw response for debugging if debug mode enabled\r\n                const debugMode = await get_settings('debugMode');\r\n                if (debugMode) {\r\n                    logRawResponse(resultText, 'SillyTavern');\r\n                }\r\n\r\n                // Log actual response token usage\r\n                try {\r\n                    const responseTokens = await context.getTokenCountAsync(resultText);\r\n                    console.log('[NT-CONTEXT] actualResponseTokens:', responseTokens);\r\n                    console.log('[NT-CONTEXT] responseEfficiency:', ((responseTokens / calculatedResponseLength) * 100).toFixed(1) + '%');\r\n                    console.log('[NT-CONTEXT] totalTokensUsed:', totalPromptTokens + responseTokens);\r\n                    console.log('[NT-CONTEXT] totalContextUsed:', (((totalPromptTokens + responseTokens) / maxContext) * 100).toFixed(1) + '%');\r\n                } catch (_error) {\r\n                    console.log('[NT-CONTEXT] responseTokenCountError:', _error.message);\r\n                    const estimatedTokens = Math.ceil(resultText.length / 4);\r\n                    console.log('[NT-CONTEXT] estimatedResponseTokens:', estimatedTokens);\r\n                }\r\n                console.log('[NT-CONTEXT] ===============================================');\r\n\r\n                debug.log();\r\n\r\n                // The result should be a string\r\n                if (!resultText || typeof resultText !== 'string') {\r\n                    throw new NameTrackerError('Empty or invalid response from SillyTavern LLM');\r\n                }\r\n\r\n                // Check for thinking contamination BEFORE attempting parse\r\n                const isContaminated = detectThinkingContamination(resultText, calculatedResponseLength);\r\n                if (isContaminated) {\r\n                    const error = new NameTrackerError('LLM response contains thinking contamination - rejecting and will retry');\r\n                    error.code = 'THINKING_CONTAMINATION';\r\n                    throw error;\r\n                }\r\n\r\n                // Pre-validation: Check if response follows JSON format requirements\r\n                console.log('[NT-ST-Call]  Pre-validation checks...');\r\n\r\n                const trimmedResult = resultText.trim();\r\n\r\n                // Check for common format violations before parsing\r\n                if (!trimmedResult.startsWith('{')) {\r\n                    console.warn('[NT-ST-Call]  Response does not start with { - attempting extraction');\r\n                    // Try to find JSON in the response\r\n                    const jsonMatch = trimmedResult.match(/\\{[\\s\\S]*\\}/);\r\n                    if (jsonMatch) {\r\n                        resultText = jsonMatch[0];\r\n                        console.log('[NT-ST-Call]  Extracted JSON from response');\r\n                    } else {\r\n                        console.error('[NT-ST-Call]  No valid JSON found in response');\r\n                        throw new NameTrackerError('LLM response does not contain valid JSON format');\r\n                    }\r\n                }\r\n\r\n                // Check for orphaned strings (common parsing issue)\r\n                const orphanedStringPattern = /\"[^\"]+\",\\s*\"[^\"]*[a-zA-Z][^\"]*\",\\s*\"[a-zA-Z_]/;\r\n                if (orphanedStringPattern.test(resultText)) {\r\n                    console.warn('[NT-ST-Call]  Detected potential orphaned strings in response');\r\n                    console.log('[NT-ST-Call] Response will need JSON repair during parsing');\r\n                }\r\n\r\n                // If we used a prefill, prepend it to complete the JSON\r\n                if (prefill) {\r\n                    if (DEBUG_LOGGING) console.log('[NT-ST-Call] Prepending prefill to complete JSON:', prefill);\r\n                    resultText = prefill + resultText;\r\n\r\n                    // If the prefill opened an object but response doesn't close it, add closing brace\r\n                    // Count braces to see if balanced\r\n                    const openBraces = (resultText.match(/{/g) || []).length;\r\n                    const closeBraces = (resultText.match(/}/g) || []).length;\r\n\r\n                    if (openBraces > closeBraces) {\r\n                        const missing = openBraces - closeBraces;\r\n                        if (DEBUG_LOGGING) console.log(`[NT-ST-Call] Adding ${missing} closing brace(s) to complete JSON`);\r\n                        resultText += '}'.repeat(missing);\r\n                    }\r\n\r\n                    if (DEBUG_LOGGING) console.log('[NT-ST-Call] Combined text preview:', resultText.substring(0, 300));\r\n                }\r\n\r\n                const parsed = await parseJSONResponse(resultText);\r\n                console.log('[NT-ST-Call] parseJSONResponse returned type:', typeof parsed);\r\n                console.log('[NT-ST-Call] parseJSONResponse returned value:', parsed);\r\n                console.log('[NT-ST-Call] parsed.characters exists?:', parsed && 'characters' in parsed);\r\n                console.log('[NT-ST-Call] parsed.characters type:', typeof parsed?.characters);\r\n                console.log('[NT-ST-Call] parsed.characters is Array?:', Array.isArray(parsed?.characters));\r\n                const parsedCount = Array.isArray(parsed?.characters) ? parsed.characters.length : 0;\r\n                console.log('[NT-ST-Call]  Successfully parsed on attempt', attempt, 'characters:', parsedCount);\r\n                console.log('[NT-ST-Call] Parsed result:', JSON.stringify(parsed).substring(0, 300));\r\n                return parsed;\r\n\r\n            } catch (error) {\r\n                lastError = error;\r\n                console.error(`[NT-ST-Call]  Attempt ${attempt}/${MAX_RETRIES} failed:`, error.message);\r\n                console.error('[NT-ST-Call] Error details:', error);\r\n\r\n                if (attempt < MAX_RETRIES) {\r\n                    const waitStart = Date.now();\r\n                    const waitSeconds = Math.round(RETRY_DELAY_MS / 100) / 10; // one decimal place\r\n                    console.log(`[NT-ST-Call] Waiting ${RETRY_DELAY_MS}ms (~${waitSeconds}s) before retry...`);\r\n                    await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS));\r\n                    const waited = Date.now() - waitStart;\r\n                    console.log(`[NT-ST-Call] Waited ${waited}ms before next attempt`);\r\n                }\r\n            }\r\n        }\r\n\r\n        // All retries failed\r\n        if (interactive) {\r\n            const shouldContinue = confirm(\r\n                `Failed to parse LLM response after ${MAX_RETRIES} attempts.\\n\\n` +\r\n                `Last error: ${lastError.message}\\n\\n` +\r\n                'Check console for detailed logs. Continue processing remaining batches?',\r\n            );\r\n\r\n            if (!shouldContinue) {\r\n                throw new NameTrackerError('User aborted after parse failures');\r\n            }\r\n            // Return empty result if user wants to continue\r\n            return { characters: [] };\r\n        }\r\n\r\n        // Non-interactive mode: throw to allow outer logic to retry/split\r\n        const err = new NameTrackerError(`Failed to parse LLM response as JSON after ${MAX_RETRIES} attempts (non-interactive mode)`);\r\n        err.code = 'JSON_PARSE_FAILED';\r\n        err.lastError = lastError;\r\n        throw err;\r\n    });\r\n}\r\n\r\n/**\r\n * Call Ollama API with optimized parameters for JSON extraction\r\n * Uses low temperature and focused sampling for deterministic, structured output\r\n * @param {string} prompt - The complete prompt to send\r\n * @returns {Promise<Object>} Parsed JSON response\r\n */\r\nexport async function callOllama(prompt) {\r\n    return withErrorBoundary('callOllama', async () => {\r\n        const llmConfig = await getLLMConfig();\r\n\r\n        if (!llmConfig.ollamaModel) {\r\n            throw new NameTrackerError('No Ollama model selected');\r\n        }\r\n\r\n        debug.log();\r\n\r\n        // Calculate response tokens: use generous allocation within available context\r\n        const maxContext = await getOllamaModelContext(llmConfig.ollamaModel);\r\n        const promptTokens = Math.ceil(prompt.length / 4); // Rough estimate\r\n        const maxTokens = Math.max(8192, maxContext - promptTokens - 1000); // Generous response allocation with safety buffer\r\n        debug.log();\r\n\r\n        // Add /nothink suffix to instruct model to avoid thinking contamination\r\n        const promptWithSuffix = prompt + '\\n\\n/nothink';\r\n\r\n        const response = await fetch(`${llmConfig.ollamaEndpoint}/api/generate`, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify({\r\n                model: llmConfig.ollamaModel,\r\n                prompt: promptWithSuffix,\r\n                stream: false,\r\n                format: 'json',\r\n                // Ollama-specific generation parameters for structured output\r\n                // Using same conservative settings as SillyTavern for consistency\r\n                options: {\r\n                    temperature: GENERATION_TEMPERATURE,      // Very low for deterministic output\r\n                    top_p: GENERATION_TOP_P,                  // Focused sampling\r\n                    top_k: GENERATION_TOP_K,                  // Standard focused sampling\r\n                    repeat_penalty: GENERATION_REP_PEN,       // Slight repetition penalty\r\n                    num_predict: maxTokens,  // Dynamic: generous allocation using remaining context after prompt\r\n                },\r\n            }),\r\n        });\r\n\r\n        if (!response.ok) {\r\n            throw new NameTrackerError(`Ollama API error: ${response.statusText}`);\r\n        }\r\n\r\n        const data = await response.json();\r\n        debug.log();\r\n        debug.log();\r\n\r\n        // Check for thinking contamination before parsing\r\n        const responseText = data.response || '';\r\n        const estimatedTokens = Math.ceil(responseText.length / 4);\r\n        const isContaminated = detectThinkingContamination(responseText, estimatedTokens);\r\n\r\n        if (isContaminated) {\r\n            console.warn('[NT-Ollama] Response contaminated with thinking - attempting parse anyway (Ollama has no retry)');\r\n            // Note: Ollama doesn't have built-in retry like SillyTavern, so we proceed with repair\r\n        }\r\n\r\n        return await parseJSONResponse(data.response);\r\n    });\r\n}\r\n\r\n/**\r\n * Detect thinking contamination in LLM response (binary detection)\r\n * @param {string} text - LLM response text\r\n * @param {number} budgetTokens - Expected response budget in tokens\r\n * @returns {boolean} True if thinking contamination detected\r\n */\r\nfunction detectThinkingContamination(text, budgetTokens = 5000) {\r\n    console.log('[NT-Contamination] Checking for thinking contamination...');\r\n\r\n    // Check 1: Response length exceeds budget by 2x\r\n    const estimatedTokens = Math.ceil(text.length / 4);\r\n    if (estimatedTokens > budgetTokens * 2.0) {\r\n        console.log('[NT-Contamination]  DETECTED: Response too long');\r\n        console.log('[NT-Contamination] Estimated:', estimatedTokens, 'Budget:', budgetTokens, 'Ratio:', (estimatedTokens / budgetTokens).toFixed(2));\r\n        return true;\r\n    }\r\n\r\n    // Check 2: Common thinking phrases\r\n    const thinkingPhrases = [\r\n        /however[,\\s]/i,\r\n        /let me (think|consider|analyze|reconsider)/i,\r\n        /upon (reflection|analysis|consideration)/i,\r\n        /it (seems|appears) that/i,\r\n        /looking at (this|these|the)/i,\r\n        /based on (this|these|the) (message|conversation|text)/i,\r\n        /from (this|these|the) (message|conversation|text)/i,\r\n        /these messages (reveal|show|indicate|suggest)/i,\r\n        /this (message|conversation) (reveal|show|indicate|suggest)/i,\r\n        /i (notice|observe|see) that/i,\r\n        /we can (see|infer|deduce|conclude)/i,\r\n        /this (indicates|suggests|shows)/i,\r\n    ];\r\n\r\n    for (const pattern of thinkingPhrases) {\r\n        if (pattern.test(text)) {\r\n            console.log('[NT-Contamination]  DETECTED: Thinking phrase found:', pattern.source);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // Check 3: Unquoted prose patterns (text outside JSON structure)\r\n    // Look for sentence-like patterns outside quotes\r\n    const jsonStripped = text.replace(/\"([^\"]*)\"/g, '\"\"'); // Remove all string contents\r\n    const sentencePattern = /[A-Z][a-z]+\\s+[a-z]+\\s+[a-z]+/; // \"Word word word\" pattern\r\n    if (sentencePattern.test(jsonStripped)) {\r\n        console.log('[NT-Contamination]  DETECTED: Unquoted prose pattern');\r\n        return true;\r\n    }\r\n\r\n    // Check 4: Non-schema fields (common thinking artifacts)\r\n    const nonSchemaFields = [\r\n        /\"thinking\":/i,\r\n        /\"thoughts\":/i,\r\n        /\"analysis\":/i,\r\n        /\"reasoning\":/i,\r\n        /\"notes\":/i,\r\n        /\"commentary\":/i,\r\n        /\"observations\":/i,\r\n    ];\r\n\r\n    for (const pattern of nonSchemaFields) {\r\n        if (pattern.test(text)) {\r\n            console.log('[NT-Contamination]  DETECTED: Non-schema field:', pattern.source);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // Check 5: XML-style thinking tags\r\n    if (/<think>/i.test(text) || /<thinking>/i.test(text) || /<\\/think>/i.test(text)) {\r\n        console.log('[NT-Contamination]  DETECTED: XML thinking tags');\r\n        return true;\r\n    }\r\n\r\n    console.log('[NT-Contamination]  No contamination detected');\r\n    return false;\r\n}\r\n\r\n/**\r\n * Repair common JSON syntax errors in LLM responses\r\n * @param {string} text - Potentially malformed JSON text\r\n * @returns {string} Repaired JSON text\r\n */\r\nfunction repairJSON(text) {\r\n    console.log('[NT-Repair] Starting JSON repair...');\r\n    let repaired = text;\r\n\r\n    // 0. Remove XML thinking tags completely (critical fix for recent failures)\r\n    repaired = repaired.replace(/<\\/think>/gi, '');\r\n    repaired = repaired.replace(/<think[^>]*>/gi, '');\r\n    repaired = repaired.replace(/<thinking[^>]*>[\\s\\S]*?<\\/thinking>/gi, '');\r\n    repaired = repaired.replace(/<think>[\\s\\S]*?<\\/think>/gi, '');\r\n    if (repaired !== text) {\r\n        console.log('[NT-Repair]  Removed XML thinking tags');\r\n    }\r\n\r\n    // 1. Fix major structural issue: orphaned string values without property names\r\n    // This is the most common issue causing parse failures\r\n    // Pattern: \"property\": \"value\", \"orphaned description text\", \"nextProperty\":\r\n    // Step 1: Find and fix orphaned strings that should be in physical/personality fields\r\n    repaired = repaired.replace(/\"name\":\\s*\"([^\"]*)\",\\s*\"([^\"]*(?:breast|body|hair|skin|face|eyes|tall|short|curvy|slim|muscular|describe|appear|look|physic)[^\"]*)\",\\s*\"([a-zA-Z_][a-zA-Z0-9_]*)\":/gi, (match, name, orphanedDesc, nextProp) => {\r\n        console.log(`[NT-Repair]  Fixing orphaned physical description for ${name}: ${orphanedDesc.substring(0, 50)}...`);\r\n        return `\"name\": \"${name}\", \"physical\": \"${orphanedDesc}\", \"${nextProp}\":`;\r\n    });\r\n\r\n    // Step 2: Fix personality/mental descriptions\r\n    repaired = repaired.replace(/\"name\":\\s*\"([^\"]*)\",\\s*\"([^\"]*(?:personality|character|behavior|emotion|feel|think|mental|psych|mood)[^\"]*)\",\\s*\"([a-zA-Z_][a-zA-Z0-9_]*)\":/gi, (match, name, orphanedDesc, nextProp) => {\r\n        console.log(`[NT-Repair]  Fixing orphaned personality description for ${name}: ${orphanedDesc.substring(0, 50)}...`);\r\n        return `\"name\": \"${name}\", \"personality\": \"${orphanedDesc}\", \"${nextProp}\":`;\r\n    });\r\n\r\n    // Step 3: Generic fallback - assign any remaining orphaned strings to physical field\r\n    repaired = repaired.replace(/\"name\":\\s*\"([^\"]*)\",\\s*\"([^\"]{20,})\",\\s*\"([a-zA-Z_][a-zA-Z0-9_]*)\":/g, (match, name, orphanedDesc, nextProp) => {\r\n        console.log(`[NT-Repair]  Fixing generic orphaned description for ${name}: ${orphanedDesc.substring(0, 50)}...`);\r\n        return `\"name\": \"${name}\", \"physical\": \"${orphanedDesc}\", \"${nextProp}\":`;\r\n    });\r\n\r\n    // 2. Fix orphaned strings anywhere in character objects (not just after name)\r\n    // Pattern: }: value, \"nextProp\": (missing property name before value)\r\n    repaired = repaired.replace(/},\\s*\"([^\"]{15,})\",\\s*\"([a-zA-Z_][a-zA-Z0-9_]*)\":/g, (match, orphanedDesc, nextProp) => {\r\n        console.log(`[NT-Repair]  Fixing orphaned string before ${nextProp}: ${orphanedDesc.substring(0, 50)}...`);\r\n        return `}, \"physical\": \"${orphanedDesc}\", \"${nextProp}\":`;\r\n    });\r\n\r\n    // 3. Fix missing commas between object properties (line breaks without commas)\r\n    repaired = repaired.replace(/([}\\]])\\s*\\n\\s*(\")/g, '$1,\\n    $2');\r\n\r\n    // 4. Fix control characters (newlines, tabs, etc. in strings) - ENHANCED\r\n    repaired = repaired.replace(/\"([^\"]*[\\n\\r\\t\\f\\b\\v][^\"]*)\"/g, (match, content) => {\r\n        const cleaned = content\r\n            .replace(/\\n/g, ' ')     // newlines -> space\r\n            .replace(/\\r/g, '')      // carriage returns -> remove\r\n            .replace(/\\t/g, ' ')     // tabs -> space\r\n            .replace(/\\f/g, ' ')     // form feeds -> space\r\n            .replace(/\\b/g, '')      // backspace -> remove\r\n            .replace(/\\v/g, ' ')     // vertical tabs -> space\r\n            .replace(/\\s+/g, ' ')    // collapse multiple spaces\r\n            .trim();                 // remove leading/trailing space\r\n        console.log(`[NT-Repair]  Cleaned control characters: ${content.length} -> ${cleaned.length} chars`);\r\n        return `\"${cleaned}\"`;\r\n    });\r\n\r\n    // 5. Remove error messages that get mixed into JSON\r\n    repaired = repaired.replace(/,\\s*\"[^\"]*I'm sorry for[^\"]*\"/gi, '');\r\n    repaired = repaired.replace(/,\\s*\"[^\"]*encountered a problem[^\"]*\"/gi, '');\r\n    repaired = repaired.replace(/,\\s*\"[^\"]*Please try again[^\"]*\"/gi, '');\r\n    repaired = repaired.replace(/\"[^\"]*I'm sorry[^\"]*\"\\s*,/gi, '');\r\n\r\n    // Remove property names that are error messages (missing opening quote)\r\n    repaired = repaired.replace(/,\\s*[A-Za-z]+\"\\s*:\\s*\"[^\"]*I'm sorry[^\"]*/gi, '');\r\n\r\n    // 6. Fix missing quotes around property names (critical fix)\r\n    // Pattern: ,Affected\": or }Affected\": (missing opening quote)\r\n    repaired = repaired.replace(/([,{]\\s*)([A-Za-z_][A-Za-z0-9_]*)(\"):/g, '$1\"$2$3:');\r\n\r\n    // 7. Fix trailing commas before closing brackets/braces\r\n    repaired = repaired.replace(/,(\\s*[}\\]])/g, '$1');\r\n\r\n    // 6. Fix missing colons after property names\r\n    repaired = repaired.replace(/\"([^\"]+)\"\\s+(?=[\"'{[])/g, '\"$1\": ');\r\n\r\n    // 7. Fix double commas introduced by repairs\r\n    repaired = repaired.replace(/,,+/g, ',');\r\n\r\n    // 8. Fix property names with spaces\r\n    repaired = repaired.replace(/\"([^\"]*\\s[^\"]*)\"\\s*:/g, (match, propName) => {\r\n        const cleanProp = propName.replace(/\\s+/g, '');\r\n        return `\"${cleanProp}\":`;\r\n    });\r\n\r\n    // 9. Final validation: ensure all character objects have required fields\r\n    repaired = repaired.replace(/\"name\":\\s*\"([^\"]*)\"(?!\\s*,\\s*\"(?:aliases|physical|personality))/g, (match, name) => {\r\n        console.log(`[NT-Repair]  Adding missing fields for character: ${name}`);\r\n        return `\"name\": \"${name}\", \"aliases\": [], \"physical\": \"\", \"personality\": \"\"`;\r\n    });\r\n\r\n    console.log('[NT-Repair] Applied repairs, length change:', repaired.length - text.length);\r\n\r\n    return repaired;\r\n}\r\n\r\n/**\r\n * Parse JSON response from LLM, handling various formats\r\n * @param {string} text - Raw text response from LLM\r\n * @returns {Object} Parsed JSON object\r\n */\r\nexport function parseJSONResponse(text) {\r\n    return withErrorBoundary('parseJSONResponse', async () => {\r\n        // Create debug session if debug mode is enabled\r\n        const debugMode = await get_settings('debugMode');\r\n        const session = debugMode ? createParsingSession() : null;\r\n\r\n        if (session) {\r\n            session.logStart('parseJSONResponse', text);\r\n        }\r\n\r\n        console.log('[NT-Parse] ========== PARSE START ==========');\r\n        console.log('[NT-Parse] Input type:', typeof text);\r\n        console.log('[NT-Parse] Input is null?:', text === null);\r\n        console.log('[NT-Parse] Input is undefined?:', text === undefined);\r\n\r\n        if (typeof text === 'object' && text !== null) {\r\n            console.log('[NT-Parse] Input is an OBJECT (not string). Keys:', Object.keys(text));\r\n            console.log('[NT-Parse] Full object:', JSON.stringify(text).substring(0, 500));\r\n\r\n            // If it's already an object with characters, return it\r\n            if (text.characters && Array.isArray(text.characters)) {\r\n                console.log('[NT-Parse] Object already has characters array, returning as-is');\r\n                return text;\r\n            }\r\n        }\r\n\r\n        console.log('[NT-Parse] Input length:', text ? text.length : 'null');\r\n        if (text && typeof text === 'string') {\r\n            console.log('[NT-Parse] First 300 chars:', text.substring(0, 300));\r\n            console.log('[NT-Parse] Last 100 chars:', text.substring(Math.max(0, text.length - 100)));\r\n        }\r\n\r\n        if (!text || typeof text !== 'string') {\r\n            console.error('[NT-Parse]  INVALID: Response is not a string:', typeof text);\r\n            console.error('[NT-Parse]  Response value:', text);\r\n            throw new NameTrackerError('LLM returned empty or invalid response');\r\n        }\r\n\r\n        // CRITICAL: Unescape JSON-escaped string from SillyTavern\r\n        // The API returns escaped JSON string that needs to be unescaped first\r\n        try {\r\n            // If text looks like a JSON-escaped string, unescape it\r\n            if (text.includes('\\\\n') || text.includes('\\\\\"')) {\r\n                console.log('[NT-Parse]  Unescaping JSON-encoded string from SillyTavern');\r\n                text = JSON.parse('\"' + text.replace(/\"/g, '\\\\\"') + '\"');\r\n                console.log('[NT-Parse]  Successfully unescaped response');\r\n            }\r\n        // eslint-disable-next-line no-unused-vars\r\n        } catch (unescapeError) {\r\n            console.log('[NT-Parse]  Could not unescape response, proceeding with raw text');\r\n        }\r\n\r\n        // Remove any leading/trailing whitespace\r\n        const beforeTrim = text;\r\n        text = text.trim();\r\n        console.log('[NT-Parse] After trim, length:', text.length);\r\n\r\n        if (session) {\r\n            session.logTransform('Trim whitespace', beforeTrim, text);\r\n        }\r\n\r\n        if (text.length === 0) {\r\n            console.error('[NT-Parse]  Text is empty after trim');\r\n            if (session) session.logEnd(false, new Error('Empty after trim'), text);\r\n            throw new NameTrackerError('LLM returned empty response');\r\n        }\r\n\r\n        // Extract JSON from markdown code blocks ONLY if response starts with markdown\r\n        // This prevents false positives from backticks embedded in JSON string values\r\n        const startsWithMarkdown = /^```(?:json)?[\\s\\n]/.test(text);\r\n\r\n        if (startsWithMarkdown) {\r\n            console.log('[NT-Parse]  Response starts with markdown code block, extracting JSON');\r\n            const beforeExtraction = text;\r\n\r\n            // Extract content between first ``` and last ```\r\n            const codeBlockMatch = text.match(/^```(?:json)?[\\s\\n]+([\\s\\S]*?)```\\s*$/);\r\n            if (codeBlockMatch && codeBlockMatch[1]) {\r\n                text = codeBlockMatch[1].trim();\r\n                console.log('[NT-Parse]  After markdown extraction, length:', text.length);\r\n\r\n                if (session) {\r\n                    logRegexExtraction(beforeExtraction, '/^```(?:json)?[\\\\s\\\\n]+([\\\\s\\\\S]*?)```\\\\s*$/', text);\r\n                    session.logTransform('Extract markdown code block', beforeExtraction, text, {\r\n                        regex: '/^```(?:json)?[\\\\s\\\\n]+([\\\\s\\\\S]*?)```\\\\s*$/',\r\n                    });\r\n                }\r\n            } else {\r\n                console.warn('[NT-Parse]  Starts with ``` but no matching closing ```, removing markdown markers');\r\n                // Remove opening and closing markers\r\n                text = text.replace(/^```(?:json)?[\\s\\n]+/, '').replace(/```\\s*$/, '');\r\n                console.log('[NT-Parse]  Removed markdown markers, length:', text.length);\r\n\r\n                if (session) {\r\n                    session.logTransform('Remove malformed markdown', beforeExtraction, text);\r\n                }\r\n            }\r\n        } else if (text.includes('```')) {\r\n            // Backticks present but NOT at start - likely embedded in JSON strings\r\n            console.log('[NT-Parse]  Found backticks in response but not at start - likely embedded in JSON strings, not extracting');\r\n            console.log('[NT-Parse] First 50 chars:', text.substring(0, 50));\r\n        }\r\n\r\n        // Remove any remaining XML/HTML tags that may interfere\r\n        if (text.includes('<') || text.includes('>')) {\r\n            const beforeTagRemoval = text;\r\n            const originalLength = text.length;\r\n            text = text.replace(/<[^>]*>/g, '');\r\n            console.log(`[NT-Parse]  Removed XML/HTML tags, length change: ${originalLength} -> ${text.length}`);\r\n\r\n            if (session) {\r\n                session.logTransform('Remove XML/HTML tags', beforeTagRemoval, text);\r\n            }\r\n        }\r\n\r\n        // Check if response contains obvious error messages\r\n        if (text.includes('I\\'m sorry') || text.includes('encountered a problem') || text.includes('Please try again')) {\r\n            console.error(`[NT-Parse]  Response contains error message: \"${text.substring(0, 200)}\"`);\r\n            if (session) session.logEnd(false, new Error('LLM error message'), text);\r\n            throw new Error('LLM generated an error response instead of JSON. Try adjusting your request.');\r\n        }\r\n\r\n        // Check if response is completely non-JSON (like pure XML tags or text)\r\n        if (text.length < 20 || (!text.includes('{') && !text.includes('['))) {\r\n            console.error(`[NT-Parse]  Response appears to be non-JSON content: \"${text}\"`);\r\n            if (session) session.logEnd(false, new Error('Non-JSON response'), text);\r\n            throw new Error('LLM generated non-JSON response. Response may be censored or malformed.');\r\n        }\r\n\r\n        // Try to find JSON object in the text (look for first { to last })\r\n        const firstBrace = text.indexOf('{');\r\n        const lastBrace = text.lastIndexOf('}');\r\n\r\n        console.log('[NT-Parse] Brace search: first={' + firstBrace + ', last=' + lastBrace + '}');\r\n\r\n        if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {\r\n            const beforeText = text.substring(0, firstBrace);\r\n            const jsonText = text.substring(firstBrace, lastBrace + 1);\r\n            const afterText = text.substring(lastBrace + 1);\r\n\r\n            console.log('[NT-Parse] Text before JSON:', beforeText.substring(0, 100));\r\n            console.log('[NT-Parse] Extracted JSON length:', jsonText.length);\r\n            console.log('[NT-Parse] Text after JSON:', afterText.substring(0, 100));\r\n\r\n            text = jsonText;\r\n        }\r\n\r\n        // Remove common prefixes that LLMs add\r\n        text = text.replace(/^(?:Here's the analysis:|Here is the JSON:|Result:|Output:)\\s*/i, '');\r\n\r\n        // Clean up common formatting issues\r\n        text = text.trim();\r\n\r\n        // Apply JSON repair for common LLM syntax errors\r\n        text = repairJSON(text);\r\n\r\n        console.log('[NT-Parse] Before JSON.parse, length:', text.length);\r\n        console.log('[NT-Parse] First 200 chars:', text.substring(0, 200));\r\n        console.log('[NT-Parse] Last 100 chars:', text.substring(Math.max(0, text.length - 100)));\r\n\r\n        try {\r\n            console.log('[NT-Parse] Attempting JSON.parse...');\r\n            const parsed = JSON.parse(text);\r\n\r\n            console.log('[NT-Parse]  Successfully parsed JSON');\r\n            console.log('[NT-Parse] Parsed type:', typeof parsed);\r\n            console.log('[NT-Parse] Parsed keys:', Object.keys(parsed));\r\n            console.log('[NT-Parse] Full parsed object:', JSON.stringify(parsed).substring(0, 500));\r\n\r\n            // Validate structure\r\n            if (!parsed.characters) {\r\n                console.warn('[NT-Parse]   parsed.characters is undefined or null');\r\n                console.warn('[NT-Parse] Available keys in object:', Object.keys(parsed));\r\n            } else if (!Array.isArray(parsed.characters)) {\r\n                console.warn('[NT-Parse]   parsed.characters exists but is NOT an array. Type:', typeof parsed.characters);\r\n                console.warn('[NT-Parse] Value:', parsed.characters);\r\n            }\r\n\r\n            if (!parsed.characters || !Array.isArray(parsed.characters)) {\r\n                console.warn('[NT-Parse]  Response missing characters array, returning empty');\r\n                console.warn('[NT-Parse] Full parsed object:', parsed);\r\n                return { characters: [] };\r\n            }\r\n\r\n            console.log('[NT-Parse]  Valid response with', parsed.characters.length, 'characters');\r\n            console.log('[NT-Parse] ========== PARSE END (SUCCESS) ==========');\r\n\r\n            if (session) {\r\n                session.logEnd(true, parsed, text);\r\n            }\r\n\r\n            return parsed;\r\n        } catch (error) {\r\n            console.error('[NT-Parse]  JSON.parse failed:', error.message);\r\n            console.error('[NT-Parse]  Error at position:', error.name);\r\n            console.log('[NT-Parse] Text being parsed (first 500 chars):', text.substring(0, 500));\r\n            console.log('[NT-Parse] Text being parsed (last 200 chars):', text.substring(Math.max(0, text.length - 200)));\r\n\r\n            // Additional targeted repairs for specific common errors\r\n            if (error.message.includes('Expected \\':\\'') || error.message.includes('after property name')) {\r\n                console.log('[NT-Parse] Attempting targeted repair for missing property names...');\r\n\r\n                let targetedRepair = text;\r\n\r\n                // Specific fix for pattern: \"name\": \"value\", \"orphaned description\", \"nextProp\":\r\n                // This is the exact pattern causing most failures\r\n                targetedRepair = targetedRepair.replace(\r\n                    /\"name\":\\s*\"([^\"]*)\",\\s*\"([^\"]+)\",\\s*\"([a-zA-Z_][a-zA-Z0-9_]*)\":\\s*/g,\r\n                    (match, name, orphanedText, nextProp) => {\r\n                        console.log(`[NT-Parse]  Targeted repair: assigning \"${orphanedText.substring(0, 30)}...\" to physical for ${name}`);\r\n                        return `\"name\": \"${name}\", \"physical\": \"${orphanedText}\", \"${nextProp}\": `;\r\n                    },\r\n                );\r\n\r\n                // Try parsing again with targeted repair\r\n                try {\r\n                    const repairedParsed = JSON.parse(targetedRepair);\r\n                    console.log('[NT-Parse]  Targeted repair successful!');\r\n                    console.log('[NT-Parse] ========== PARSE END (TARGETED REPAIR) ==========');\r\n                    return repairedParsed;\r\n                } catch (repairError) {\r\n                    console.error('[NT-Parse]  Targeted repair also failed:', repairError.message);\r\n                }\r\n            }\r\n\r\n            // Check if response was truncated (common issue with long responses)\r\n            if (text.includes('\"characters\"') && !text.trim().endsWith('}')) {\r\n                console.log('[NT-Parse] Detected truncated response, attempting recovery...');\r\n\r\n                // Try to salvage partial data by attempting to close the JSON\r\n                let salvaged = text;\r\n\r\n                // Count open vs closed braces to determine how many we need\r\n                const openBraces = (text.match(/\\{/g) || []).length;\r\n                const closeBraces = (text.match(/\\}/g) || []).length;\r\n                const openBrackets = (text.match(/\\[/g) || []).length;\r\n                const closeBrackets = (text.match(/\\]/g) || []).length;\r\n\r\n                console.log('[NT-Parse] Recovery attempt - braces: open=' + openBraces + ' close=' + closeBraces + ', brackets: open=' + openBrackets + ' close=' + closeBrackets);\r\n\r\n                // Try to close incomplete strings and objects\r\n                if (salvaged.match(/\"[^\"]*$/)) {\r\n                    // Has unclosed quote\r\n                    console.log('[NT-Parse] Adding closing quote');\r\n                    salvaged += '\"';\r\n                }\r\n\r\n                // Close missing brackets/braces\r\n                for (let i = 0; i < (openBrackets - closeBrackets); i++) {\r\n                    salvaged += ']';\r\n                }\r\n                for (let i = 0; i < (openBraces - closeBraces); i++) {\r\n                    salvaged += '}';\r\n                }\r\n\r\n                console.log('[NT-Parse] Salvaged text length:', salvaged.length);\r\n                console.log('[NT-Parse] Attempting to parse salvaged content...');\r\n\r\n                try {\r\n                    const recovered = JSON.parse(salvaged);\r\n                    console.log('[NT-Parse]  Successfully recovered JSON with', recovered.characters?.length || 0, 'characters');\r\n                    console.log('[NT-Parse] ========== PARSE END (RECOVERED) ==========');\r\n                    return recovered;\r\n                } catch (e) {\r\n                    console.error('[NT-Parse]  Recovery failed:', e.message);\r\n                    console.error('[NT-Parse] Salvaged text (first 500):', salvaged.substring(0, 500));\r\n                }\r\n            }\r\n\r\n            console.log('[NT-Parse] ========== PARSE END (FAILED) ==========');\r\n\r\n            if (session) {\r\n                session.logEnd(false, error, text);\r\n            }\r\n\r\n            // Provide specific feedback about the JSON error\r\n            let errorHelp = 'Failed to parse LLM response as JSON.';\r\n            if (error.message.includes('Expected \\':\\'') || error.message.includes('after property name')) {\r\n                errorHelp = 'JSON parsing failed: Missing colon after property name or orphaned string without property. The LLM likely generated a description without specifying which field it belongs to.';\r\n            } else if (error.message.includes('Unexpected token')) {\r\n                errorHelp = 'JSON parsing failed: Unexpected character found. Check for missing quotes, commas, or control characters.';\r\n            } else if (error.message.includes('Unexpected end')) {\r\n                errorHelp = 'JSON parsing failed: Response appears truncated. Try analyzing fewer messages at once.';\r\n            }\r\n\r\n            throw new NameTrackerError(errorHelp);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Call LLM for character analysis with automatic batch splitting if prompt is too long\r\n * and adaptive splitting when parse/output failures occur.\r\n * @param {Array} messageObjs - Array of message objects (with .mes property) or strings\r\n * @param {string} knownCharacters - Roster of previously identified characters\r\n * @param {number} depth - Recursion depth (for logging)\r\n * @param {number} retryCount - Number of retries attempted (simple backoff)\r\n * @param {number} splitAttempts - Number of times this failing batch has been split\r\n * @returns {Promise<Object>} Analysis result with merged characters\r\n */\r\nexport async function callLLMAnalysis(messageObjs, knownCharacters = '', depth = 0, retryCount = 0, splitAttempts = 0) {\r\n    return withErrorBoundary('callLLMAnalysis', async () => {\r\n        const llmConfig = await getLLMConfig();\r\n        const maxPromptResult = await getMaxPromptLength(); // Dynamic based on API context window\r\n        const maxPromptTokens = maxPromptResult.maxPrompt;\r\n        const MAX_SIMPLE_RETRIES = 1;   // retry count after first failure (total 2 attempts)\r\n        const MAX_SPLIT_ATTEMPTS = 2;   // how many times we can split on failure (up to 4 chunks)\r\n\r\n        debug.log();\r\n\r\n        // Extract message text\r\n        const messages = messageObjs.map(msg => {\r\n            if (typeof msg === 'string') return msg;\r\n            if (msg.mes) return msg.mes;\r\n            if (msg.message) return msg.message;\r\n            return JSON.stringify(msg);\r\n        });\r\n\r\n        // Create cache key\r\n        const cacheKey = simpleHash(messages.join('\\\\n') + llmConfig.source + llmConfig.ollamaModel);\r\n\r\n        // Check cache\r\n        if (analysisCache.has(cacheKey)) {\r\n            debug.log();\r\n            return analysisCache.get(cacheKey);\r\n        }\r\n\r\n        // Build the prompt\r\n        const messagesText = messages.map((msg, idx) => `Message ${idx + 1}:\\\\n${msg}`).join('\\\\n\\\\n');\r\n\r\n        // Get system prompt\r\n        let systemPrompt = await getSystemPrompt();\r\n        console.log('[NT-Prompt] getSystemPrompt() returned type:', typeof systemPrompt);\r\n\r\n        // Handle if it's still not a string\r\n        if (typeof systemPrompt !== 'string') {\r\n            console.warn('[NT-Prompt] systemPrompt is not a string, using default. Type:', typeof systemPrompt, 'Value:', systemPrompt);\r\n            systemPrompt = DEFAULT_SYSTEM_PROMPT;\r\n        }\r\n\r\n        // Get character roster and ensure it's a string\r\n        let rosterStr = knownCharacters || '';\r\n        console.log('[NT-Prompt] knownCharacters type:', typeof rosterStr);\r\n\r\n        // Handle if it's a Promise\r\n        if (rosterStr && typeof rosterStr === 'object' && typeof rosterStr.then === 'function') {\r\n            console.warn('[NT-Prompt] knownCharacters is Promise, awaiting...');\r\n            rosterStr = await rosterStr;\r\n            console.log('[NT-Prompt] After await, type:', typeof rosterStr);\r\n        }\r\n\r\n        // Ensure it's a string\r\n        rosterStr = String(rosterStr || '');\r\n\r\n        console.log('[NT-Prompt] Final systemPrompt length:', systemPrompt.length);\r\n        console.log('[NT-Prompt] Final rosterStr length:', rosterStr.length);\r\n        console.log('[NT-Prompt] systemPrompt preview:', systemPrompt.substring(0, 100));\r\n\r\n        // Inject character roster into system prompt using template placeholder\r\n        const systemMessage = systemPrompt.replace('{{CHARACTER_ROSTER}}', rosterStr);\r\n\r\n        // Build user prompt with data\r\n        const userPrompt = '[DATA TO ANALYZE]\\n' + messagesText;\r\n\r\n        // No prefill - let model generate complete JSON from system prompt guidance\r\n        const prefill = '';\r\n\r\n        // Calculate actual token count for the combined messages\r\n        let promptTokens;\r\n        const combinedText = systemMessage + '\\n\\n' + userPrompt;\r\n        try {\r\n            promptTokens = await calculateMessageTokens([{ mes: combinedText }]);\r\n            debug.log();\r\n        } catch {\r\n            debug.log();\r\n            // Fallback to character-based estimate\r\n            promptTokens = Math.ceil(combinedText.length / 4);\r\n        }\r\n\r\n        // If prompt is too long, split into sub-batches\r\n        if (promptTokens > maxPromptTokens && messageObjs.length > 1) {\r\n            debug.log();\r\n\r\n            // Split roughly in half\r\n            const midpoint = Math.floor(messageObjs.length / 2);\r\n            const firstHalf = messageObjs.slice(0, midpoint);\r\n            const secondHalf = messageObjs.slice(midpoint);\r\n\r\n            debug.log();\r\n\r\n            // Analyze both halves in parallel\r\n            const [result1, result2] = await Promise.all([\r\n                callLLMAnalysis(firstHalf, knownCharacters, depth + 1, 0, splitAttempts),\r\n                callLLMAnalysis(secondHalf, knownCharacters, depth + 1, 0, splitAttempts),\r\n            ]);\r\n\r\n            // Merge the results\r\n            const mergedResult = {\r\n                characters: [\r\n                    ...(result1.characters || []),\r\n                    ...(result2.characters || []),\r\n                ],\r\n            };\r\n\r\n            debug.log();\r\n            return mergedResult;\r\n        }\r\n\r\n        // Prompt is acceptable length, proceed with analysis\r\n        debug.log(`Calling LLM with prompt (${promptTokens} tokens)...`);\r\n        console.log(`[NT-Prompt] Composition: SYSTEM(${systemMessage.length} chars) + USER(${userPrompt.length} chars) + PREFILL`);\r\n\r\n        let result;\r\n\r\n        try {\r\n            if (llmConfig.source === 'ollama') {\r\n                // Ollama still uses flat prompt for now\r\n                const flatPrompt = systemMessage + '\\n\\n' + userPrompt + '\\n' + prefill;\r\n                result = await callOllama(flatPrompt);\r\n            } else {\r\n                // Use non-interactive mode so outer logic can handle retries/splitting\r\n                result = await callSillyTavern(systemMessage, userPrompt, prefill, false);\r\n            }\r\n        } catch (error) {\r\n            const isRetryable = error.message.includes('JSON')\r\n                || error.message.includes('empty')\r\n                || error.message.includes('truncated');\r\n\r\n            // First retry: try the same batch once with backoff\r\n            if (isRetryable && retryCount < MAX_SIMPLE_RETRIES) {\r\n                debug.log();\r\n\r\n                const delay = Math.pow(2, retryCount) * 1000; // 1s, 2s\r\n                await new Promise(resolve => setTimeout(resolve, delay));\r\n\r\n                return await callLLMAnalysis(messageObjs, knownCharacters, depth, retryCount + 1, splitAttempts);\r\n            }\r\n\r\n            // Subsequent retries: split the current failing batch into halves (up to 4 chunks total)\r\n            if (isRetryable && messageObjs.length > 1 && splitAttempts < MAX_SPLIT_ATTEMPTS) {\r\n                const midpoint = Math.floor(messageObjs.length / 2);\r\n                const firstHalf = messageObjs.slice(0, midpoint);\r\n                const secondHalf = messageObjs.slice(midpoint);\r\n\r\n                const [result1, result2] = await Promise.all([\r\n                    callLLMAnalysis(firstHalf, knownCharacters, depth + 1, 0, splitAttempts + 1),\r\n                    callLLMAnalysis(secondHalf, knownCharacters, depth + 1, 0, splitAttempts + 1),\r\n                ]);\r\n\r\n                return {\r\n                    characters: [\r\n                        ...(result1.characters || []),\r\n                        ...(result2.characters || []),\r\n                    ],\r\n                };\r\n            }\r\n\r\n            // Max retries/splits exceeded or non-retryable error\r\n            throw error;\r\n        }\r\n\r\n        // Check for empty response and retry once with stronger emphasis\r\n        if (result && Array.isArray(result.characters) && result.characters.length === 0 && retryCount === 0) {\r\n            console.warn('[NT-LLM] Empty response detected, retrying with stronger user character emphasis...');\r\n\r\n            // Add stronger user character requirement to the user prompt\r\n            const retryUserPrompt = userPrompt + '\\n\\nCRITICAL ERROR: Previous response was empty. You MUST return at minimum the user character ({{user}}) with any available details from these messages. An empty character list is INVALID.';\r\n\r\n            try {\r\n                let retryResult;\r\n                if (llmConfig.source === 'ollama') {\r\n                    const retryFlatPrompt = systemMessage + '\\n\\n' + retryUserPrompt + '\\n' + prefill;\r\n                    retryResult = await callOllama(retryFlatPrompt);\r\n                } else {\r\n                    retryResult = await callSillyTavern(systemMessage, retryUserPrompt, prefill, false);\r\n                }\r\n\r\n                if (retryResult && Array.isArray(retryResult.characters) && retryResult.characters.length > 0) {\r\n                    console.log('[NT-LLM] Retry successful, got', retryResult.characters.length, 'characters');\r\n                    result = retryResult;\r\n                } else {\r\n                    console.error('[NT-LLM] Retry also returned empty, proceeding with empty result');\r\n                }\r\n            } catch (retryError) {\r\n                console.error('[NT-LLM] Retry failed:', retryError.message, 'proceeding with original empty result');\r\n            }\r\n        }\r\n\r\n        // Cache the result only if we have characters\r\n        if (result && Array.isArray(result.characters) && result.characters.length > 0) {\r\n            if (analysisCache.size > 50) {\r\n                // Clear oldest entries if cache is getting too large\r\n                const firstKey = analysisCache.keys().next().value;\r\n                analysisCache.delete(firstKey);\r\n            }\r\n            analysisCache.set(cacheKey, result);\r\n        } else {\r\n            console.warn('[NT-Cache] Skipping cache because result is empty or has no characters');\r\n        }\r\n\r\n        debug.log();\r\n        return result;\r\n    });\r\n}\r\n\r\n/**\r\n * Clear the analysis cache\r\n */\r\nexport function clearAnalysisCache() {\r\n    analysisCache.clear();\r\n    debug.log();\r\n}\r\n\r\n/**\r\n * Get analysis cache statistics\r\n * @returns {Object} Cache statistics\r\n */\r\nexport function getCacheStats() {\r\n    return {\r\n        size: analysisCache.size,\r\n        entries: [...analysisCache.keys()].map(key => ({\r\n            key: key.substring(0, 8) + '...',\r\n            timestamp: Date.now(),\r\n        })),\r\n    };\r\n}\r\n\r\n// End of module\r\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};","\"use strict\";\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n  if (!cssMapping) {\n    return content;\n  }\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    return [content].concat([sourceMapping]).join(\"\\n\");\n  }\n  return [content].join(\"\\n\");\n};","/**\r\n * Error handling and recovery system for Name Tracker extension\r\n * Provides error boundaries, graceful degradation, and transaction rollback\r\n */\r\n\r\nimport debugLogger from './debug.js';\r\n\r\nconst logger = debugLogger.createModuleLogger('ErrorHandler');\r\n\r\nclass NameTrackerError extends Error {\r\n    constructor(message, code, module, recoverable = true) {\r\n        super(message);\r\n        this.name = 'NameTrackerError';\r\n        this.code = code;\r\n        this.module = module;\r\n        this.recoverable = recoverable;\r\n        this.timestamp = Date.now();\r\n    }\r\n}\r\n\r\nclass ErrorHandler {\r\n    constructor() {\r\n        this.errorHistory = [];\r\n        this.transactionStack = [];\r\n        this.recoveryStrategies = new Map();\r\n        this.criticalErrorCallbacks = [];\r\n    }\r\n\r\n    /**\r\n     * Create error boundary for a module operation\r\n     * @param {string} moduleName - Module name\r\n     * @param {Function} operation - Operation to execute\r\n     * @param {Object} options - Error handling options\r\n     * @returns {Promise<any>} Operation result or error recovery result\r\n     */\r\n    async withErrorBoundary(moduleName, operation, options = {}) {\r\n        const {\r\n            fallback = null,\r\n            retries = 0,\r\n            silent = false,\r\n            operationId = null,\r\n        } = options;\r\n\r\n        let lastError = null;\r\n        const startTime = Date.now();\r\n\r\n        if (operationId) {\r\n            logger.trace(operationId, `Starting operation in ${moduleName}`);\r\n        }\r\n\r\n        for (let attempt = 0; attempt <= retries; attempt++) {\r\n            try {\r\n                const result = await operation();\r\n\r\n                if (operationId) {\r\n                    logger.trace(operationId, `Operation completed successfully in ${moduleName}`);\r\n                }\r\n\r\n                return result;\r\n            } catch (error) {\r\n                console.log(`[NT-Errors] Error caught in ${moduleName}:`, error);\r\n                lastError = error;\r\n\r\n                if (attempt < retries) {\r\n                    console.log(`[NT-Errors] Retrying operation in ${moduleName}, attempt ${attempt + 1}/${retries + 1}:`, error.message);\r\n                    logger.warn(`Retrying operation in ${moduleName}, attempt ${attempt + 1}/${retries + 1}:`, error.message);\r\n                    await this.delay(Math.pow(2, attempt) * 100); // Exponential backoff\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        // All retries failed\r\n        console.log(`[NT-Errors] All retries failed in ${moduleName}, tracking error:`, lastError);\r\n        const trackedError = this.trackError(lastError, moduleName, {\r\n            operation: operation.name || 'anonymous',\r\n            duration: Date.now() - startTime,\r\n            retries: retries,\r\n            operationId: operationId,\r\n        });\r\n\r\n        if (!silent) {\r\n            console.log(`[NT-Errors] Notifying user of error in ${moduleName}`);\r\n            this.notifyUser(trackedError);\r\n        }\r\n\r\n        // Try recovery strategy\r\n        if (fallback) {\r\n            try {\r\n                logger.debug(`Attempting fallback for ${moduleName}:`, trackedError.code);\r\n                return await fallback(trackedError);\r\n            } catch (fallbackError) {\r\n                logger.error(`Fallback failed for ${moduleName}:`, fallbackError);\r\n            }\r\n        }\r\n\r\n        // Check if we have a recovery strategy\r\n        const recovery = this.recoveryStrategies.get(trackedError.code);\r\n        if (recovery) {\r\n            try {\r\n                return await recovery(trackedError);\r\n            } catch (recoveryError) {\r\n                logger.error(`Recovery strategy failed for ${trackedError.code}:`, recoveryError);\r\n            }\r\n        }\r\n\r\n        throw trackedError;\r\n    }\r\n\r\n    /**\r\n     * Track and categorize errors\r\n     * @param {Error} error - Original error\r\n     * @param {string} moduleName - Module where error occurred\r\n     * @param {Object} context - Additional context\r\n     * @returns {NameTrackerError} Tracked error\r\n     */\r\n    trackError(error, moduleName, context = {}) {\r\n        let trackedError;\r\n\r\n        if (error instanceof NameTrackerError) {\r\n            trackedError = error;\r\n        } else {\r\n            // Categorize common error types\r\n            const code = this.categorizeError(error, moduleName);\r\n            trackedError = new NameTrackerError(\r\n                error.message,\r\n                code,\r\n                moduleName,\r\n                this.isRecoverable(error, code),\r\n            );\r\n        }\r\n\r\n        trackedError.context = context;\r\n        this.errorHistory.push(trackedError);\r\n\r\n        // Keep only last 100 errors\r\n        if (this.errorHistory.length > 100) {\r\n            this.errorHistory.shift();\r\n        }\r\n\r\n        logger.error(`Error in ${moduleName}:`, {\r\n            code: trackedError.code,\r\n            message: trackedError.message,\r\n            context: context,\r\n        });\r\n\r\n        return trackedError;\r\n    }\r\n\r\n    /**\r\n     * Categorize error types for better handling\r\n     * @param {Error} error - Original error\r\n     * @param {string} moduleName - Module name\r\n     * @returns {string} Error code\r\n     */\r\n    categorizeError(error, moduleName) {\r\n        if (error.message.includes('fetch') || error.message.includes('network')) {\r\n            return 'NETWORK_ERROR';\r\n        }\r\n\r\n        if (error.message.includes('JSON') || error.message.includes('parse')) {\r\n            return 'DATA_FORMAT_ERROR';\r\n        }\r\n\r\n        if (error.message.includes('context') || error.message.includes('SillyTavern')) {\r\n            return 'CONTEXT_ERROR';\r\n        }\r\n\r\n        if (error.name === 'TypeError') {\r\n            return 'TYPE_ERROR';\r\n        }\r\n\r\n        if (moduleName === 'LLM' && (error.message.includes('quota') || error.message.includes('rate'))) {\r\n            return 'API_LIMIT_ERROR';\r\n        }\r\n\r\n        return 'UNKNOWN_ERROR';\r\n    }\r\n\r\n    /**\r\n     * Determine if an error is recoverable\r\n     * @param {Error} error - Original error\r\n     * @param {string} code - Error code\r\n     * @returns {boolean} Whether error is recoverable\r\n     */\r\n    isRecoverable(error, code) {\r\n        const nonRecoverableErrors = [\r\n            'CONTEXT_ERROR',\r\n            'TYPE_ERROR',\r\n        ];\r\n\r\n        return !nonRecoverableErrors.includes(code);\r\n    }\r\n\r\n    /**\r\n     * Start a transaction for rollback capability\r\n     * @param {string} transactionId - Unique transaction identifier\r\n     * @param {Object} initialState - State to potentially rollback to\r\n     */\r\n    startTransaction(transactionId, initialState) {\r\n        this.transactionStack.push({\r\n            id: transactionId,\r\n            state: JSON.stringify(initialState),\r\n            timestamp: Date.now(),\r\n        });\r\n\r\n        logger.debug(`Started transaction: ${transactionId}`);\r\n    }\r\n\r\n    /**\r\n     * Commit a transaction (remove from rollback stack)\r\n     * @param {string} transactionId - Transaction identifier\r\n     */\r\n    commitTransaction(transactionId) {\r\n        const index = this.transactionStack.findIndex(t => t.id === transactionId);\r\n        if (index !== -1) {\r\n            this.transactionStack.splice(index, 1);\r\n            logger.debug(`Committed transaction: ${transactionId}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rollback a transaction\r\n     * @param {string} transactionId - Transaction identifier\r\n     * @returns {Object|null} Previous state or null if not found\r\n     */\r\n    rollbackTransaction(transactionId) {\r\n        const index = this.transactionStack.findIndex(t => t.id === transactionId);\r\n        if (index !== -1) {\r\n            const transaction = this.transactionStack.splice(index, 1)[0];\r\n            logger.debug(`Rolled back transaction: ${transactionId}`);\r\n            return JSON.parse(transaction.state);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Register a recovery strategy for specific error codes\r\n     * @param {string} errorCode - Error code to handle\r\n     * @param {Function} strategy - Recovery function\r\n     */\r\n    registerRecoveryStrategy(errorCode, strategy) {\r\n        this.recoveryStrategies.set(errorCode, strategy);\r\n        logger.debug(`Registered recovery strategy for: ${errorCode}`);\r\n    }\r\n\r\n    /**\r\n     * Register callback for critical errors\r\n     * @param {Function} callback - Function to call on critical errors\r\n     */\r\n    onCriticalError(callback) {\r\n        this.criticalErrorCallbacks.push(callback);\r\n    }\r\n\r\n    /**\r\n     * Notify user of errors via toastr\r\n     * @param {NameTrackerError} error - Error to display\r\n     */\r\n    notifyUser(error) {\r\n        const message = `Name Tracker: ${error.message}`;\r\n\r\n        if (error.recoverable) {\r\n            toastr.warning(message, 'Warning', { timeOut: 5000 });\r\n        } else {\r\n            toastr.error(message, 'Error', { timeOut: 8000 });\r\n\r\n            // Notify critical error callbacks\r\n            this.criticalErrorCallbacks.forEach(callback => {\r\n                try {\r\n                    callback(error);\r\n                } catch (callbackError) {\r\n                    logger.error('Critical error callback failed:', callbackError);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get recent error history\r\n     * @param {number} count - Number of recent errors to return\r\n     * @returns {Array} Recent errors\r\n     */\r\n    getRecentErrors(count = 10) {\r\n        return this.errorHistory.slice(-count);\r\n    }\r\n\r\n    /**\r\n     * Clear error history\r\n     */\r\n    clearHistory() {\r\n        this.errorHistory = [];\r\n        logger.debug('Cleared error history');\r\n    }\r\n\r\n    /**\r\n     * Utility delay function for retries\r\n     * @param {number} ms - Milliseconds to delay\r\n     * @returns {Promise} Delay promise\r\n     */\r\n    delay(ms) {\r\n        return new Promise(resolve => setTimeout(resolve, ms));\r\n    }\r\n}\r\n\r\n// Create singleton instance\r\nconst errorHandler = new ErrorHandler();\r\n\r\nexport { errorHandler, NameTrackerError };\r\nexport const withErrorBoundary = errorHandler.withErrorBoundary.bind(errorHandler);\r\nexport default errorHandler;\r\n","\"use strict\";\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;","/**\r\n * Simplified settings management for Name Tracker extension\r\n * Uses SillyTavern standard patterns with preserved error handling\r\n */\r\n\r\nimport { errorHandler } from './errors.js';\r\nimport { createModuleLogger } from './debug.js';\r\nimport { stContext } from './context.js';\r\n\r\nconst MODULE_NAME = 'STnametracker';\r\nconst debug = createModuleLogger('Settings');\r\n\r\n// Cache for context availability to avoid repeated null checks\r\nlet contextAvailable = false;\r\nlet lastContextCheck = 0;\r\nconst CONTEXT_CHECK_INTERVAL = 100; // Check every 100ms max\r\nlet hasLoggedUnavailable = false; // Only log warning once\r\n\r\nfunction getContextSettings() {\r\n    // CORRECTED: Use direct global access pattern (MessageSummarize/Codex/Nicknames pattern)\r\n    // All reference extensions use window.extension_settings[MODULE_NAME] directly,\r\n    // NOT through context.extension_settings (which doesn't exist)\r\n    \r\n    // Check if window.extension_settings is available\r\n    if (!window.extension_settings) {\r\n        return {\r\n            extSettings: null,\r\n            saveSettings: null,\r\n        };\r\n    }\r\n\r\n    // Get context for saveSettingsDebounced\r\n    const context = stContext.getContext();\r\n    \r\n    return {\r\n        extSettings: window.extension_settings,  // Direct global access\r\n        saveSettings: context?.saveSettingsDebounced || null,\r\n    };\r\n}\r\n\r\n// Default settings structure\r\nconst DEFAULT_SETTINGS = Object.freeze({\r\n    enabled: true,\r\n    autoAnalyze: true,\r\n    messageFrequency: 10,\r\n    llmSource: 'sillytavern', // 'sillytavern' or 'ollama'\r\n    ollamaEndpoint: 'http://localhost:11434',\r\n    ollamaModel: '',\r\n    confidenceThreshold: 70,\r\n    lorebookPosition: 0, // after character defs\r\n    lorebookDepth: 1,\r\n    lorebookCooldown: 10,\r\n    lorebookScanDepth: 1,\r\n    lorebookProbability: 100,\r\n    lorebookEnabled: true,\r\n    debugMode: false,\r\n    systemPrompt: null, // null means use default\r\n    maxResponseTokens: 5000, // Maximum tokens for LLM response (budget cap)\r\n    lastScannedMessageId: -1,\r\n    totalCharactersDetected: 0,\r\n    lastAnalysisTime: null,\r\n    analysisCache: new Map(),\r\n});\r\n\r\n// Default chat-level data structure\r\nconst DEFAULT_CHAT_DATA = Object.freeze({\r\n    characters: {},\r\n    lastScannedMessageId: -1,\r\n    analysisHistory: [],\r\n    lorebookEntries: {},\r\n    processingStats: {\r\n        totalProcessed: 0,\r\n        charactersFound: 0,\r\n        lastProcessedTime: null,\r\n    },\r\n});\r\n\r\n/**\r\n * Get current settings with defaults\r\n * @returns {Object} Current settings\r\n */\r\nfunction get_settings() {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        const { extSettings } = getContextSettings();\r\n        if (!extSettings) {\r\n            // Only log once to avoid console spam\r\n            if (!hasLoggedUnavailable) {\r\n                console.warn('[STnametracker] extension_settings not yet available, using defaults');\r\n                hasLoggedUnavailable = true;\r\n            }\r\n            return { ...DEFAULT_SETTINGS };\r\n        }\r\n\r\n        // Context now available, reset warning flag for next session\r\n        hasLoggedUnavailable = false;\r\n\r\n        // Initialize if not exists\r\n        let needsSave = false;\r\n        if (!extSettings[MODULE_NAME]) {\r\n            console.log('[STnametracker] First-time initialization: creating default settings');\r\n            extSettings[MODULE_NAME] = { ...DEFAULT_SETTINGS };\r\n            needsSave = true;\r\n        }\r\n\r\n        // Merge with defaults to ensure all properties exist\r\n        const settings = { ...DEFAULT_SETTINGS, ...extSettings[MODULE_NAME] };\r\n        \r\n        // Persist defaults if this was first initialization\r\n        if (needsSave && saveSettings && typeof saveSettings === 'function') {\r\n            console.log('[STnametracker] Saving default settings to persist them');\r\n            saveSettings();\r\n        }\r\n        \r\n        return settings;\r\n    }, { ...DEFAULT_SETTINGS });\r\n}\r\n\r\n/**\r\n * Update settings and save\r\n * @param {Object} newSettings - Settings to update\r\n */\r\nfunction set_settings(newSettings) {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        const { extSettings, saveSettings } = getContextSettings();\r\n        if (!extSettings) {\r\n            console.warn('[STnametracker] extension_settings not available for saving');\r\n            return;\r\n        }\r\n\r\n        // Initialize if not exists\r\n        if (!extSettings[MODULE_NAME]) {\r\n            extSettings[MODULE_NAME] = { ...DEFAULT_SETTINGS };\r\n        }\r\n\r\n        // Update settings\r\n        Object.assign(extSettings[MODULE_NAME], newSettings);\r\n\r\n        // Save to SillyTavern\r\n        if (typeof saveSettings === 'function') {\r\n            saveSettings();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Get current chat characters\r\n * @returns {Object} Chat characters data\r\n */\r\nfunction getCharacters() {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        try {\r\n            const metadata = stContext.getChatMetadata();\r\n\r\n            // Initialize if not exists\r\n            if (!metadata[MODULE_NAME]) {\r\n                metadata[MODULE_NAME] = { ...DEFAULT_CHAT_DATA };\r\n            }\r\n\r\n            return metadata[MODULE_NAME].characters || {};\r\n        } catch (error) {\r\n            debug.warn('Failed to get characters:', error.message);\r\n            return {};\r\n        }\r\n    }, {});\r\n}\r\n\r\n/**\r\n * Update chat characters and save\r\n * @param {Object} characters - Characters data to save\r\n */\r\nasync function setCharacters(characters) {\r\n    return errorHandler.withErrorBoundary('Settings', async () => {\r\n        try {\r\n            const metadata = stContext.getChatMetadata();\r\n\r\n            // Initialize if not exists\r\n            if (!metadata[MODULE_NAME]) {\r\n                metadata[MODULE_NAME] = { ...DEFAULT_CHAT_DATA };\r\n            }\r\n\r\n            // Update characters\r\n            metadata[MODULE_NAME].characters = characters;\r\n\r\n            // CRITICAL: AWAIT the save to complete before returning\r\n            await stContext.saveMetadata();\r\n        } catch (error) {\r\n            debug.warn('Failed to set characters:', error.message);\r\n            throw error; // Re-throw so caller knows it failed\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Get chat-level data\r\n * @returns {Object} Chat metadata\r\n */\r\nfunction getChatData() {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        try {\r\n            const metadata = stContext.getChatMetadata();\r\n\r\n            // Initialize if not exists\r\n            if (!metadata[MODULE_NAME]) {\r\n                metadata[MODULE_NAME] = { ...DEFAULT_CHAT_DATA };\r\n            }\r\n\r\n            return metadata[MODULE_NAME];\r\n        } catch (error) {\r\n            debug.warn('Failed to get chat data:', error.message);\r\n            return { ...DEFAULT_CHAT_DATA };\r\n        }\r\n    }, { ...DEFAULT_CHAT_DATA });\r\n}\r\n\r\n/**\r\n * Update chat-level data\r\n * @param {Object} data - Data to update\r\n */\r\nasync function setChatData(data) {\r\n    return errorHandler.withErrorBoundary('Settings', async () => {\r\n        try {\r\n            const metadata = stContext.getChatMetadata();\r\n\r\n            // Initialize if not exists\r\n            if (!metadata[MODULE_NAME]) {\r\n                metadata[MODULE_NAME] = { ...DEFAULT_CHAT_DATA };\r\n            }\r\n\r\n            // Update data\r\n            Object.assign(metadata[MODULE_NAME], data);\r\n\r\n            // CRITICAL: AWAIT the save to complete before returning\r\n            await stContext.saveMetadata();\r\n        } catch (error) {\r\n            debug.warn('Failed to set chat data:', error.message);\r\n            throw error; // Re-throw so caller knows it failed\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Add a character to the current chat\r\n * @param {string} name - Character name\r\n * @param {Object} characterData - Character data\r\n */\r\nasync function addCharacter(name, characterData) {\r\n    return errorHandler.withErrorBoundary('Settings', async () => {\r\n        const characters = await getCharacters();\r\n        characters[name] = characterData;\r\n        await setCharacters(characters); // AWAIT the async save\r\n    });\r\n}\r\n\r\n/**\r\n * Remove a character from the current chat\r\n * @param {string} name - Character name to remove\r\n */\r\nasync function removeCharacter(name) {\r\n    return errorHandler.withErrorBoundary('Settings', async () => {\r\n        const characters = await getCharacters();\r\n        delete characters[name];\r\n        await setCharacters(characters); // AWAIT the async save\r\n    });\r\n}\r\n\r\n/**\r\n * Get a specific setting value\r\n * @param {string} key - Setting key\r\n * @param {*} defaultValue - Default value if not found\r\n * @returns {*} Setting value\r\n */\r\nasync function getSetting(key, defaultValue) {\r\n    const settings = await get_settings();\r\n    return settings[key] !== undefined ? settings[key] : defaultValue;\r\n}\r\n\r\n/**\r\n * Set a specific setting value\r\n * @param {string} key - Setting key\r\n * @param {*} value - Setting value\r\n */\r\nasync function setSetting(key, value) {\r\n    const update = {};\r\n    update[key] = value;\r\n    await set_settings(update);\r\n}\r\n\r\n/**\r\n * Get a single character by name\r\n * @param {string} name - Character name\r\n * @returns {Object|null} Character data or null if not found\r\n */\r\nasync function getCharacter(name) {\r\n    return errorHandler.withErrorBoundary('Settings', async () => {\r\n        if (!name || typeof name !== 'string') {\r\n            console.warn('[STnametracker] Invalid character name:', name);\r\n            return null;\r\n        }\r\n        const chars = await getCharacters();\r\n        return chars[name] || null;\r\n    });\r\n}\r\n\r\n/**\r\n * Set a character by name\r\n * @param {string} name - Character name\r\n * @param {Object} character - Character data\r\n */\r\nasync function setCharacter(name, character) {\r\n    return errorHandler.withErrorBoundary('Settings', async () => {\r\n        if (!name || typeof name !== 'string') {\r\n            throw new Error('Character name must be a non-empty string');\r\n        }\r\n        if (!character || typeof character !== 'object') {\r\n            throw new Error('Character data must be an object');\r\n        }\r\n        console.log('[NT-Settings]  setCharacter() called for:', name);\r\n        const chars = { ...await getCharacters() };\r\n        chars[name] = character;\r\n        await setCharacters(chars); // AWAIT the async setCharacters\r\n        debug.log(`Set character: ${name}`);\r\n        console.log('[NT-Settings]  setCharacter() completed for:', name);\r\n    });\r\n}\r\n\r\n/**\r\n * Get LLM configuration (Fixed: No Promise contamination)\r\n * @returns {Object} LLM configuration object with resolved values\r\n */\r\nasync function getLLMConfig() {\r\n    try {\r\n        const llmSource = await getSetting('llmSource');\r\n        const ollamaEndpoint = await getSetting('ollamaEndpoint');\r\n        const ollamaModel = await getSetting('ollamaModel');\r\n        const systemPrompt = await getSetting('systemPrompt');\r\n\r\n        const { extSettings } = getContextSettings();\r\n        const moduleSettings = extSettings ? extSettings[MODULE_NAME] : null;\r\n        debug.log('[NT-LLMConfig] llmSource setting:', llmSource);\r\n        debug.log('[NT-LLMConfig] extension_settings keys for module:', moduleSettings ? Object.keys(moduleSettings) : 'none');\r\n\r\n        // Ensure no Promise objects are returned\r\n        return {\r\n            source: (typeof llmSource === 'string') ? llmSource : 'sillytavern',\r\n            ollamaEndpoint: (typeof ollamaEndpoint === 'string') ? ollamaEndpoint : 'http://localhost:11434',\r\n            ollamaModel: (typeof ollamaModel === 'string') ? ollamaModel : '',\r\n            systemPrompt: (typeof systemPrompt === 'string') ? systemPrompt : null,\r\n        };\r\n    } catch (error) {\r\n        console.warn('[STnametracker] Error getting LLM config, using defaults:', error);\r\n        return { source: 'sillytavern', ollamaEndpoint: 'http://localhost:11434', ollamaModel: '', systemPrompt: null };\r\n    }\r\n}\r\n\r\n/**\r\n * Get lorebook configuration (Fixed: No Promise contamination)\r\n * @returns {Object} Lorebook configuration object with resolved values\r\n */\r\nasync function getLorebookConfig() {\r\n    try {\r\n        const position = await getSetting('lorebookPosition');\r\n        const depth = await getSetting('lorebookDepth');\r\n        const cooldown = await getSetting('lorebookCooldown');\r\n        const scanDepth = await getSetting('lorebookScanDepth');\r\n        const probability = await getSetting('lorebookProbability');\r\n        const enabled = await getSetting('lorebookEnabled');\r\n\r\n        // Ensure no Promise objects are returned\r\n        return {\r\n            position: (typeof position === 'number') ? position : 0,\r\n            depth: (typeof depth === 'number') ? depth : 1,\r\n            cooldown: (typeof cooldown === 'number') ? cooldown : 5,\r\n            scanDepth: (typeof scanDepth === 'number') ? scanDepth : 1,\r\n            probability: (typeof probability === 'number') ? probability : 100,\r\n            enabled: (typeof enabled === 'boolean') ? enabled : true,\r\n        };\r\n    } catch (error) {\r\n        console.warn('[STnametracker] Error getting lorebook config, using defaults:', error);\r\n        return { position: 0, depth: 1, cooldown: 5, scanDepth: 1, probability: 100, enabled: true };\r\n    }\r\n}\r\n\r\n/**\r\n * Alias for get_settings for compatibility\r\n * @returns {Object} Current settings\r\n */\r\nasync function getSettings() {\r\n    return await get_settings();\r\n}\r\n\r\n/**\r\n * Get chat metadata value\r\n * @param {string} key - Metadata key\r\n * @returns {any} Metadata value\r\n */\r\nfunction get_chat_metadata(key) {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        try {\r\n            const metadata = stContext.getChatMetadata();\r\n\r\n            if (!metadata[MODULE_NAME]) {\r\n                metadata[MODULE_NAME] = { ...DEFAULT_CHAT_DATA };\r\n            }\r\n\r\n            return metadata[MODULE_NAME][key];\r\n        } catch (error) {\r\n            debug.warn('Failed to get chat metadata:', error.message);\r\n            return DEFAULT_CHAT_DATA[key];\r\n        }\r\n    }, DEFAULT_CHAT_DATA[key]);\r\n}\r\n\r\n/**\r\n * Set chat metadata value\r\n * @param {string} key - Metadata key\r\n * @param {any} value - New value\r\n */\r\nfunction set_chat_metadata(key, value) {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        try {\r\n            const metadata = stContext.getChatMetadata();\r\n\r\n            if (!metadata[MODULE_NAME]) {\r\n                metadata[MODULE_NAME] = { ...DEFAULT_CHAT_DATA };\r\n            }\r\n\r\n            metadata[MODULE_NAME][key] = value;\r\n            debug.log(`Updated chat data ${key}`);\r\n\r\n            stContext.saveMetadata().catch(err => {\r\n                debug.warn('Failed to save chat metadata:', err.message);\r\n            });\r\n        } catch (error) {\r\n            debug.warn('Failed to set chat metadata:', error.message);\r\n        }\r\n    });\r\n}\r\n\r\nexport {\r\n    MODULE_NAME,\r\n    DEFAULT_SETTINGS,\r\n    DEFAULT_CHAT_DATA,\r\n    get_settings,\r\n    set_settings,\r\n    getCharacters,\r\n    setCharacters,\r\n    getChatData,\r\n    setChatData,\r\n    addCharacter,\r\n    removeCharacter,\r\n    getSetting,\r\n    setSetting,\r\n    getCharacter,\r\n    setCharacter,\r\n    getLLMConfig,\r\n    getLorebookConfig,\r\n    getSettings,\r\n    get_chat_metadata,\r\n    set_chat_metadata,\r\n};\r\n","/**\r\n * Character Management Module\r\n *\r\n * Handles character CRUD operations, merging, alias detection, relationship management,\r\n * and per-character processing state tracking for the Name Tracker extension.\r\n */\r\n\r\nimport { updateLorebookEntry } from './lorebook.js';\r\nimport { createModuleLogger } from '../core/debug.js';\r\nimport { withErrorBoundary, NameTrackerError } from '../core/errors.js';\r\nimport {\r\n    getCharacters, getCharacter, setCharacter, removeCharacter,\r\n    set_chat_metadata, getSetting,\r\n} from '../core/settings.js';\r\nimport { NotificationManager } from '../utils/notifications.js';\r\n\r\nconst debug = createModuleLogger('characters');\r\nconst notifications = new NotificationManager('Character Management');\r\n\r\n/**\r\n * Validate and clean character data from LLM analysis\r\n * @param {Object} analyzedChar - Raw character data from LLM\r\n * @param {Array} allCharacters - Existing characters for validation\r\n * @returns {Object} Cleaned and validated character data\r\n */\r\nfunction validateCharacterData(analyzedChar, allCharacters = []) {\r\n    // Ensure required fields exist\r\n    const name = (analyzedChar.name || '').trim();\r\n    if (!name) {\r\n        throw new NameTrackerError('Character name is required');\r\n    }\r\n\r\n    // Validate confidence score\r\n    const confidence = typeof analyzedChar.confidence === 'number' && analyzedChar.confidence >= 0 && analyzedChar.confidence <= 100\r\n        ? analyzedChar.confidence\r\n        : 75;\r\n\r\n    // Clean and validate arrays\r\n    const aliases = Array.isArray(analyzedChar.aliases) ? analyzedChar.aliases.filter(a => typeof a === 'string' && a.trim()) : [];\r\n    const relationships = Array.isArray(analyzedChar.relationships) ? analyzedChar.relationships.filter(r => typeof r === 'string' && r.trim()) : [];\r\n\r\n    // Clean text fields\r\n    const cleanTextField = (field) => {\r\n        return typeof field === 'string' ? field.trim() : '';\r\n    };\r\n\r\n    // Clean name using helper if available (fallback to basic sanitization)\r\n    const sanitizedName = name.replace(/[<>&\"']/g, '').trim();\r\n\r\n    return {\r\n        name: sanitizedName,\r\n        aliases,\r\n        physicalAge: cleanTextField(analyzedChar.physicalAge),\r\n        mentalAge: cleanTextField(analyzedChar.mentalAge),\r\n        physical: cleanTextField(analyzedChar.physical),\r\n        personality: cleanTextField(analyzedChar.personality),\r\n        sexuality: cleanTextField(analyzedChar.sexuality),\r\n        raceEthnicity: cleanTextField(analyzedChar.raceEthnicity),\r\n        roleSkills: cleanTextField(analyzedChar.roleSkills),\r\n        relationships,\r\n        confidence,\r\n    };\r\n}\r\n\r\n// ============================================================================\r\n// DEBUG CONFIGURATION\r\n// ============================================================================\r\nconst DEBUG_LOGGING = true; // Set to false in production after testing\r\n\r\nfunction debugLog(message, data = null) {\r\n    if (DEBUG_LOGGING) {\r\n        console.log(`[NT-Characters] ${message}`, data || '');\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// CHARACTER-LOREBOOK SYNCHRONIZATION\r\n// ============================================================================\r\n\r\n/**\r\n * Validate character-lorebook synchronization\r\n * Ensures 1:1 relationship between characters and lorebook entries\r\n * @returns {Promise<{valid: boolean, issues: string[]}>} Validation results\r\n */\r\nexport async function validateCharacterLorebookSync() {\r\n    return withErrorBoundary('validateCharacterLorebookSync', async () => {\r\n        const characters = await getCharacters();\r\n        const issues = [];\r\n\r\n        debugLog(' Validating character-lorebook synchronization...');\r\n\r\n        // Check each character has a valid lorebook entry ID\r\n        for (const [name, character] of Object.entries(characters)) {\r\n            if (!character.lorebookEntryId) {\r\n                issues.push(`Character '${name}' missing lorebookEntryId`);\r\n            }\r\n        }\r\n\r\n        // Get lorebook stats to compare counts\r\n        try {\r\n            const { getLorebookStats } = await import('./lorebook.js');\r\n            const stats = await getLorebookStats();\r\n            const characterCount = Object.keys(characters).length;\r\n\r\n            if (stats.totalEntries !== characterCount) {\r\n                issues.push(`Count mismatch: ${characterCount} characters vs ${stats.totalEntries} lorebook entries`);\r\n            }\r\n\r\n            debugLog(` Sync validation: ${characterCount} characters, ${stats.totalEntries} entries`);\r\n\r\n        } catch (error) {\r\n            issues.push(`Could not validate lorebook entries: ${error.message}`);\r\n        }\r\n\r\n        const valid = issues.length === 0;\r\n\r\n        if (!valid) {\r\n            console.warn('[NT-Characters]  Character-Lorebook sync issues:', issues);\r\n        } else {\r\n            debugLog(' Character-lorebook synchronization validated');\r\n        }\r\n\r\n        return { valid, issues };\r\n    });\r\n}\r\n\r\n/**\r\n * Repair character-lorebook synchronization issues\r\n * @returns {Promise<{repaired: number, errors: string[]}>} Repair results\r\n */\r\nexport async function repairCharacterLorebookSync() {\r\n    return withErrorBoundary('repairCharacterLorebookSync', async () => {\r\n        const characters = await getCharacters();\r\n        const { updateLorebookEntry } = await import('./lorebook.js');\r\n        let repaired = 0;\r\n        const errors = [];\r\n\r\n        debugLog(' Repairing character-lorebook synchronization...');\r\n\r\n        for (const [name, character] of Object.entries(characters)) {\r\n            try {\r\n                if (!character.lorebookEntryId) {\r\n                    debugLog(` Creating missing lorebook entry for: ${name}`);\r\n                    await updateLorebookEntry(character, name);\r\n                    repaired++;\r\n                }\r\n            } catch (error) {\r\n                const errorMsg = `Failed to repair ${name}: ${error.message}`;\r\n                errors.push(errorMsg);\r\n                console.error(`[NT-Characters] ${errorMsg}`);\r\n            }\r\n        }\r\n\r\n        debugLog(` Repair complete: ${repaired} entries repaired, ${errors.length} errors`);\r\n        return { repaired, errors };\r\n    });\r\n}\r\n\r\n// Merge Confidence Tiers (as percentages: 0-100)\r\nconst MERGE_CONFIDENCE_HIGH = 0.9;      // 90%+ - Automatic merge (e.g., exact substring: \"Jazz\"/\"Jasmine\")\r\nconst MERGE_CONFIDENCE_MEDIUM = 0.7;    // 70%+ - User prompt required (e.g., phonetic similarity)\r\n// eslint-disable-next-line no-unused-vars\r\nconst MERGE_CONFIDENCE_LOW = 0.5;       // 50%+ - No automatic action (may indicate false positives)\r\n\r\n// ============================================================================\r\n// CHARACTER DATA VALIDATION AND CLEANUP\r\n// ============================================================================\r\n\r\n/**\r\n * Parse and normalize relationship strings from the new natural language format\r\n * Handles: \"Character A is to Character B: relationship1, relationship2\"\r\n * @param {Array<string>} relationships - Raw relationship strings from LLM\r\n * @param {string} currentCharName - Name of the current character\r\n * @param {Object} allCharacters - All known characters for name resolution\r\n * @returns {Array<string>} Normalized relationship triplets\r\n */\r\nfunction parseNewRelationshipFormat(relationships, currentCharName, allCharacters) {\r\n    if (!relationships || !Array.isArray(relationships)) {\r\n        return [];\r\n    }\r\n\r\n    debugLog(` Parsing ${relationships.length} new-format relationships for ${currentCharName}`);\r\n    const parsedTriplets = [];\r\n\r\n    for (const rel of relationships) {\r\n        if (!rel || typeof rel !== 'string') continue;\r\n\r\n        // Parse format: \"Character A is to Character B: relationship1, relationship2\"\r\n        const match = rel.match(/^(.+?)\\s+is\\s+to\\s+(.+?):\\s*(.+)$/i);\r\n        if (!match) {\r\n            debugLog(` Failed to parse relationship format: \"${rel}\"`);\r\n            continue;\r\n        }\r\n\r\n        const [, char1, char2, relationshipsPart] = match;\r\n        const char1Trimmed = char1.trim();\r\n        const char2Trimmed = char2.trim();\r\n\r\n        // Normalize character names to preferred names\r\n        const normalizedChar1 = findPreferredName(char1Trimmed, allCharacters);\r\n        const normalizedChar2 = findPreferredName(char2Trimmed, allCharacters);\r\n\r\n        if (!normalizedChar1 || !normalizedChar2) {\r\n            debugLog(` Could not normalize names: \"${char1Trimmed}\" -> \"${normalizedChar1}\", \"${char2Trimmed}\" -> \"${normalizedChar2}\"`);\r\n            continue;\r\n        }\r\n\r\n        // Split multiple relationships and create individual triplets\r\n        const relationshipTypes = relationshipsPart.split(',').map(r => r.trim());\r\n\r\n        for (const relType of relationshipTypes) {\r\n            if (relType) {\r\n                const triplet = `${normalizedChar1}, ${normalizedChar2}, ${relType.toLowerCase()}`;\r\n                parsedTriplets.push(triplet);\r\n                debugLog(` Parsed: \"${rel}\" -> \"${triplet}\"`);\r\n            }\r\n        }\r\n    }\r\n\r\n    debugLog(` Converted ${relationships.length} relationships to ${parsedTriplets.length} triplets`);\r\n    return parsedTriplets;\r\n}\r\n/**\r\n * Normalize and deduplicate relationships while preserving \"is to\" format\r\n * @param {Array<string>} relationships - Raw relationship strings from LLM\r\n * @param {string} currentCharName - Name of the current character\r\n * @param {Object} allCharacters - All known characters for name resolution\r\n * @returns {Array<string>} Cleaned \"is to\" format relationships\r\n */\r\nfunction rationalizeRelationships(relationships, currentCharName, allCharacters) {\r\n    if (!relationships || !Array.isArray(relationships)) {\r\n        return [];\r\n    }\r\n\r\n    debugLog(` Rationalizing ${relationships.length} relationships for ${currentCharName}`);\r\n\r\n    // Check if we have \"is to\" format\r\n    const hasIsToFormat = relationships.some(rel => typeof rel === 'string' && /\\s+is\\s+to\\s+.+:/.test(rel));\r\n\r\n    if (!hasIsToFormat) {\r\n        debugLog(' WARNING: No \"is to\" format detected. Expected format: \"[Name] is to [Name]: [role]\"');\r\n        return [];\r\n    }\r\n\r\n    // Parse and normalize to \"is to\" format with canonical names\r\n    const normalized = parseNewRelationshipFormat(relationships, currentCharName, allCharacters);\r\n\r\n    if (normalized.length === 0) {\r\n        debugLog(' No valid relationships found after parsing');\r\n        return [];\r\n    }\r\n\r\n    // Deduplicate exact matches (case-insensitive)\r\n    const uniqueRelationships = [];\r\n    const seen = new Set();\r\n\r\n    for (const rel of normalized) {\r\n        const normalized_lower = rel.toLowerCase().trim();\r\n        if (!seen.has(normalized_lower)) {\r\n            seen.add(normalized_lower);\r\n            uniqueRelationships.push(rel);\r\n        } else {\r\n            debugLog(` Removed duplicate: \"${rel}\"`);\r\n        }\r\n    }\r\n\r\n    debugLog(` Deduplicated to ${uniqueRelationships.length} unique relationships (from ${normalized.length})`);\r\n\r\n    return uniqueRelationships;\r\n}\r\n\r\n/**\r\n * Find the preferred canonical name for a character\r\n * @param {string} name - Name variant to resolve\r\n * @param {Object} allCharacters - All known characters\r\n * @returns {string|null} Preferred name or null if not found\r\n */\r\nfunction findPreferredName(name, allCharacters) {\r\n    if (!name || !allCharacters) return name;\r\n\r\n    // First, try exact match on preferred names\r\n    for (const [preferredName] of Object.entries(allCharacters)) {\r\n        if (preferredName === name) {\r\n            return preferredName;\r\n        }\r\n    }\r\n\r\n    // Then try aliases\r\n    for (const [preferredName, character] of Object.entries(allCharacters)) {\r\n        if (character.aliases && character.aliases.includes(name)) {\r\n            return preferredName;\r\n        }\r\n    }\r\n\r\n    // Return original if no match found\r\n    return name;\r\n}\r\n\r\n/**\r\n * Rationalize a group of relationships for the same character pair\r\n * Now maintains multiple compatible relationships instead of choosing just one\r\n * @param {Array} relationships - Array of relationship objects for same pair\r\n * @returns {Object|null} Single rationalized relationship or null\r\n */\r\nfunction rationalizeRelationshipGroup(relationships) {\r\n    if (!relationships || relationships.length === 0) return null;\r\n\r\n    const relTypes = relationships.map(r => r.relationship);\r\n    debugLog(` Rationalizing group: [${relTypes.join(', ')}]`);\r\n\r\n    // Deduplication mapping - convert synonyms to canonical forms\r\n    const equivalents = {\r\n        'sexual partner': 'lover',\r\n        'romantic partner': 'lover',\r\n        'boyfriend': 'lover',\r\n        'girlfriend': 'lover',\r\n        'husband': 'spouse',\r\n        'wife': 'spouse',\r\n        'father': 'parent',\r\n        'mother': 'parent',\r\n        'son': 'child',\r\n        'daughter': 'child',\r\n        'brother': 'sibling',\r\n        'sister': 'sibling',\r\n        'manager': 'boss',\r\n        'supervisor': 'boss',\r\n    };\r\n\r\n    // Normalize to canonical forms and remove duplicates\r\n    const normalizedRels = [...new Set(relTypes.map(rel => equivalents[rel] || rel))];\r\n\r\n    // Remove contradictory relationships (keep the first one found)\r\n    const contradictions = [\r\n        ['dominant', 'submissive'],\r\n        ['leader', 'follower'],\r\n        ['boss', 'employee'],\r\n        ['parent', 'child'],\r\n    ];\r\n\r\n    let filteredRels = [...normalizedRels];\r\n    for (const [rel1, rel2] of contradictions) {\r\n        const hasRel1 = filteredRels.includes(rel1);\r\n        const hasRel2 = filteredRels.includes(rel2);\r\n\r\n        if (hasRel1 && hasRel2) {\r\n            // Keep the first one, remove the second\r\n            const index1 = filteredRels.indexOf(rel1);\r\n            const index2 = filteredRels.indexOf(rel2);\r\n\r\n            if (index1 < index2) {\r\n                filteredRels = filteredRels.filter(r => r !== rel2);\r\n                debugLog(` Removed contradictory '${rel2}', kept '${rel1}'`);\r\n            } else {\r\n                filteredRels = filteredRels.filter(r => r !== rel1);\r\n                debugLog(` Removed contradictory '${rel1}', kept '${rel2}'`);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (filteredRels.length === 0) {\r\n        debugLog(' No relationships left after filtering contradictions');\r\n        return null;\r\n    }\r\n\r\n    // Combine multiple relationships with commas (new approach)\r\n    const combinedRelationship = filteredRels.join(', ');\r\n\r\n    debugLog(` Combined relationships: \"${combinedRelationship}\" from [${relTypes.join(', ')}]`);\r\n\r\n    const baseRel = relationships[0];\r\n    return {\r\n        char1: baseRel.char1,\r\n        char2: baseRel.char2,\r\n        relationship: combinedRelationship,\r\n    };\r\n}\r\n\r\n// Substring Matching Thresholds\r\nconst MIN_SUBSTRING_LENGTH = 3;         // Minimum length for substring detection\r\nconst SUBSTRING_MATCH_BONUS = 0.95;     // High confidence for substring matches\r\n\r\n// Character management state\r\nlet undoHistory = []; // Store last 3 merge operations\r\n\r\n/**\r\n * Character data structure\r\n * @typedef {Object} CharacterData\r\n * @property {string} preferredName - The preferred/canonical name\r\n * @property {string[]} aliases - List of alternative names\r\n * @property {string} physicalAge - Physical age description\r\n * @property {string} mentalAge - Mental age description\r\n * @property {string} physical - Physical description\r\n * @property {string} personality - Personality traits\r\n * @property {string} sexuality - Sexual orientation/preferences\r\n * @property {string} raceEthnicity - Race/ethnicity information\r\n * @property {string} roleSkills - Role and skills description\r\n * @property {string[]} relationships - Relationships with other characters\r\n * @property {boolean} ignored - Whether character is ignored\r\n * @property {number} confidence - Confidence score (0-100)\r\n * @property {string|null} lorebookEntryId - Associated lorebook entry ID\r\n * @property {number} lastUpdated - Timestamp of last update\r\n * @property {boolean} isMainChar - Whether this is the main character\r\n */\r\n\r\n/**\r\n * Check if a character is in the ignored list\r\n * @param {string} name - Character name to check\r\n * @returns {boolean} True if character is ignored\r\n */\r\nexport async function isIgnoredCharacter(name) {\r\n    return withErrorBoundary('isIgnoredCharacter', async () => {\r\n        const chars = await getCharacters();\r\n        return Object.values(chars).some(\r\n            char => char.ignored && (char.preferredName === name || char.aliases.includes(name)),\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Find existing character by name or alias\r\n * @param {string} name - Name to search for\r\n * @returns {CharacterData|null} Character data if found, null otherwise\r\n */\r\nexport async function findExistingCharacter(name) {\r\n    return withErrorBoundary('findExistingCharacter', async () => {\r\n        const chars = await getCharacters();\r\n        const found = Object.values(chars).find(\r\n            char => char.preferredName === name || char.aliases.includes(name),\r\n        ) || null;\r\n        debugLog(`[FindChar] Searching for '${name}': ${found ? 'FOUND as ' + found.preferredName : 'NOT FOUND'}`);\r\n        return found;\r\n    });\r\n}\r\n\r\n/**\r\n * Find character by unique ID (UID)\r\n * Required for REC-15 chat lifecycle management and lorebook synchronization\r\n * @param {string} uid - Character UID to search for\r\n * @returns {Promise<CharacterData|null>} Character data if found, null otherwise\r\n */\r\nexport async function findCharacterByUid(uid) {\r\n    return withErrorBoundary('findCharacterByUid', async () => {\r\n        if (!uid) {\r\n            debugLog('[FindChar] No UID provided');\r\n            return null;\r\n        }\r\n\r\n        const chars = await getCharacters();\r\n        const found = Object.values(chars).find(char => char.uid === uid) || null;\r\n        debugLog(`[FindChar] Searching for UID '${uid}': ${found ? 'FOUND as ' + found.preferredName : 'NOT FOUND'}`);\r\n        return found;\r\n    });\r\n}\r\n\r\n/**\r\n * Find potential match for a new character based on confidence threshold\r\n * @param {Object} analyzedChar - Character data from LLM analysis\r\n * @returns {Promise<CharacterData|null>} Potential match if found\r\n */\r\nexport async function findPotentialMatch(analyzedChar) {\r\n    return withErrorBoundary('findPotentialMatch', async () => {\r\n        const chars = await getCharacters();\r\n        // Use the user-configured confidence threshold (0-100)\r\n        const threshold = await getSetting('confidenceThreshold', 70);\r\n\r\n        debug.log();\r\n\r\n        // Simple matching logic - can be enhanced with LLM-based similarity\r\n        for (const existingChar of Object.values(chars)) {\r\n            // Check for name similarity (simple approach)\r\n            const similarity = await calculateNameSimilarity(analyzedChar.name, existingChar.preferredName);\r\n\r\n            if (similarity >= threshold) {\r\n                debug.log();\r\n                return existingChar;\r\n            }\r\n\r\n            // Check aliases\r\n            for (const alias of existingChar.aliases) {\r\n                const aliasSimilarity = await calculateNameSimilarity(analyzedChar.name, alias);\r\n                if (aliasSimilarity >= threshold) {\r\n                    debug.log();\r\n                    return existingChar;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    });\r\n}\r\n\r\n/**\r\n * Calculate simple name similarity (0-100)\r\n * @param {string} name1 - First name to compare\r\n * @param {string} name2 - Second name to compare\r\n * @returns {number} Similarity score 0-100\r\n */\r\nexport function calculateNameSimilarity(name1, name2) {\r\n    return withErrorBoundary('calculateNameSimilarity', () => {\r\n        name1 = name1.toLowerCase();\r\n        name2 = name2.toLowerCase();\r\n\r\n        // Exact match\r\n        if (name1 === name2) {\r\n            return 100;\r\n        }\r\n\r\n        // One contains the other\r\n        if (name1.includes(name2) || name2.includes(name1)) {\r\n            return 85;\r\n        }\r\n\r\n        // Check if they share significant parts\r\n        const words1 = name1.split(/\\s+/);\r\n        const words2 = name2.split(/\\s+/);\r\n\r\n        const commonWords = words1.filter(w => words2.includes(w));\r\n        if (commonWords.length > 0) {\r\n            return 70;\r\n        }\r\n\r\n        // No significant similarity\r\n        return 0;\r\n    });\r\n}\r\n\r\n/**\r\n * Filter and clean aliases\r\n * Removes character's own name, relationship words, and other invalid aliases\r\n * @param {string[]} aliases - Array of alias strings\r\n * @param {string} characterName - The character's actual name\r\n * @returns {string[]} Cleaned array of unique aliases\r\n */\r\nexport function cleanAliases(aliases, characterName) {\r\n    return withErrorBoundary('cleanAliases', () => {\r\n        if (!aliases || !Array.isArray(aliases)) {\r\n            return [];\r\n        }\r\n\r\n        // Common relationship/role words that shouldn't be aliases\r\n        const invalidAliases = [\r\n            'son', 'daughter', 'mother', 'father', 'mom', 'dad', 'parent',\r\n            'brother', 'sister', 'sibling', 'cousin', 'uncle', 'aunt',\r\n            'friend', 'boyfriend', 'girlfriend', 'husband', 'wife', 'spouse',\r\n            'boss', 'employee', 'coworker', 'colleague', 'partner',\r\n            'neighbor', 'roommate', 'child', 'kid', 'baby',\r\n            'man', 'woman', 'person', 'guy', 'girl', 'boy',\r\n            'user', '{{user}}', 'char', '{{char}}',\r\n        ];\r\n\r\n        const lowerName = characterName.toLowerCase();\r\n\r\n        return aliases.filter(alias => {\r\n            if (!alias || typeof alias !== 'string') return false;\r\n\r\n            const lowerAlias = alias.trim().toLowerCase();\r\n\r\n            // Remove if it's the character's own name\r\n            if (lowerAlias === lowerName) return false;\r\n\r\n            // Remove if it's just a relationship word\r\n            if (invalidAliases.includes(lowerAlias)) return false;\r\n\r\n            // Remove if it's too short (likely not a real alias)\r\n            if (lowerAlias.length < 2) return false;\r\n\r\n            return true;\r\n        })\r\n            .map(alias => alias.trim()) // Trim whitespace\r\n            .filter((alias, index, self) => self.indexOf(alias) === index); // Remove duplicates\r\n    });\r\n}\r\n\r\n// ============================================================================\r\n// MERGE DETECTION AND CONFIDENCE SCORING\r\n// ============================================================================\r\n\r\n/**\r\n * Detect potential merge opportunities for a new character\r\n * Finds existing characters that might be the same person with different names\r\n * @param {string} newCharacterName - Name of the newly discovered character\r\n * @returns {Array} Array of potential merge targets with confidence scores\r\n */\r\nexport async function detectMergeOpportunities(newCharacterName) {\r\n    return withErrorBoundary('detectMergeOpportunities', async () => {\r\n        debugLog(`[MergeDetect] Checking merge opportunities for: ${newCharacterName}`);\r\n\r\n        const potentialMatches = [];\r\n        const existingCharacters = await getCharacters();\r\n\r\n        if (!newCharacterName || typeof newCharacterName !== 'string') {\r\n            debugLog('[MergeDetect] Invalid name provided');\r\n            return potentialMatches;\r\n        }\r\n\r\n        // eslint-disable-next-line no-unused-vars\r\n        for (const [_existingName, existingChar] of Object.entries(existingCharacters)) {\r\n            const confidence = calculateMergeConfidence(newCharacterName, existingChar);\r\n\r\n            if (confidence >= MERGE_CONFIDENCE_MEDIUM) {\r\n                const tier = confidence >= MERGE_CONFIDENCE_HIGH ? 'HIGH' : 'MEDIUM';\r\n                const reason = generateMergeReason(newCharacterName, existingChar, confidence);\r\n                potentialMatches.push({\r\n                    targetName: existingChar.preferredName,\r\n                    confidence: confidence,\r\n                    tier: tier,\r\n                    reason: reason,\r\n                });\r\n                debugLog(`[MergeDetect] ${newCharacterName} -> ${existingChar.preferredName}: ${tier} (${Math.round(confidence * 100)}%) - ${reason}`);\r\n            }\r\n        }\r\n\r\n        // Sort by confidence descending\r\n        potentialMatches.sort((a, b) => b.confidence - a.confidence);\r\n\r\n        debugLog(`[MergeDetect] Total merge candidates for ${newCharacterName}: ${potentialMatches.length}`);\r\n\r\n        return potentialMatches;\r\n    }, []);\r\n}\r\n\r\n/**\r\n * Calculate merge confidence between two character names\r\n * Returns value 0-1 (0-100%)\r\n * @private\r\n */\r\nfunction calculateMergeConfidence(newName, existingChar) {\r\n    debugLog(`[CalcConfidence] Comparing '${newName}' vs '${existingChar.preferredName}'`);\r\n\r\n    const existingName = existingChar.preferredName;\r\n    let confidence = 0;\r\n\r\n    // Check for exact substring match (e.g., \"Jazz\" in \"Jasmine\")\r\n    if (isSubstringMatch(newName, existingName)) {\r\n        confidence = SUBSTRING_MATCH_BONUS;\r\n        debugLog('[CalcConfidence] Substring match detected');\r\n    }\r\n    // Check if new name matches any existing alias\r\n    else if (existingChar.aliases && existingChar.aliases.some(alias =>\r\n        newName.toLowerCase() === alias.toLowerCase())) {\r\n        confidence = 0.95;\r\n    }\r\n    // Check for phonetic similarity\r\n    else if (isPhoneticSimilar(newName, existingName)) {\r\n        confidence = 0.8;\r\n    }\r\n    // Check for partial similarity\r\n    else if (isPartialMatch(newName, existingName)) {\r\n        confidence = 0.65;\r\n    }\r\n\r\n    return confidence;\r\n}\r\n\r\n/**\r\n * Check if newName is a substring of existingName (or vice versa)\r\n * Used for detecting nickname relationships like \"Jazz\" for \"Jasmine\"\r\n * @private\r\n */\r\nfunction isSubstringMatch(newName, existingName) {\r\n    const newLower = newName.toLowerCase();\r\n    const existLower = existingName.toLowerCase();\r\n\r\n    // Check if one is a substring of the other, and long enough to be meaningful\r\n    if (newName.length >= MIN_SUBSTRING_LENGTH) {\r\n        return existLower.includes(newLower) || newLower.includes(existLower);\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Basic phonetic similarity check using Levenshtein distance\r\n * @private\r\n */\r\nfunction isPhoneticSimilar(str1, str2) {\r\n    const distance = levenshteinDistance(str1.toLowerCase(), str2.toLowerCase());\r\n    const maxLength = Math.max(str1.length, str2.length);\r\n    const similarity = 1 - (distance / maxLength);\r\n\r\n    // Consider similar if >75% match\r\n    return similarity >= 0.75;\r\n}\r\n\r\n/**\r\n * Check for partial name match (e.g., first/last name components)\r\n * @private\r\n */\r\nfunction isPartialMatch(newName, existingName) {\r\n    const newParts = newName.toLowerCase().split(/\\s+/);\r\n    const existParts = existingName.toLowerCase().split(/\\s+/);\r\n\r\n    // Check if any part of new name matches parts of existing\r\n    return newParts.some(newPart => existParts.some(existPart =>\r\n        newPart === existPart && newPart.length > 2,\r\n    ));\r\n}\r\n\r\n/**\r\n * Calculate Levenshtein distance between two strings\r\n * @private\r\n */\r\nfunction levenshteinDistance(str1, str2) {\r\n    const track = Array(str2.length + 1).fill(null).map(() =>\r\n        Array(str1.length + 1).fill(null),\r\n    );\r\n\r\n    for (let i = 0; i <= str1.length; i++) {\r\n        track[0][i] = i;\r\n    }\r\n\r\n    for (let j = 0; j <= str2.length; j++) {\r\n        track[j][0] = j;\r\n    }\r\n\r\n    for (let j = 1; j <= str2.length; j++) {\r\n        for (let i = 1; i <= str1.length; i++) {\r\n            const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;\r\n            track[j][i] = Math.min(\r\n                track[j][i - 1] + 1,\r\n                track[j - 1][i] + 1,\r\n                track[j - 1][i - 1] + indicator,\r\n            );\r\n        }\r\n    }\r\n\r\n    return track[str2.length][str1.length];\r\n}\r\n\r\n/**\r\n * Generate human-readable reason for merge suggestion\r\n * @private\r\n */\r\nfunction generateMergeReason(newName, existingChar, confidence) {\r\n    if (confidence >= MERGE_CONFIDENCE_HIGH) {\r\n        if (newName.toLowerCase().includes(existingChar.preferredName.toLowerCase())) {\r\n            return `\"${newName}\" contains \"${existingChar.preferredName}\" (likely nickname)`;\r\n        }\r\n        return `Exact match confidence: ${(confidence * 100).toFixed(0)}%`;\r\n    }\r\n\r\n    return `Phonetic/partial match with confidence: ${(confidence * 100).toFixed(0)}%`;\r\n}\r\n\r\n/**\r\n * Create a new character entry\r\nantml:parameter>\r\n\r\n * @param {Object} analyzedChar - Character data from LLM analysis\r\n * @param {boolean} isMainChar - Whether this is the main character\r\n * @returns {Promise<CharacterData>} Created character data\r\n */\r\nexport async function createCharacter(analyzedChar, isMainChar = false) {\r\n    return withErrorBoundary('createCharacter', async () => {\r\n        debug.log();\r\n        console.log('[NT-Characters]  createCharacter() called for:', analyzedChar.name);\r\n\r\n        // Get all characters for relationship normalization\r\n        const allCharacters = await getCharacters();\r\n\r\n        // Validate and clean character data from LLM\r\n        const cleanedChar = validateCharacterData(analyzedChar, allCharacters);\r\n\r\n        // Clean and filter aliases\r\n        const aliases = await cleanAliases(cleanedChar.aliases || [], cleanedChar.name);\r\n\r\n        const character = {\r\n            preferredName: cleanedChar.name,\r\n            aliases: aliases,\r\n            physicalAge: cleanedChar.physicalAge || '',\r\n            mentalAge: cleanedChar.mentalAge || '',\r\n            physical: cleanedChar.physical || '',\r\n            personality: cleanedChar.personality || '',\r\n            sexuality: cleanedChar.sexuality || '',\r\n            raceEthnicity: cleanedChar.raceEthnicity || '',\r\n            roleSkills: cleanedChar.roleSkills || '',\r\n            relationships: (() => {\r\n                const rawRels = cleanedChar.relationships || [];\r\n                console.log(`[NT-Characters]  Processing relationships for ${cleanedChar.name}:`);\r\n                console.log(`[NT-Characters]    Raw relationships:`, JSON.stringify(rawRels, null, 2));\r\n                \r\n                const normalized = rationalizeRelationships(rawRels, cleanedChar.name, allCharacters);\r\n                \r\n                console.log(`[NT-Characters]    Raw count: ${rawRels.length}`);\r\n                console.log(`[NT-Characters]    Normalized count: ${normalized.length}`);\r\n                console.log(`[NT-Characters]    Normalized relationships:`, JSON.stringify(normalized, null, 2));\r\n                \r\n                if (normalized.length > 0) {\r\n                    console.log(`[NT-Characters]    Sample normalized: ${normalized[0]}`);\r\n                }\r\n                return normalized;\r\n            })(),\r\n            ignored: false,\r\n            confidence: cleanedChar.confidence || 50,\r\n            lorebookEntryId: null,\r\n            lastUpdated: Date.now(),\r\n            isMainChar: isMainChar || false,\r\n            needsReview: true,  // New characters always need review\r\n        };\r\n\r\n        debug.log();\r\n\r\n        // Store character in settings - CRITICAL: AWAIT to ensure save completes\r\n        await setCharacter(character.preferredName, character);\r\n        console.log('[NT-Characters]  Created and saved character:', character.preferredName);\r\n\r\n        // Create lorebook entry and ensure ID is saved\r\n        await updateLorebookEntry(character, character.preferredName);\r\n\r\n        // Verify lorebook entry was created successfully\r\n        if (!character.lorebookEntryId) {\r\n            console.warn(`[NT-Characters]  Lorebook entry creation may have failed for: ${character.preferredName}`);\r\n        } else {\r\n            debugLog(` Lorebook entry created with ID: ${character.lorebookEntryId}`);\r\n        }\r\n\r\n        debug.log();\r\n\r\n        return character;\r\n    });\r\n}\r\n\r\n/**\r\n * Update existing character with new information\r\n * @param {CharacterData} existingChar - Existing character data\r\n * @param {Object} analyzedChar - New character data from LLM analysis\r\n * @param {boolean} addAsAlias - Whether to add the analyzed name as an alias\r\n * @param {boolean} isMainChar - Whether this is the main character\r\n * @returns {Promise<CharacterData>} Updated character data\r\n */\r\nexport async function updateCharacter(existingChar, analyzedChar, addAsAlias = false, isMainChar = false) {\r\n    return withErrorBoundary('updateCharacter', async () => {\r\n        debug.log();\r\n\r\n        // Get all characters for relationship normalization\r\n        const allCharacters = await getCharacters();\r\n\r\n        // Validate and clean new character data from LLM\r\n        const cleanedChar = validateCharacterData(analyzedChar, allCharacters);\r\n\r\n        // Mark as main character if detected\r\n        if (isMainChar) {\r\n            existingChar.isMainChar = true;\r\n        }\r\n\r\n        // If adding as alias, add the analyzed name to aliases if not already present\r\n        if (addAsAlias && cleanedChar.name !== existingChar.preferredName) {\r\n            if (!existingChar.aliases) existingChar.aliases = [];\r\n            if (!existingChar.aliases.includes(cleanedChar.name) &&\r\n                cleanedChar.name.toLowerCase() !== existingChar.preferredName.toLowerCase()) {\r\n                existingChar.aliases.push(cleanedChar.name);\r\n            }\r\n        }\r\n\r\n        // Clean up all aliases using the helper function\r\n        existingChar.aliases = await cleanAliases(existingChar.aliases || [], existingChar.preferredName);\r\n\r\n        // Update consolidated fields (new data takes precedence if not empty)\r\n        if (cleanedChar.physicalAge) existingChar.physicalAge = cleanedChar.physicalAge;\r\n        if (cleanedChar.mentalAge) existingChar.mentalAge = cleanedChar.mentalAge;\r\n        if (cleanedChar.physical) existingChar.physical = cleanedChar.physical;\r\n        if (cleanedChar.personality) existingChar.personality = cleanedChar.personality;\r\n        if (cleanedChar.sexuality) existingChar.sexuality = cleanedChar.sexuality;\r\n        if (cleanedChar.raceEthnicity) existingChar.raceEthnicity = cleanedChar.raceEthnicity;\r\n        if (cleanedChar.roleSkills) existingChar.roleSkills = cleanedChar.roleSkills;\r\n\r\n        // Merge relationships array - deduplicate and filter to valid triplets\r\n        if (cleanedChar.relationships && Array.isArray(cleanedChar.relationships)) {\r\n            if (!existingChar.relationships) existingChar.relationships = [];\r\n            for (const rel of cleanedChar.relationships) {\r\n                if (!existingChar.relationships.includes(rel)) {\r\n                    existingChar.relationships.push(rel);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update confidence (average of old and new)\r\n        if (cleanedChar.confidence) {\r\n            existingChar.confidence = Math.round((existingChar.confidence + cleanedChar.confidence) / 2);\r\n        }\r\n\r\n        existingChar.lastUpdated = Date.now();\r\n        existingChar.needsReview = true;  // Updated characters need review\r\n\r\n        // Update character in settings - AWAIT to ensure save completes\r\n        await setCharacter(existingChar.preferredName, existingChar);\r\n        console.log('[NT-Characters]  Updated and saved character:', existingChar.preferredName);\r\n\r\n        debug.log();\r\n\r\n        return existingChar;\r\n    });\r\n}\r\n\r\n/**\r\n * Merge two characters\r\n * @param {string} sourceName - Name of character to merge from\r\n * @param {string} targetName - Name of character to merge into\r\n * @returns {Promise<void>}\r\n */\r\nexport async function mergeCharacters(sourceName, targetName) {\r\n    return withErrorBoundary('mergeCharacters', async () => {\r\n        const chars = await getCharacters();\r\n\r\n        const sourceChar = chars[sourceName];\r\n        const targetChar = chars[targetName];\r\n\r\n        if (!sourceChar || !targetChar) {\r\n            throw new NameTrackerError('One or both characters not found');\r\n        }\r\n\r\n        // Store for undo\r\n        const undoData = {\r\n            operation: 'merge',\r\n            timestamp: Date.now(),\r\n            sourceName: sourceName,\r\n            targetName: targetName,\r\n            sourceData: JSON.parse(JSON.stringify(sourceChar)),\r\n            targetDataBefore: JSON.parse(JSON.stringify(targetChar)),\r\n        };\r\n\r\n        // Add to undo history\r\n        undoHistory.push(undoData);\r\n        if (undoHistory.length > 3) {\r\n            undoHistory.shift();\r\n        }\r\n\r\n        // Merge aliases\r\n        for (const alias of sourceChar.aliases) {\r\n            if (!targetChar.aliases.includes(alias)) {\r\n                targetChar.aliases.push(alias);\r\n            }\r\n        }\r\n\r\n        // Add source name as alias if not the same\r\n        if (sourceChar.preferredName !== targetChar.preferredName &&\r\n            !targetChar.aliases.includes(sourceChar.preferredName)) {\r\n            targetChar.aliases.push(sourceChar.preferredName);\r\n        }\r\n\r\n        // Merge fields (target takes precedence for conflicts, but add new fields)\r\n        if (sourceChar.physicalAge && !targetChar.physicalAge) targetChar.physicalAge = sourceChar.physicalAge;\r\n        if (sourceChar.mentalAge && !targetChar.mentalAge) targetChar.mentalAge = sourceChar.mentalAge;\r\n        if (sourceChar.physical && !targetChar.physical) targetChar.physical = sourceChar.physical;\r\n        if (sourceChar.personality && !targetChar.personality) targetChar.personality = sourceChar.personality;\r\n        if (sourceChar.sexuality && !targetChar.sexuality) targetChar.sexuality = sourceChar.sexuality;\r\n        if (sourceChar.raceEthnicity && !targetChar.raceEthnicity) targetChar.raceEthnicity = sourceChar.raceEthnicity;\r\n        if (sourceChar.roleSkills && !targetChar.roleSkills) targetChar.roleSkills = sourceChar.roleSkills;\r\n\r\n        // Merge relationships\r\n        for (const rel of sourceChar.relationships) {\r\n            if (!targetChar.relationships.includes(rel)) {\r\n                targetChar.relationships.push(rel);\r\n            }\r\n        }\r\n\r\n        // Update timestamp\r\n        targetChar.lastUpdated = Date.now();\r\n\r\n        // Update target character and delete source - AWAIT both\r\n        await setCharacter(targetChar.preferredName, targetChar);\r\n        await removeCharacter(sourceName);\r\n\r\n        // Save chat data\r\n        // Auto-saved by new settings system\r\n\r\n        debug.log();\r\n        notifications.success(`Merged ${sourceName} into ${targetName}`);\r\n\r\n        return undoData;\r\n    });\r\n}\r\n\r\n/**\r\n * Undo last merge operation\r\n * @returns {Promise<boolean>} True if undo was successful\r\n */\r\nexport async function undoLastMerge() {\r\n    return withErrorBoundary('undoLastMerge', async () => {\r\n        if (undoHistory.length === 0) {\r\n            notifications.warning('No merge operations to undo');\r\n            return false;\r\n        }\r\n\r\n        const lastOp = undoHistory.pop();\r\n\r\n        if (lastOp.operation !== 'merge') {\r\n            notifications.error('Last operation was not a merge');\r\n            return false;\r\n        }\r\n\r\n        // Restore source character - AWAIT\r\n        await setCharacter(lastOp.sourceName, lastOp.sourceData);\r\n\r\n        // Restore target character to pre-merge state - AWAIT\r\n        await setCharacter(lastOp.targetName, lastOp.targetDataBefore);\r\n\r\n        debug.log();\r\n        notifications.success('Merge undone successfully');\r\n\r\n        return true;\r\n    });\r\n}\r\n\r\n/**\r\n * Toggle ignore status for a character\r\n * @param {string} characterName - Name of character to toggle\r\n * @returns {boolean} New ignore status\r\n */\r\nexport async function toggleIgnoreCharacter(characterName) {\r\n    return withErrorBoundary('toggleIgnoreCharacter', async () => {\r\n        const character = await getCharacter(characterName);\r\n\r\n        if (!character) {\r\n            throw new NameTrackerError('Character not found');\r\n        }\r\n\r\n        character.ignored = !character.ignored;\r\n\r\n        await setCharacter(characterName, character);\r\n\r\n        // Save chat data\r\n        // Auto-saved by new settings system\r\n\r\n        const status = character.ignored ? 'ignored' : 'unignored';\r\n        notifications.info(`${characterName} ${status}`);\r\n        debug.log();\r\n\r\n        return character.ignored;\r\n    });\r\n}\r\n\r\n/**\r\n * Manually create a new character\r\n * @param {string} characterName - Name of new character\r\n * @returns {Promise<CharacterData>} Created character\r\n */\r\nexport async function createNewCharacter(characterName) {\r\n    return withErrorBoundary('createNewCharacter', async () => {\r\n        if (!characterName || !characterName.trim()) {\r\n            throw new NameTrackerError('Character name is required');\r\n        }\r\n\r\n        const trimmedName = characterName.trim();\r\n\r\n        // Check if character already exists\r\n        if (await getCharacter(trimmedName)) {\r\n            throw new NameTrackerError(`Character \"${trimmedName}\" already exists`);\r\n        }\r\n\r\n        // Create basic character structure\r\n        const newChar = {\r\n            name: trimmedName,\r\n            aliases: [],\r\n            physicalAge: '',\r\n            mentalAge: '',\r\n            physical: '',\r\n            personality: '',\r\n            sexuality: '',\r\n            raceEthnicity: '',\r\n            roleSkills: '',\r\n            relationships: [],\r\n            confidence: 100, // Manually created = 100% confidence\r\n        };\r\n\r\n        const character = await createCharacter(newChar, false);\r\n\r\n        // Save chat data\r\n        // Auto-saved by new settings system\r\n\r\n        debug.log();\r\n        notifications.success(`Created character: ${trimmedName}`);\r\n\r\n        return character;\r\n    });\r\n}\r\n\r\n/**\r\n * Purge all character entries\r\n * @returns {Promise<number>} Number of characters purged\r\n */\r\nexport async function purgeAllCharacters() {\r\n    return withErrorBoundary('purgeAllCharacters', async () => {\r\n        const chars = await getCharacters();\r\n        const characterCount = Object.keys(chars).length;\r\n\r\n        if (characterCount === 0) {\r\n            notifications.info('No characters to purge');\r\n            return 0;\r\n        }\r\n\r\n        // Clear all character data\r\n        await set_chat_metadata('characters', {});\r\n\r\n        // Clear undo history\r\n        undoHistory = [];\r\n\r\n        debug.log();\r\n        notifications.success(`Purged ${characterCount} characters`);\r\n\r\n        return characterCount;\r\n    });\r\n}\r\n\r\n/**\r\n * Check if character has unresolved relationships\r\n * @param {CharacterData} character - Character to check\r\n * @returns {boolean} True if character has relationships to unknown characters\r\n */\r\nexport async function hasUnresolvedRelationships(character) {\r\n    return withErrorBoundary('hasUnresolvedRelationships', async () => {\r\n        if (!character.relationships || character.relationships.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        const chars = await getCharacters();\r\n        const knownNames = Object.values(chars).reduce((names, char) => {\r\n            names.add(char.preferredName.toLowerCase());\r\n            char.aliases.forEach(alias => names.add(alias.toLowerCase()));\r\n            return names;\r\n        }, new Set());\r\n\r\n        return character.relationships.some(rel => {\r\n            // Simple check - extract character names from relationship strings\r\n            const words = rel.toLowerCase().split(/\\s+/);\r\n            return words.some(word => {\r\n                return word.length > 2 && !knownNames.has(word);\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * Get undo history\r\n * @returns {Array} Array of undo operations\r\n */\r\nexport function getUndoHistory() {\r\n    return [...undoHistory];\r\n}\r\n\r\n/**\r\n * Clear undo history\r\n */\r\nexport function clearUndoHistory() {\r\n    undoHistory = [];\r\n    debug.log();\r\n}\r\n\r\n/**\r\n * Export all characters as JSON\r\n * @returns {Object} Character data\r\n */\r\nexport async function exportCharacters() {\r\n    return withErrorBoundary('exportCharacters', async () => {\r\n        return await getCharacters();\r\n    });\r\n}\r\n\r\n/**\r\n * Import characters from JSON\r\n * @param {Object} characterData - Character data to import\r\n * @param {boolean} merge - Whether to merge with existing characters\r\n * @returns {Promise<number>} Number of characters imported\r\n */\r\nexport async function importCharacters(characterData, merge = false) {\r\n    return withErrorBoundary('importCharacters', async () => {\r\n        if (!characterData || typeof characterData !== 'object') {\r\n            throw new NameTrackerError('Invalid character data');\r\n        }\r\n\r\n        let importCount = 0;\r\n\r\n        for (const [name, character] of Object.entries(characterData)) {\r\n            if (merge || !await getCharacter(name)) {\r\n                await setCharacter(name, character);\r\n                importCount++;\r\n            }\r\n        }\r\n\r\n        debug.log();\r\n        notifications.success(`Imported ${importCount} characters`);\r\n\r\n        return importCount;\r\n    });\r\n}\r\n","\"use strict\";\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;","/**\r\n * Notification utilities for Name Tracker extension\r\n * Centralizes toastr notifications with consistent styling\r\n */\r\n\r\nimport debugLogger from '../core/debug.js';\r\n\r\nconst logger = debugLogger.createModuleLogger('Notifications');\r\n\r\nclass NotificationManager {\r\n    constructor() {\r\n        this.defaultOptions = {\r\n            timeOut: 5000,\r\n            extendedTimeOut: 2000,\r\n            closeButton: true,\r\n            progressBar: true,\r\n            preventDuplicates: true,\r\n        };\r\n\r\n        this.prefix = 'Name Tracker: ';\r\n    }\r\n\r\n    /**\r\n     * Show success notification\r\n     * @param {string} message - Message to display\r\n     * @param {string} title - Optional title\r\n     * @param {Object} options - Toastr options\r\n     */\r\n    success(message, title = 'Success', options = {}) {\r\n        const opts = { ...this.defaultOptions, ...options };\r\n        toastr.success(this.prefix + message, title, opts);\r\n        logger.debug('Success notification:', message);\r\n    }\r\n\r\n    /**\r\n     * Show info notification\r\n     * @param {string} message - Message to display\r\n     * @param {string} title - Optional title\r\n     * @param {Object} options - Toastr options\r\n     */\r\n    info(message, title = 'Info', options = {}) {\r\n        const opts = { ...this.defaultOptions, ...options };\r\n        toastr.info(this.prefix + message, title, opts);\r\n        logger.debug('Info notification:', message);\r\n    }\r\n\r\n    /**\r\n     * Show warning notification\r\n     * @param {string} message - Message to display\r\n     * @param {string} title - Optional title\r\n     * @param {Object} options - Toastr options\r\n     */\r\n    warning(message, title = 'Warning', options = {}) {\r\n        const opts = { ...this.defaultOptions, timeOut: 8000, ...options };\r\n        toastr.warning(this.prefix + message, title, opts);\r\n        logger.debug('Warning notification:', message);\r\n    }\r\n\r\n    /**\r\n     * Show error notification\r\n     * @param {string} message - Message to display\r\n     * @param {string} title - Optional title\r\n     * @param {Object} options - Toastr options\r\n     */\r\n    error(message, title = 'Error', options = {}) {\r\n        const opts = {\r\n            ...this.defaultOptions,\r\n            timeOut: 10000,\r\n            extendedTimeOut: 5000,\r\n            ...options,\r\n        };\r\n        toastr.error(this.prefix + message, title, opts);\r\n        logger.error('Error notification:', message);\r\n    }\r\n\r\n    /**\r\n     * Show persistent notification that doesn't auto-close\r\n     * @param {string} message - Message to display\r\n     * @param {string} title - Optional title\r\n     * @param {string} type - Notification type (info, success, warning, error)\r\n     */\r\n    persistent(message, title = 'Notice', type = 'info') {\r\n        const opts = {\r\n            ...this.defaultOptions,\r\n            timeOut: 0,\r\n            extendedTimeOut: 0,\r\n        };\r\n\r\n        switch (type) {\r\n            case 'success':\r\n                toastr.success(this.prefix + message, title, opts);\r\n                break;\r\n            case 'warning':\r\n                toastr.warning(this.prefix + message, title, opts);\r\n                break;\r\n            case 'error':\r\n                toastr.error(this.prefix + message, title, opts);\r\n                break;\r\n            default:\r\n                toastr.info(this.prefix + message, title, opts);\r\n        }\r\n\r\n        logger.debug('Persistent notification:', message);\r\n    }\r\n\r\n    /**\r\n     * Show progress notification for long operations\r\n     * @param {string} message - Message to display\r\n     * @param {number} progress - Progress percentage (0-100)\r\n     * @param {string} id - Unique ID for updating the same notification\r\n     * @returns {string} Notification ID for updates\r\n     */\r\n    progress(message, progress = 0, id = null) {\r\n        const notificationId = id || `progress_${Date.now()}`;\r\n        const progressHtml = `\r\n            <div style=\"margin-bottom: 8px;\">${this.prefix}${message}</div>\r\n            <div style=\"background: #333; border-radius: 3px; overflow: hidden;\">\r\n                <div style=\"background: #007acc; height: 6px; width: ${progress}%; transition: width 0.3s ease;\"></div>\r\n            </div>\r\n            <div style=\"text-align: center; font-size: 11px; margin-top: 4px;\">${progress}%</div>\r\n        `;\r\n\r\n        const opts = {\r\n            timeOut: 0,\r\n            extendedTimeOut: 0,\r\n            closeButton: false,\r\n            progressBar: false,\r\n            preventDuplicates: false,\r\n            toastId: notificationId,\r\n        };\r\n\r\n        // Remove existing notification with same ID\r\n        toastr.remove();\r\n\r\n        toastr.info(progressHtml, '', opts);\r\n        logger.debug('Progress notification:', message, `${progress}%`);\r\n\r\n        return notificationId;\r\n    }\r\n\r\n    /**\r\n     * Clear all notifications\r\n     */\r\n    clear() {\r\n        toastr.clear();\r\n        logger.debug('Cleared all notifications');\r\n    }\r\n\r\n    /**\r\n     * Show a confirmation-style notification with action buttons\r\n     * @param {string} message - Message to display\r\n     * @param {Function} onConfirm - Callback for confirm action\r\n     * @param {Function} onCancel - Callback for cancel action\r\n     * @param {string} title - Optional title\r\n     */\r\n    confirm(message, onConfirm, onCancel = null, title = 'Confirm') {\r\n        const confirmId = `confirm_${Date.now()}`;\r\n        const confirmHtml = `\r\n            <div style=\"margin-bottom: 12px;\">${message}</div>\r\n            <div style=\"text-align: right;\">\r\n                <button class=\"btn btn-sm btn-secondary me-2\" onclick=\"nameTrackerNotifications.handleConfirmCancel('${confirmId}')\">Cancel</button>\r\n                <button class=\"btn btn-sm btn-primary\" onclick=\"nameTrackerNotifications.handleConfirmOk('${confirmId}')\">Confirm</button>\r\n            </div>\r\n        `;\r\n\r\n        // Store callbacks globally for onclick handlers\r\n        window.nameTrackerNotifications = window.nameTrackerNotifications || {};\r\n        window.nameTrackerNotifications.confirmCallbacks = window.nameTrackerNotifications.confirmCallbacks || {};\r\n        window.nameTrackerNotifications.confirmCallbacks[confirmId] = { onConfirm, onCancel };\r\n\r\n        window.nameTrackerNotifications.handleConfirmOk = (id) => {\r\n            const callbacks = window.nameTrackerNotifications.confirmCallbacks[id];\r\n            if (callbacks && callbacks.onConfirm) {\r\n                callbacks.onConfirm();\r\n            }\r\n            delete window.nameTrackerNotifications.confirmCallbacks[id];\r\n            toastr.clear();\r\n        };\r\n\r\n        window.nameTrackerNotifications.handleConfirmCancel = (id) => {\r\n            const callbacks = window.nameTrackerNotifications.confirmCallbacks[id];\r\n            if (callbacks && callbacks.onCancel) {\r\n                callbacks.onCancel();\r\n            }\r\n            delete window.nameTrackerNotifications.confirmCallbacks[id];\r\n            toastr.clear();\r\n        };\r\n\r\n        const opts = {\r\n            timeOut: 0,\r\n            extendedTimeOut: 0,\r\n            closeButton: false,\r\n            progressBar: false,\r\n            preventDuplicates: false,\r\n            toastId: confirmId,\r\n        };\r\n\r\n        toastr.info(confirmHtml, this.prefix + title, opts);\r\n        logger.debug('Confirmation notification:', message);\r\n\r\n        return confirmId;\r\n    }\r\n\r\n    /**\r\n     * Get notification status for debugging\r\n     * @returns {Object} Status information\r\n     */\r\n    getStatus() {\r\n        return {\r\n            defaultOptions: this.defaultOptions,\r\n            prefix: this.prefix,\r\n            activeConfirms: Object.keys(window.nameTrackerNotifications?.confirmCallbacks || {}).length,\r\n        };\r\n    }\r\n}\r\n\r\n// Create singleton instance\r\nconst notifications = new NotificationManager();\r\n\r\nlogger.debug('Notifications module loaded');\r\n\r\nexport { NotificationManager };\r\nexport default notifications;\r\n","/**\r\n * Debug and logging utilities for Name Tracker extension\r\n * Provides module-specific logging, performance monitoring, and state inspection\r\n */\r\n\r\nconst MODULE_NAME = 'NT';\r\n\r\nclass DebugLogger {\r\n    constructor() {\r\n        this.modules = new Map();\r\n        this.performanceMarks = new Map();\r\n        this.operationTraces = new Map();\r\n    }\r\n\r\n    /**\r\n     * Create a module-specific logger\r\n     * @param {string} moduleName - Name of the module\r\n     * @returns {Object} Logger instance with module-specific methods\r\n     */\r\n    createModuleLogger(moduleName) {\r\n        if (this.modules.has(moduleName)) {\r\n            return this.modules.get(moduleName);\r\n        }\r\n\r\n        const logger = {\r\n            log: (...args) => this.log(moduleName, 'log', ...args),\r\n            warn: (...args) => this.log(moduleName, 'warn', ...args),\r\n            error: (...args) => this.log(moduleName, 'error', ...args),\r\n            debug: (...args) => this.log(moduleName, 'debug', ...args),\r\n            trace: (operationId, message) => this.addTrace(moduleName, operationId, message),\r\n            startTimer: (timerName) => this.startTimer(moduleName, timerName),\r\n            endTimer: (timerName) => this.endTimer(moduleName, timerName),\r\n        };\r\n\r\n        this.modules.set(moduleName, logger);\r\n        return logger;\r\n    }\r\n\r\n    /**\r\n     * Internal logging method\r\n     * @param {string} moduleName - Module name\r\n     * @param {string} level - Log level\r\n     * @param {...any} args - Arguments to log\r\n     */\r\n    log(moduleName, level, ...args) {\r\n        if (!this.isDebugEnabled()) {\r\n            return;\r\n        }\r\n\r\n        const timestamp = new Date().toLocaleTimeString();\r\n        const prefix = `[${MODULE_NAME}:${moduleName}] ${timestamp}`;\r\n\r\n        switch (level) {\r\n            case 'error':\r\n                console.error(prefix, ...args);\r\n                break;\r\n            case 'warn':\r\n                console.warn(prefix, ...args);\r\n                break;\r\n            case 'debug':\r\n                console.debug(prefix, ...args);\r\n                break;\r\n            default:\r\n                console.log(prefix, ...args);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add operation trace for debugging workflows\r\n     * @param {string} moduleName - Module name\r\n     * @param {string} operationId - Unique operation identifier\r\n     * @param {string} message - Trace message\r\n     */\r\n    addTrace(moduleName, operationId, message) {\r\n        if (!this.isDebugEnabled()) {\r\n            return;\r\n        }\r\n\r\n        if (!this.operationTraces.has(operationId)) {\r\n            this.operationTraces.set(operationId, []);\r\n        }\r\n\r\n        this.operationTraces.get(operationId).push({\r\n            module: moduleName,\r\n            timestamp: Date.now(),\r\n            message: message,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get trace history for an operation\r\n     * @param {string} operationId - Operation identifier\r\n     * @returns {Array} Trace entries\r\n     */\r\n    getTrace(operationId) {\r\n        return this.operationTraces.get(operationId) || [];\r\n    }\r\n\r\n    /**\r\n     * Start performance timer\r\n     * @param {string} moduleName - Module name\r\n     * @param {string} timerName - Timer identifier\r\n     */\r\n    startTimer(moduleName, timerName) {\r\n        const key = `${moduleName}:${timerName}`;\r\n        this.performanceMarks.set(key, performance.now());\r\n    }\r\n\r\n    /**\r\n     * End performance timer and log duration\r\n     * @param {string} moduleName - Module name\r\n     * @param {string} timerName - Timer identifier\r\n     * @returns {number} Duration in milliseconds\r\n     */\r\n    endTimer(moduleName, timerName) {\r\n        const key = `${moduleName}:${timerName}`;\r\n        const startTime = this.performanceMarks.get(key);\r\n\r\n        if (startTime === undefined) {\r\n            this.log(moduleName, 'warn', `Timer '${timerName}' was not started`);\r\n            return 0;\r\n        }\r\n\r\n        const duration = performance.now() - startTime;\r\n        this.performanceMarks.delete(key);\r\n\r\n        this.log(moduleName, 'debug', `Timer '${timerName}': ${duration.toFixed(2)}ms`);\r\n        return duration;\r\n    }\r\n\r\n    /**\r\n     * Check if debug mode is enabled\r\n     * @returns {boolean} Debug mode status\r\n     */\r\n    isDebugEnabled() {\r\n        // This will be overridden by main.js to connect to settings\r\n        return true; // Default during initialization\r\n    }\r\n\r\n    /**\r\n     * Clear all traces and performance data\r\n     */\r\n    clear() {\r\n        this.operationTraces.clear();\r\n        this.performanceMarks.clear();\r\n    }\r\n\r\n    /**\r\n     * Get performance summary\r\n     * @returns {Object} Performance statistics\r\n     */\r\n    getPerformanceSummary() {\r\n        return {\r\n            activeTimers: this.performanceMarks.size,\r\n            activeTraces: this.operationTraces.size,\r\n            modules: Array.from(this.modules.keys()),\r\n        };\r\n    }\r\n}\r\n\r\n// Create singleton instance\r\nconst debugLogger = new DebugLogger();\r\n\r\n// Export the instance and key methods for easy access\r\nexport { debugLogger };\r\n\r\n// Export functions instead of bound methods to avoid binding issues\r\nexport function createModuleLogger(moduleName) {\r\n    return debugLogger.createModuleLogger(moduleName);\r\n}\r\n\r\nexport function addTrace(moduleName, operationId, message) {\r\n    return debugLogger.addTrace(moduleName, operationId, message);\r\n}\r\n\r\nexport function startTimer(operationId) {\r\n    return debugLogger.startTimer(operationId);\r\n}\r\n\r\nexport function endTimer(operationId) {\r\n    return debugLogger.endTimer(operationId);\r\n}\r\n\r\nexport default debugLogger;\r\n","\"use strict\";\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;","/**\r\n * Utility functions for Name Tracker extension\r\n * Common helpers and shared functionality\r\n */\r\n\r\nimport debugLogger from '../core/debug.js';\r\n\r\nconst logger = debugLogger.createModuleLogger('Utils');\r\n\r\n/**\r\n * Simple hash function for generating unique identifiers\r\n * @param {string} str - String to hash\r\n * @returns {string} Hash value in base-36 format\r\n */\r\nexport function simpleHash(str) {\r\n    let hash = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        const char = str.charCodeAt(i);\r\n        hash = ((hash << 5) - hash) + char;\r\n        hash = hash & hash;\r\n    }\r\n    return hash.toString(36);\r\n}\r\n\r\n/**\r\n * Escape HTML special characters to prevent XSS\r\n * @param {string} text - Text to escape\r\n * @returns {string} HTML-safe text\r\n */\r\nexport function escapeHtml(text) {\r\n    if (typeof text !== 'string') {\r\n        return '';\r\n    }\r\n\r\n    const div = document.createElement('div');\r\n    div.textContent = text;\r\n    return div.innerHTML;\r\n}\r\n\r\n/**\r\n * Generate unique identifier\r\n * @returns {string} Unique ID\r\n */\r\nexport function generateUID() {\r\n    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);\r\n}\r\n\r\n/**\r\n * Deep clone an object\r\n * @param {any} obj - Object to clone\r\n * @returns {any} Cloned object\r\n */\r\nexport function deepClone(obj) {\r\n    if (obj === null || typeof obj !== 'object') {\r\n        return obj;\r\n    }\r\n\r\n    if (obj instanceof Date) {\r\n        return new Date(obj.getTime());\r\n    }\r\n\r\n    if (obj instanceof Array) {\r\n        return obj.map(item => deepClone(item));\r\n    }\r\n\r\n    if (typeof obj === 'object') {\r\n        const cloned = {};\r\n        Object.keys(obj).forEach(key => {\r\n            cloned[key] = deepClone(obj[key]);\r\n        });\r\n        return cloned;\r\n    }\r\n\r\n    return obj;\r\n}\r\n\r\n/**\r\n * Debounce function calls\r\n * @param {Function} func - Function to debounce\r\n * @param {number} wait - Wait time in milliseconds\r\n * @returns {Function} Debounced function\r\n */\r\nexport function debounce(func, wait) {\r\n    let timeout;\r\n    return function executedFunction(...args) {\r\n        const later = () => {\r\n            clearTimeout(timeout);\r\n            func(...args);\r\n        };\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(later, wait);\r\n    };\r\n}\r\n\r\n/**\r\n * Throttle function calls\r\n * @param {Function} func - Function to throttle\r\n * @param {number} limit - Time limit in milliseconds\r\n * @returns {Function} Throttled function\r\n */\r\nexport function throttle(func, limit) {\r\n    let inThrottle;\r\n    return function executedFunction(...args) {\r\n        if (!inThrottle) {\r\n            func.apply(this, args);\r\n            inThrottle = true;\r\n            setTimeout(() => inThrottle = false, limit);\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Check if a value is empty (null, undefined, empty string, empty array, empty object)\r\n * @param {any} value - Value to check\r\n * @returns {boolean} True if empty\r\n */\r\nexport function isEmpty(value) {\r\n    if (value == null) return true;\r\n    if (typeof value === 'string') return value.trim() === '';\r\n    if (Array.isArray(value)) return value.length === 0;\r\n    if (typeof value === 'object') return Object.keys(value).length === 0;\r\n    return false;\r\n}\r\n\r\n/**\r\n * Normalize character names (remove extra spaces, normalize case)\r\n * @param {string} name - Name to normalize\r\n * @returns {string} Normalized name\r\n */\r\nexport function normalizeName(name) {\r\n    if (typeof name !== 'string') {\r\n        return '';\r\n    }\r\n\r\n    return name\r\n        .trim()\r\n        .replace(/\\s+/g, ' ') // Replace multiple spaces with single space\r\n        .split(' ')\r\n        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\r\n        .join(' ');\r\n}\r\n\r\n/**\r\n * Calculate similarity between two strings\r\n * @param {string} str1 - First string\r\n * @param {string} str2 - Second string\r\n * @returns {number} Similarity score (0-1)\r\n */\r\nexport function calculateSimilarity(str1, str2) {\r\n    if (!str1 || !str2) return 0;\r\n\r\n    const a = str1.toLowerCase();\r\n    const b = str2.toLowerCase();\r\n\r\n    if (a === b) return 1;\r\n\r\n    // Simple Levenshtein distance\r\n    const matrix = [];\r\n\r\n    for (let i = 0; i <= b.length; i++) {\r\n        matrix[i] = [i];\r\n    }\r\n\r\n    for (let j = 0; j <= a.length; j++) {\r\n        matrix[0][j] = j;\r\n    }\r\n\r\n    for (let i = 1; i <= b.length; i++) {\r\n        for (let j = 1; j <= a.length; j++) {\r\n            if (b.charAt(i - 1) === a.charAt(j - 1)) {\r\n                matrix[i][j] = matrix[i - 1][j - 1];\r\n            } else {\r\n                matrix[i][j] = Math.min(\r\n                    matrix[i - 1][j - 1] + 1, // substitution\r\n                    matrix[i][j - 1] + 1,     // insertion\r\n                    matrix[i - 1][j] + 1,      // deletion\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    const maxLength = Math.max(a.length, b.length);\r\n    return 1 - (matrix[b.length][a.length] / maxLength);\r\n}\r\n\r\n/**\r\n * Format timestamp for display\r\n * @param {number} timestamp - Unix timestamp\r\n * @returns {string} Formatted time string\r\n */\r\nexport function formatTimestamp(timestamp) {\r\n    const date = new Date(timestamp);\r\n    const now = new Date();\r\n    const diff = now - date;\r\n\r\n    const seconds = Math.floor(diff / 1000);\r\n    const minutes = Math.floor(seconds / 60);\r\n    const hours = Math.floor(minutes / 60);\r\n    const days = Math.floor(hours / 24);\r\n\r\n    if (days > 0) return `${days}d ago`;\r\n    if (hours > 0) return `${hours}h ago`;\r\n    if (minutes > 0) return `${minutes}m ago`;\r\n    return 'Just now';\r\n}\r\n\r\n/**\r\n * Truncate text with ellipsis\r\n * @param {string} text - Text to truncate\r\n * @param {number} maxLength - Maximum length\r\n * @returns {string} Truncated text\r\n */\r\nexport function truncate(text, maxLength) {\r\n    if (typeof text !== 'string') return '';\r\n    if (text.length <= maxLength) return text;\r\n    return text.substring(0, maxLength - 3) + '...';\r\n}\r\n\r\nlogger.debug('Utils module loaded');\r\n\r\nexport default {\r\n    simpleHash,\r\n    escapeHtml,\r\n    generateUID,\r\n    deepClone,\r\n    debounce,\r\n    throttle,\r\n    isEmpty,\r\n    normalizeName,\r\n    calculateSimilarity,\r\n    formatTimestamp,\r\n    truncate,\r\n};\n","/**\r\n * UI Management Module\r\n *\r\n * Handles user interface components, settings panel management, character lists,\r\n * modal dialogs, and progress indicators for the Name Tracker extension.\r\n */\r\n\r\nimport { createModuleLogger } from '../core/debug.js';\r\nimport { withErrorBoundary, NameTrackerError } from '../core/errors.js';\r\nimport {\r\n    get_settings,\r\n    getCharacters, getCharacter, setCharacter, removeCharacter,\r\n    getSetting, setSetting,\r\n} from '../core/settings.js';\r\nimport { stContext } from '../core/context.js';\r\nimport { escapeHtml } from '../utils/helpers.js';\r\nimport { NotificationManager } from '../utils/notifications.js';\r\nimport { mergeCharacters, toggleIgnoreCharacter, createNewCharacter, purgeAllCharacters, hasUnresolvedRelationships } from './characters.js';\r\nimport { loadOllamaModels } from './llm.js';\r\nimport { harvestMessages, scanEntireChat, clearProcessingQueue } from './processing.js';\r\nimport { viewInLorebook } from './lorebook.js';\r\n\r\nconst debug = createModuleLogger('ui');\r\nconst notifications = new NotificationManager('UI Management');\r\n\r\n/**\r\n * Update character list display in settings\r\n * @returns {void}\r\n */\r\nexport function updateCharacterList() {\r\n    return withErrorBoundary('updateCharacterList', async () => {\r\n        let $container = $('#name_tracker_character_list');\r\n        if ($container.length === 0) {\r\n            // Fallback: create a minimal container if settings HTML wasn't loaded\r\n            const settingsRoot = document.getElementById('extensions_settings');\r\n            if (settingsRoot) {\r\n                const placeholder = document.createElement('div');\r\n                placeholder.id = 'name_tracker_character_list';\r\n                settingsRoot.appendChild(placeholder);\r\n                $container = $('#name_tracker_character_list');\r\n            } else {\r\n                debug.log();\r\n                return;\r\n            }\r\n        }\r\n\r\n        console.log('[NT-UI]  updateCharacterList() called');\r\n        const characters = await getCharacters();\r\n        console.log('[NT-UI]  getCharacters() returned:', Object.keys(characters || {}));\r\n        const characterNames = Object.keys(characters);\r\n        console.log('[NT-UI]  Character count:', characterNames.length);\r\n\r\n        if (characterNames.length === 0) {\r\n            $container.html(`\r\n                <div class=\"name_tracker_no_characters\">\r\n                    <p style=\"text-align: center; color: var(--SmartThemeQuoteColor);\">\r\n                        No characters tracked yet. Start a conversation and character information will be extracted automatically!\r\n                    </p>\r\n                </div>\r\n            `);\r\n            return;\r\n        }\r\n\r\n        // Sort characters: Main characters first, then alphabetically\r\n        const sortedCharacters = Object.values(characters).sort((a, b) => {\r\n            if (a.isMainChar && !b.isMainChar) return -1;\r\n            if (!a.isMainChar && b.isMainChar) return 1;\r\n            return a.preferredName.localeCompare(b.preferredName);\r\n        });\r\n\r\n        let html = '<div class=\"name_tracker_character_list\">';\r\n\r\n        for (const character of sortedCharacters) {\r\n            const charIcon = character.isMainChar ? '<i class=\"fa-solid fa-user\"></i>' : '';\r\n            const ignoreIcon = character.ignored ? '<span class=\"char-ignored-badge\">IGNORED</span>' : '';\r\n            const reviewBadge = await hasUnresolvedRelationships(character) ? '<span class=\"char-review-badge\">NEEDS REVIEW</span>' : '';\r\n\r\n            const aliasText = character.aliases && character.aliases.length > 0\r\n                ? `<div class=\"char-aliases\">Aliases: ${escapeHtml(character.aliases.join(', '))}</div>`\r\n                : '';\r\n\r\n            const relationshipText = character.relationships && character.relationships.length > 0\r\n                ? `<div class=\"char-relationships\">Relationships: ${escapeHtml(character.relationships.join('; '))}</div>`\r\n                : '';\r\n\r\n            const lastUpdated = character.lastUpdated\r\n                ? new Date(character.lastUpdated).toLocaleString()\r\n                : 'Never';\r\n\r\n            html += `\r\n                <div class=\"name_tracker_character_item\" data-character=\"${escapeHtml(character.preferredName)}\">\r\n                    <div class=\"char-header\">\r\n                        <span class=\"char-name\">\r\n                            ${charIcon}\r\n                            ${escapeHtml(character.preferredName)}\r\n                            ${ignoreIcon}\r\n                            ${reviewBadge}\r\n                        </span>\r\n                        <div class=\"char-actions\">\r\n                            <button class=\"char-action-btn char-action-view\" data-name=\"${escapeHtml(character.preferredName)}\" title=\"View in lorebook\">\r\n                                <i class=\"fa-solid fa-book\"></i>\r\n                            </button>\r\n                            <button class=\"char-action-btn char-action-acknowledge ${character.needsReview ? 'needs-review' : ''}\" data-name=\"${escapeHtml(character.preferredName)}\" title=\"Acknowledge review\">\r\n                                <i class=\"fa-solid fa-check\"></i>\r\n                            </button>\r\n                            <button class=\"char-action-btn char-action-ignore\" data-name=\"${escapeHtml(character.preferredName)}\" title=\"${character.ignored ? 'Unignore' : 'Ignore'} character\">\r\n                                <i class=\"fa-solid ${character.ignored ? 'fa-eye' : 'fa-eye-slash'}\"></i>\r\n                            </button>\r\n                            <button class=\"char-action-btn char-action-merge\" data-name=\"${escapeHtml(character.preferredName)}\" title=\"Merge with another character\">\r\n                                <i class=\"fa-solid fa-code-merge\"></i>\r\n                            </button>\r\n                        </div>\r\n                    </div>\r\n                    ${aliasText}\r\n                    ${relationshipText}\r\n                    <div class=\"char-metadata\">\r\n                        <span>Confidence: ${character.confidence}%</span>\r\n                        <span>Updated: ${lastUpdated}</span>\r\n                    </div>\r\n                </div>\r\n            `;\r\n        }\r\n\r\n        html += '</div>';\r\n        $container.html(html);\r\n    });\r\n}\r\n\r\n/**\r\n * Update status display in settings\r\n * @returns {void}\r\n */\r\nexport function updateStatusDisplay() {\r\n    return withErrorBoundary('updateStatusDisplay', async () => {\r\n        const $statusContainer = $('#name_tracker_status_display');\r\n        if ($statusContainer.length === 0) {\r\n            return;\r\n        }\r\n\r\n        const characters = await getCharacters();\r\n        const characterCount = Object.keys(characters).length;\r\n\r\n        // Await settings to avoid Promise objects and ensure proper types\r\n        const messageCounter = await getSetting('messageCounter') || 0;\r\n        const lastScannedId = await getSetting('lastScannedMessageId') || -1;\r\n        const messageFreq = await getSetting('messageFrequency') || 10;\r\n\r\n        const context = stContext.getContext();\r\n        const currentMessageId = context?.chat?.length || 0;\r\n\r\n        // Ensure numeric values to prevent NaN\r\n        const safeLastScanned = typeof lastScannedId === 'number' ? lastScannedId : -1;\r\n        const safeMessageCounter = typeof messageCounter === 'number' ? messageCounter : 0;\r\n        const safeMessageFreq = typeof messageFreq === 'number' ? messageFreq : 10;\r\n        const safeChatLength = typeof currentMessageId === 'number' ? currentMessageId : 0;\r\n\r\n        const pendingMessages = Math.max(0, safeChatLength - safeLastScanned);\r\n        const progressText = safeMessageCounter > 0 ? ` (${safeMessageCounter} analyzed)` : '';\r\n        const messagesToNextScan = Math.max(0, safeMessageFreq - (safeChatLength - safeLastScanned));\r\n\r\n        // Debug logging\r\n        console.log(`[NT-Status] Characters: ${characterCount}, Messages: ${safeChatLength}, LastScanned: ${safeLastScanned}, Pending: ${pendingMessages}`);\r\n\r\n        const statusHtml = `\r\n            <div class=\"name_tracker_status\">\r\n                <div class=\"status-item\">\r\n                    <strong>Characters tracked:</strong> ${characterCount}${progressText}\r\n                </div>\r\n                <div class=\"status-item\">\r\n                    <strong>Messages in chat:</strong> ${safeChatLength}\r\n                </div>\r\n                <div class=\"status-item\">\r\n                    <strong>Last scanned message:</strong> ${safeLastScanned >= 0 ? safeLastScanned + 1 : 'None'}\r\n                </div>\r\n                <div class=\"status-item\">\r\n                    <strong>Pending messages:</strong> ${pendingMessages}\r\n                </div>\r\n                <div class=\"status-item\">\r\n                    <strong>Messages until next scan:</strong> ${messagesToNextScan}\r\n                </div>\r\n            </div>\r\n        `;\r\n\r\n        $statusContainer.html(statusHtml);\r\n    });\r\n}\r\n\r\n/**\r\n * Show character merge dialog\r\n * @param {string} sourceName - Name of source character\r\n * @returns {Promise<void>}\r\n */\r\nexport async function showMergeDialog(sourceName) {\r\n    return withErrorBoundary('showMergeDialog', async () => {\r\n        const characters = await getCharacters();\r\n\r\n        // Create list of other characters\r\n        const otherChars = Object.keys(characters).filter(name => name !== sourceName);\r\n\r\n        if (otherChars.length === 0) {\r\n            notifications.warning('No other characters to merge with');\r\n            return;\r\n        }\r\n\r\n        // Simple prompt for target character\r\n        const targetName = prompt(`Merge \"${sourceName}\" into which character? Available: ${otherChars.join(', ')}`);\r\n        if (!targetName) {\r\n            return; // User cancelled\r\n        }\r\n\r\n        try {\r\n            if (characters[targetName]) {\r\n                await mergeCharacters(sourceName, targetName);\r\n                notifications.success(`Merged ${sourceName} into ${targetName}`);\r\n            } else {\r\n                notifications.error('Invalid target character name');\r\n            }\r\n        } catch (error) {\r\n            notifications.error(`Merge failed: ${error.message}`, 'Merge Error');\r\n        } finally {\r\n            // Always update UI after merge attempt\r\n            await updateCharacterList();\r\n            await updateStatusDisplay();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Show character creation modal\r\n * @returns {Promise<void>}\r\n */\r\nexport async function showCreateCharacterModal() {\r\n    return withErrorBoundary('showCreateCharacterModal', async () => {\r\n        const characterName = prompt('Enter character name:');\r\n\r\n        if (!characterName || !characterName.trim()) {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            await createNewCharacter(characterName.trim());\r\n            notifications.success(`Created character: ${characterName.trim()}`);\r\n        } catch (error) {\r\n            notifications.error(`Failed to create character: ${error.message}`, 'Creation Error');\r\n        } finally {\r\n            // Always update UI after character creation attempt\r\n            await updateCharacterList();\r\n            await updateStatusDisplay();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Show purge confirmation dialog\r\n * @returns {Promise<void>}\r\n */\r\nexport async function showPurgeConfirmation() {\r\n    return withErrorBoundary('showPurgeConfirmation', async () => {\r\n        const characters = await getCharacters();\r\n        const characterCount = Object.keys(characters).length;\r\n\r\n        if (characterCount === 0) {\r\n            notifications.info('No characters to purge');\r\n            return;\r\n        }\r\n\r\n        const confirmed = confirm(`This will delete all ${characterCount} tracked characters and their lorebook entries.\\\\n\\\\nThis action cannot be undone!\\\\n\\\\nContinue?`);\r\n\r\n        if (!confirmed) {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const deletedCount = await purgeAllCharacters();\r\n            notifications.success(`Purged ${deletedCount} characters`, 'Purge Complete');\r\n        } catch (error) {\r\n            notifications.error(`Failed to purge characters: ${error.message}`, 'Purge Error');\r\n        } finally {\r\n            // Always update UI after purge attempt\r\n            await updateCharacterList();\r\n            await updateStatusDisplay();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Show system prompt editor modal\r\n * @returns {Promise<void>}\r\n */\r\nexport async function showSystemPromptEditor() {\r\n    return withErrorBoundary('showSystemPromptEditor', async () => {\r\n        // Get current system prompt\r\n        let currentPrompt = await getSetting('systemPrompt');\r\n        currentPrompt = currentPrompt || '';\r\n\r\n        // Create modal dialog\r\n        const modal = $(`\r\n            <div class=\"nametracker-modal\" style=\"\r\n                position: fixed;\r\n                top: 50%;\r\n                left: 50%;\r\n                transform: translate(-50%, -50%);\r\n                background: var(--SmartThemeBlurTintColor);\r\n                border: 1px solid var(--SmartThemeBorderColor);\r\n                border-radius: 10px;\r\n                padding: 20px;\r\n                max-width: 700px;\r\n                width: 90%;\r\n                max-height: 80vh;\r\n                overflow-y: auto;\r\n                z-index: 9999;\r\n                box-shadow: 0 4px 20px rgba(0,0,0,0.5);\r\n            \">\r\n                <h3 style=\"margin-top: 0;\">Edit System Prompt</h3>\r\n                <p>Customize the system prompt used for character analysis. Leave blank to use default.</p>\r\n                <textarea id=\"system_prompt_editor\" rows=\"20\" style=\"width: 100%; margin: 10px 0;\"\r\n                          placeholder=\"Enter custom system prompt or leave blank for default...\">${escapeHtml(currentPrompt)}</textarea>\r\n                <div style=\"margin-top: 20px; text-align: right;\">\r\n                    <button class=\"menu_button\" id=\"system_prompt_save\">Save</button>\r\n                    <button class=\"menu_button\" id=\"system_prompt_reset\">Reset to Default</button>\r\n                    <button class=\"menu_button\" id=\"system_prompt_cancel\">Cancel</button>\r\n                </div>\r\n            </div>\r\n        `);\r\n\r\n        const overlay = $(`\r\n            <div class=\"nametracker-overlay\" style=\"\r\n                position: fixed;\r\n                top: 0;\r\n                left: 0;\r\n                width: 100%;\r\n                height: 100%;\r\n                background: rgba(0,0,0,0.7);\r\n                z-index: 9998;\r\n            \"></div>\r\n        `);\r\n\r\n        $('body').append(overlay).append(modal);\r\n\r\n        const removeModal = () => {\r\n            modal.remove();\r\n            overlay.remove();\r\n        };\r\n\r\n        modal.find('#system_prompt_save').on('click', async () => {\r\n            const newPrompt = modal.find('#system_prompt_editor').val().trim();\r\n            await setSetting('systemPrompt', newPrompt || null);\r\n            notifications.success('System prompt updated');\r\n            removeModal();\r\n        });\r\n\r\n        modal.find('#system_prompt_reset').on('click', async () => {\r\n            modal.find('#system_prompt_editor').val('');\r\n            await setSetting('systemPrompt', null);\r\n            notifications.success('Reset to default system prompt');\r\n            removeModal();\r\n        });\r\n\r\n        modal.find('#system_prompt_cancel').on('click', removeModal);\r\n        overlay.on('click', removeModal);\r\n    });\r\n}\r\n\r\n/**\r\n * Show character list modal\r\n * @returns {void}\r\n */\r\nexport async function showCharacterListModal() {\r\n    return withErrorBoundary('showCharacterListModal', async () => {\r\n        const characters = Object.values(await getCharacters() || {});\r\n\r\n        // Build character list HTML\r\n        let charactersHtml = '';\r\n\r\n        if (characters.length === 0) {\r\n            charactersHtml = '<p style=\"text-align: center; color: var(--SmartThemeQuoteColor);\">No characters tracked yet</p>';\r\n        } else {\r\n            // Sort: Main characters first, then by name\r\n            characters.sort((a, b) => {\r\n                if (a.isMainChar && !b.isMainChar) return -1;\r\n                if (!a.isMainChar && b.isMainChar) return 1;\r\n                return a.preferredName.localeCompare(b.preferredName);\r\n            });\r\n\r\n            charactersHtml = '<div style=\"max-height: 400px; overflow-y: auto;\">';\r\n            for (const char of characters) {\r\n                const badges = [];\r\n                if (char.isMainChar) badges.push('<span style=\"background: var(--SmartThemeBodyColor); padding: 2px 6px; border-radius: 3px; font-size: 0.85em; margin-left: 5px;\">MAIN</span>');\r\n                if (char.ignored) badges.push('<span style=\"background: var(--black70a); padding: 2px 6px; border-radius: 3px; font-size: 0.85em; margin-left: 5px;\">IGNORED</span>');\r\n                if (await hasUnresolvedRelationships(char)) badges.push('<span style=\"background: var(--crimsonDark); padding: 2px 6px; border-radius: 3px; font-size: 0.85em; margin-left: 5px;\">NEEDS REVIEW</span>');\r\n\r\n                const aliasText = char.aliases && char.aliases.length > 0\r\n                    ? `<div style=\"font-size: 0.9em; color: var(--SmartThemeQuoteColor); margin-top: 3px;\">Aliases: ${escapeHtml(char.aliases.join(', '))}</div>`\r\n                    : '';\r\n\r\n                charactersHtml += `\r\n                    <div style=\"padding: 10px; margin: 5px 0; background: var(--SmartThemeBlurTintColor); border: 1px solid var(--SmartThemeBorderColor); border-radius: 5px;\">\r\n                        <div style=\"font-weight: bold;\">\r\n                            ${char.isMainChar ? '<i class=\"fa-solid fa-user\" style=\"margin-right: 5px;\"></i>' : ''}\r\n                            ${escapeHtml(char.preferredName)}\r\n                            ${badges.join('')}\r\n                        </div>\r\n                        ${aliasText}\r\n                    </div>\r\n                `;\r\n            }\r\n            charactersHtml += '</div>';\r\n        }\r\n\r\n        // Create and show modal\r\n        const modalHtml = `\r\n            <div class=\"name-tracker-character-modal\">\r\n                <h3 style=\"margin-top: 0;\">Tracked Characters (${characters.length})</h3>\r\n                ${charactersHtml}\r\n                <div style=\"margin-top: 15px; text-align: center;\">\r\n                    <button class=\"menu_button\" onclick=\"$('#name_tracker_settings').find('.inline-drawer-toggle').click(); $(this).closest('.popup').remove();\">\r\n                        <i class=\"fa-solid fa-gear\"></i> Open Settings\r\n                    </button>\r\n                </div>\r\n            </div>\r\n        `;\r\n\r\n        const context = stContext.getContext();\r\n        context.callGenericPopup(modalHtml, context.POPUP_TYPE.TEXT, '', { wider: true, okButton: 'Close' });\r\n    });\r\n}\r\n\r\n/**\r\n * Initialize UI event handlers\r\n * @returns {void}\r\n */\r\nexport function initializeUIHandlers() {\r\n    return withErrorBoundary('initializeUIHandlers', () => {\r\n        // Character action handlers\r\n        $(document).on('click', '.char-action-merge', async function() {\r\n            const sourceName = $(this).data('name');\r\n            await showMergeDialog(sourceName);\r\n        });\r\n\r\n        $(document).on('click', '.char-action-ignore', async function() {\r\n            const name = $(this).data('name');\r\n            try {\r\n                await toggleIgnoreCharacter(name);\r\n            } catch (error) {\r\n                notifications.error(`Failed to toggle ignore: ${error.message}`, 'Toggle Error');\r\n            } finally {\r\n                // Always update UI after ignore toggle attempt\r\n                await updateCharacterList();\r\n                await updateStatusDisplay();\r\n            }\r\n        });\r\n\r\n        $(document).on('click', '.char-action-view', async function() {\r\n            const name = $(this).data('name');\r\n            await viewInLorebook(name);\r\n        });\r\n\r\n        $(document).on('click', '.char-action-acknowledge', async function() {\r\n            const name = $(this).data('name');\r\n            try {\r\n                const character = await getCharacter(name);\r\n                if (character) {\r\n                    character.needsReview = false;\r\n                    await setCharacter(name, character);\r\n                    await updateCharacterList();\r\n                    notifications.success(`Acknowledged review for ${name}`);\r\n                }\r\n            } catch (error) {\r\n                notifications.error(`Failed to acknowledge: ${error.message}`);\r\n            }\r\n        });\r\n\r\n        debug.log();\r\n    });\r\n}\r\n\r\n/**\r\n * Show edit lorebook entry modal\r\n * @param {string} characterName - Name of character to edit\r\n * @returns {Promise<void>}\r\n */\r\n// eslint-disable-next-line no-unused-vars\r\nasync function showEditLorebookModal(characterName) {\r\n    return withErrorBoundary('showEditLorebookModal', async () => {\r\n        const character = await getCharacter(characterName);\r\n\r\n        if (!character) {\r\n            notifications.error('Character not found');\r\n            return;\r\n        }\r\n\r\n        // Build edit dialog\r\n        const currentKeys = [characterName, ...(character.aliases || [])].join(', ');\r\n\r\n        const dialogHtml = `\r\n            <div class=\"lorebook-entry-editor\">\r\n                <h3>Edit Lorebook Entry: ${escapeHtml(characterName)}</h3>\r\n\r\n                <div class=\"editor-section\">\r\n                    <label for=\"entry-keys\">Keys (comma-separated):</label>\r\n                    <input type=\"text\" id=\"entry-keys\" class=\"text_pole\" value=\"${escapeHtml(currentKeys)}\"\r\n                           placeholder=\"${escapeHtml(characterName)}, aliases, nicknames\">\r\n                    <small>These words trigger this entry in the chat context</small>\r\n                </div>\r\n\r\n                <div class=\"editor-section\">\r\n                    <label for=\"entry-content\">Entry Content:</label>\r\n                    <textarea id=\"entry-content\" rows=\"10\" class=\"text_pole\"\r\n                              placeholder=\"Description, personality, background, relationships...\">${escapeHtml(character.notes || '')}</textarea>\r\n                    <small>This will be injected into context when keys are mentioned</small>\r\n                </div>\r\n\r\n                <div class=\"editor-section\">\r\n                    <label for=\"entry-relationships\">Relationships:</label>\r\n                    <textarea id=\"entry-relationships\" rows=\"3\" class=\"text_pole\"\r\n                              placeholder=\"Friend of Alice; Enemy of Bob; Works for XYZ Corp\">${escapeHtml((character.relationships || []).join('; '))}</textarea>\r\n                    <small>One relationship per line or semicolon-separated</small>\r\n                </div>\r\n            </div>\r\n        `;\r\n\r\n        // Create simple modal dialog\r\n        const modal = $(`\r\n            <div class=\"nametracker-modal\" style=\"\r\n                position: fixed;\r\n                top: 50%;\r\n                left: 50%;\r\n                transform: translate(-50%, -50%);\r\n                background: var(--SmartThemeBlurTintColor);\r\n                border: 1px solid var(--SmartThemeBorderColor);\r\n                border-radius: 10px;\r\n                padding: 20px;\r\n                max-width: 600px;\r\n                width: 90%;\r\n                max-height: 80vh;\r\n                overflow-y: auto;\r\n                z-index: 9999;\r\n                box-shadow: 0 4px 20px rgba(0,0,0,0.5);\r\n            \">\r\n                ${dialogHtml}\r\n                <div style=\"margin-top: 20px; text-align: right;\">\r\n                    <button class=\"menu_button\" id=\"entry-save\">Save</button>\r\n                    <button class=\"menu_button\" id=\"entry-cancel\">Cancel</button>\r\n                </div>\r\n            </div>\r\n        `);\r\n\r\n        const overlay = $(`\r\n            <div class=\"nametracker-overlay\" style=\"\r\n                position: fixed;\r\n                top: 0;\r\n                left: 0;\r\n                width: 100%;\r\n                height: 100%;\r\n                background: rgba(0,0,0,0.7);\r\n                z-index: 9998;\r\n            \"></div>\r\n        `);\r\n\r\n        $('body').append(overlay).append(modal);\r\n\r\n        const removeModal = () => {\r\n            modal.remove();\r\n            overlay.remove();\r\n        };\r\n\r\n        modal.find('#entry-save').on('click', async () => {\r\n            const keys = modal.find('#entry-keys').val().split(',').map(k => k.trim()).filter(k => k);\r\n            const content = modal.find('#entry-content').val();\r\n            const relationships = modal.find('#entry-relationships').val()\r\n                .split(/[;\\\\n]/)\r\n                .map(r => r.trim())\r\n                .filter(r => r);\r\n\r\n            // Update character data\r\n            const preferredName = keys[0] || characterName;\r\n            const aliases = keys.slice(1);\r\n\r\n            character.preferredName = preferredName;\r\n            character.aliases = aliases;\r\n            character.notes = content;\r\n            character.relationships = relationships;\r\n\r\n            // If preferred name changed, need to update the key in settings\r\n            if (preferredName !== characterName) {\r\n                await removeCharacter(characterName);\r\n            }\r\n            await setCharacter(preferredName, character);\r\n\r\n            await updateCharacterList();\r\n            await updateStatusDisplay();\r\n\r\n            notifications.success(`Updated lorebook entry for ${preferredName}`);\r\n            removeModal();\r\n        });\r\n\r\n        modal.find('#entry-cancel').on('click', removeModal);\r\n        overlay.on('click', removeModal);\r\n    });\r\n}\r\n\r\n/**\r\n * Add a menu button to the extensions menu\r\n * @param {string} text - Button text\r\n * @param {string} faIcon - Font Awesome icon classes\r\n * @param {Function} callback - Click handler\r\n * @param {string} hover - Tooltip text\r\n * @param {string} className - Optional additional CSS class\r\n * @returns {void}\r\n */\r\nexport function addMenuButton(text, faIcon, callback, hover = null, className = '') {\r\n    return withErrorBoundary('addMenuButton', () => {\r\n        const $button = $(`\r\n            <div class=\"list-group-item flex-container flexGap5 interactable ${className}\" title=\"${hover || text}\" tabindex=\"0\">\r\n                <i class=\"${faIcon}\"></i>\r\n                <span>${text}</span>\r\n            </div>\r\n        `);\r\n\r\n        const $extensionsMenu = $('#extensionsMenu');\r\n        if (!$extensionsMenu.length) {\r\n            console.error('[Name Tracker] Could not find the extensions menu');\r\n            return;\r\n        }\r\n\r\n        $button.appendTo($extensionsMenu);\r\n        $button.on('click', () => callback());\r\n    });\r\n}\r\n\r\n/**\r\n * Toggle auto-harvest on/off\r\n * @returns {Promise<void>}\r\n */\r\nexport async function toggleAutoHarvest() {\r\n    return withErrorBoundary('toggleAutoHarvest', async () => {\r\n        const currentValue = await getSetting('autoAnalyze', true);\r\n        await setSetting('autoAnalyze', !currentValue);\r\n\r\n        // Update the settings UI\r\n        $('#name_tracker_auto_analyze').prop('checked', !currentValue);\r\n\r\n        // Update menu button icon to reflect state\r\n        const $menuButton = $('#extensionsMenu .name-tracker-toggle-harvest');\r\n        if (!currentValue) {\r\n            $menuButton.find('i').removeClass('fa-toggle-off').addClass('fa-toggle-on');\r\n        } else {\r\n            $menuButton.find('i').removeClass('fa-toggle-on').addClass('fa-toggle-off');\r\n        }\r\n\r\n        await updateStatusDisplay();\r\n\r\n        notifications.success(\r\n            `Auto-harvest ${!currentValue ? 'enabled' : 'disabled'}`,\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Open the chat lorebook in the World Info editor\r\n * @returns {Promise<void>}\r\n */\r\nexport async function openChatLorebook() {\r\n    return withErrorBoundary('openChatLorebook', async () => {\r\n        const context = stContext.getContext();\r\n        const lorebookName = context.chatMetadata?.world_info;\r\n\r\n        if (!lorebookName) {\r\n            notifications.warning('No active chat or lorebook');\r\n            return;\r\n        }\r\n\r\n        if (typeof context.openWorldInfoEditor === 'function') {\r\n            await context.openWorldInfoEditor(lorebookName);\r\n        } else {\r\n            // Fallback: show the world info panel\r\n            $('#WorldInfo').click();\r\n            notifications.info(`Please select \"${lorebookName}\" from the World Info panel`);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Initialize extension menu buttons\r\n * @returns {void}\r\n */\r\nexport function initializeMenuButtons() {\r\n    return withErrorBoundary('initializeMenuButtons', async () => {\r\n        // Add toggle auto-harvest button with visual state\r\n        const autoAnalyze = await getSetting('autoAnalyze', true);\r\n        const toggleIcon = autoAnalyze ? 'fa-solid fa-toggle-on' : 'fa-solid fa-toggle-off';\r\n        await addMenuButton(\r\n            'Toggle Auto-Harvest',\r\n            toggleIcon,\r\n            toggleAutoHarvest,\r\n            'Toggle automatic character harvesting on/off',\r\n            'name-tracker-toggle-harvest',\r\n        );\r\n\r\n        // Add character list button\r\n        await addMenuButton(\r\n            'View Characters',\r\n            'fa-solid fa-users',\r\n            showCharacterListModal,\r\n            'View all tracked characters',\r\n        );\r\n\r\n        // Add open lorebook button\r\n        await addMenuButton(\r\n            'Open Chat Lorebook',\r\n            'fa-solid fa-book',\r\n            openChatLorebook,\r\n            'Open the Name Tracker chat lorebook in the World Info editor',\r\n        );\r\n\r\n        debug.log();\r\n    });\r\n}\r\n\r\n/**\r\n * Bind settings UI event handlers\r\n * @returns {void}\r\n */\r\nexport function bindSettingsHandlers() {\r\n    return withErrorBoundary('bindSettingsHandlers', () => {\r\n        // Main settings handlers\r\n        $('#name_tracker_enabled').on('input', async (event) => {\r\n            await setSetting('enabled', event.target.checked);\r\n            await updateStatusDisplay();\r\n        });\r\n\r\n        $('#name_tracker_auto_analyze').on('input', async (event) => {\r\n            await setSetting('autoAnalyze', event.target.checked);\r\n            await updateStatusDisplay();\r\n        });\r\n\r\n        $('#name_tracker_message_frequency').on('input', async (event) => {\r\n            await setSetting('messageFrequency', parseInt(event.target.value) || 10);\r\n            await updateStatusDisplay();\r\n        });\r\n\r\n        $('#name_tracker_llm_source').on('change', async (event) => {\r\n            await setSetting('llmSource', event.target.value);\r\n        });\r\n\r\n        $('#name_tracker_ollama_endpoint').on('input', async (event) => {\r\n            await setSetting('ollamaEndpoint', event.target.value);\r\n        });\r\n\r\n        $('#name_tracker_ollama_model').on('change', async (event) => {\r\n            await setSetting('ollamaModel', event.target.value);\r\n        });\r\n\r\n        $('#name_tracker_load_models').on('click', async () => {\r\n            try {\r\n                await loadOllamaModels();\r\n                notifications.success('Ollama models loaded');\r\n                // eslint-disable-next-line no-unused-vars\r\n            } catch (error) {\r\n                debug.log();\r\n                notifications.error('Failed to load Ollama models');\r\n            }\r\n        });\r\n\r\n        $('#name_tracker_confidence_threshold').on('input', async (event) => {\r\n            await setSetting('confidenceThreshold', parseInt(event.target.value) || 70);\r\n        });\r\n\r\n        // Lorebook settings handlers\r\n        $('#name_tracker_lorebook_position').on('change', async (event) => {\r\n            await setSetting('lorebookPosition', parseInt(event.target.value) || 0);\r\n        });\r\n\r\n        $('#name_tracker_lorebook_depth').on('input', async (event) => {\r\n            await setSetting('lorebookDepth', parseInt(event.target.value) || 1);\r\n        });\r\n\r\n        $('#name_tracker_lorebook_cooldown').on('input', async (event) => {\r\n            await setSetting('lorebookCooldown', parseInt(event.target.value) || 5);\r\n        });\r\n\r\n        $('#name_tracker_lorebook_probability').on('input', async (event) => {\r\n            await setSetting('lorebookProbability', parseInt(event.target.value) || 100);\r\n        });\r\n\r\n        $('#name_tracker_lorebook_enabled').on('input', async (event) => {\r\n            await setSetting('lorebookEnabled', event.target.checked);\r\n        });\r\n\r\n        $('#name_tracker_debug_mode').on('input', async (event) => {\r\n            await setSetting('debugMode', event.target.checked);\r\n        });\r\n\r\n        // Action button handlers\r\n        $('#name_tracker_manual_analyze').on('click', async () => {\r\n            const messageFreq = await getSetting('messageFrequency', 10);\r\n            await harvestMessages(messageFreq, true);\r\n            await updateCharacterList();\r\n            await updateStatusDisplay();\r\n        });\r\n\r\n        $('#name_tracker_scan_all').on('click', async () => {\r\n            await scanEntireChat();\r\n            await updateCharacterList();\r\n            await updateStatusDisplay();\r\n        });\r\n\r\n        $('#name_tracker_create_character').on('click', async () => {\r\n            await showCreateCharacterModal();\r\n        });\r\n\r\n        $('#name_tracker_clear_cache').on('click', () => {\r\n            clearProcessingQueue();\r\n            notifications.info('Cache and processing queue cleared');\r\n        });\r\n\r\n        $('#name_tracker_undo_merge').on('click', async () => {\r\n            const { undoLastMerge } = await import('./characters.js');\r\n            const success = await undoLastMerge();\r\n            if (success) {\r\n                await updateCharacterList();\r\n                await updateStatusDisplay();\r\n            }\r\n        });\r\n\r\n        $('#name_tracker_purge_entries').on('click', async () => {\r\n            await showPurgeConfirmation();\r\n        });\r\n\r\n        $('#name_tracker_edit_prompt').on('click', async () => {\r\n            await showSystemPromptEditor();\r\n        });\r\n\r\n        $('#name_tracker_debug_status').on('click', async () => {\r\n            await showDebugStatus();\r\n        });\r\n\r\n        $('#name_tracker_dump_context').on('click', async () => {\r\n            await dumpContextToConsole();\r\n        });\r\n\r\n        debug.log();\r\n    });\r\n}\r\n\r\n/**\r\n * Show debug status popup with all relevant variables\r\n * @returns {void}\r\n */\r\nfunction showDebugStatus() {\r\n    return withErrorBoundary('showDebugStatus', async () => {\r\n        const settings = await get_settings();\r\n        const characters = await getCharacters();\r\n\r\n        // Reusable builder: compute debug info + HTML\r\n        const buildDebugContent = async () => {\r\n            // Get LLM context info\r\n            let maxPromptTokens = 4096;\r\n            let contextDetails = {};\r\n            let detectionMethod = 'unknown';\r\n\r\n            try {\r\n                const { getMaxPromptLength } = await import('./llm.js');\r\n                const { stContext } = await import('../core/context.js');\r\n                const maxPromptResultObj = await getMaxPromptLength();\r\n                maxPromptTokens = maxPromptResultObj.maxPrompt;\r\n                detectionMethod = maxPromptResultObj.detectionMethod;\r\n\r\n                // Get raw context info (retry briefly if not yet ready)\r\n                let context = stContext.getContext();\r\n                if (!context || typeof context.maxContext === 'undefined') {\r\n                    for (let i = 0; i < 3; i++) {\r\n                        await new Promise(r => setTimeout(r, 200));\r\n                        context = stContext.getContext();\r\n                        if (context && typeof context.maxContext !== 'undefined') break;\r\n                    }\r\n                }\r\n\r\n                if (!context || typeof context.maxContext === 'undefined') {\r\n                    contextDetails = {\r\n                        totalContext: 'Not loaded yet (no chat active)',\r\n                        maxGeneration: 'N/A',\r\n                        maxGenerationNote: 'Context will be available after chat loads',\r\n                        modelName: context?.main_api || 'unknown',\r\n                    };\r\n                } else {\r\n                    const totalContext = context.maxContext;\r\n                    const extensionMaxTokens = Math.min(4096, Math.floor(totalContext * 0.15));\r\n\r\n                    contextDetails = {\r\n                        totalContext: totalContext,\r\n                        maxGeneration: extensionMaxTokens,\r\n                        maxGenerationNote: 'Extension-controlled (15% of context, max 4096)',\r\n                        modelName: context.main_api || 'unknown',\r\n                    };\r\n                }\r\n            } catch (_error) {\r\n                console.error('[NT-Debug] Error in buildDebugContent:', _error);\r\n                debug.log('Could not load LLM config:', _error);\r\n                contextDetails = {\r\n                    totalContext: 'Error loading',\r\n                    maxGeneration: 'Error',\r\n                    maxGenerationNote: 'Check console for details',\r\n                    modelName: 'unknown',\r\n                };\r\n                detectionMethod = 'error';\r\n            }\r\n\r\n            // Get batch size constants from processing module\r\n            const batchConstants = {\r\n                MIN_MESSAGES_PER_BATCH: 5,\r\n                TARGET_MESSAGES_PER_BATCH: 30,\r\n                MAX_MESSAGES_PER_BATCH: 50,\r\n                CONTEXT_TARGET_PERCENT: 80,\r\n                MIN_CONTEXT_TARGET: 50,\r\n            };\r\n\r\n            const systemPromptTokens = 500;\r\n            // Use generous response allocation instead of hardcoded 2048 limit\r\n            const maxGenTokens = typeof contextDetails.maxGeneration === 'number' ? contextDetails.maxGeneration : Math.max(8192, maxPromptTokens - 2000);\r\n            const safetyMargin = 500;\r\n            const reservedTokens = systemPromptTokens + maxGenTokens + safetyMargin;\r\n            const availableTokens = maxPromptTokens;\r\n\r\n            // Compile debug info\r\n            const debugInfo = {\r\n                'Extension Status': {\r\n                    'Enabled': settings.enabled !== false,\r\n                    'Debug Mode': settings.debugMode !== false,\r\n                    'LLM Source': settings.llmSource || 'sillytavern',\r\n                    'Model API': contextDetails.modelName,\r\n                    'Tracked Characters': Object.keys(characters).length,\r\n                },\r\n                'SillyTavern Context': {\r\n                    'Total Context Window': contextDetails.totalContext,\r\n                    'Extension Max Tokens': `${contextDetails.maxGeneration} (${contextDetails.maxGenerationNote})`,\r\n                    'System Prompt Reserve': systemPromptTokens,\r\n                    'Safety Margin': safetyMargin,\r\n                    'Total Reserved': reservedTokens,\r\n                },\r\n                'Max Context Detection': {\r\n                    'Detection Method': detectionMethod || 'unknown',\r\n                    'Detected Max Context': contextDetails.totalContext,\r\n                    'Final Max Prompt': maxPromptTokens,\r\n                },\r\n                'Usable Token Budget': {\r\n                    'Max Prompt Tokens': maxPromptTokens,\r\n                    'Context Target %': batchConstants.CONTEXT_TARGET_PERCENT,\r\n                    'Tokens to Use': Math.floor(availableTokens * (batchConstants.CONTEXT_TARGET_PERCENT / 100)),\r\n                },\r\n                'Batch Configuration': {\r\n                    'Min Messages/Batch': batchConstants.MIN_MESSAGES_PER_BATCH,\r\n                    'Target Messages/Batch': batchConstants.TARGET_MESSAGES_PER_BATCH,\r\n                    'Max Messages/Batch': batchConstants.MAX_MESSAGES_PER_BATCH,\r\n                    'Min Context Target': batchConstants.MIN_CONTEXT_TARGET,\r\n                },\r\n                'Analysis Settings': {\r\n                    'Message Frequency': settings.messageFrequency || 10,\r\n                    'Auto-Analyze': settings.autoAnalyze !== false,\r\n                    'Confidence Threshold': settings.confidenceThreshold || 70,\r\n                },\r\n                'Lorebook Settings': {\r\n                    'Position': ['After Char', 'Before Char', 'Top', 'Bottom'][settings.lorebookPosition || 0],\r\n                    'Depth': settings.lorebookDepth || 1,\r\n                    'Cooldown': settings.lorebookCooldown || 5,\r\n                    'Probability %': settings.lorebookProbability || 100,\r\n                    'Enabled': settings.lorebookEnabled !== false,\r\n                },\r\n            };\r\n\r\n            // Format for display\r\n            let htmlContent = '<div style=\"font-family: monospace; font-size: 12px; max-height: 500px; overflow-y: auto;\">';\r\n            for (const [section, values] of Object.entries(debugInfo)) {\r\n                htmlContent += '<div style=\"margin-bottom: 15px; border-bottom: 1px solid #666; padding-bottom: 10px;\">';\r\n                htmlContent += `<strong style=\"color: #90EE90; font-size: 13px;\">${section}</strong><br>`;\r\n                for (const [key, value] of Object.entries(values)) {\r\n                    const displayValue = value === true ? '' : (value === false ? '' : value);\r\n                    htmlContent += `<div style=\"margin-left: 10px; padding: 2px 0;\">\r\n                        <span style=\"color: #87CEEB;\">${key}:</span>\r\n                        <span style=\"color: #FFFF99;\">${displayValue}</span>\r\n                    </div>`;\r\n                }\r\n                htmlContent += '</div>';\r\n            }\r\n            htmlContent += '</div>';\r\n\r\n            return { debugInfo, htmlContent };\r\n        };\r\n\r\n        // Initial content\r\n        const initial = await buildDebugContent();\r\n\r\n        // Show in modal\r\n        const modal = $(`\r\n            <div class=\"nametracker-modal\" style=\"\r\n                position: fixed;\r\n                top: 50%;\r\n                left: 50%;\r\n                transform: translate(-50%, -50%);\r\n                background: #1a1a1a;\r\n                border: 2px solid #90EE90;\r\n                border-radius: 10px;\r\n                padding: 20px;\r\n                max-width: 550px;\r\n                width: 90%;\r\n                max-height: 75vh;\r\n                overflow-y: auto;\r\n                z-index: 9999;\r\n                box-shadow: 0 4px 20px rgba(0,0,0,0.8);\r\n            \">\r\n                <h3 style=\"margin-top: 0; color: #90EE90; border-bottom: 2px solid #90EE90; padding-bottom: 10px;\">\r\n                    <i class=\"fa-solid fa-bug\"></i> Debug Status\r\n                </h3>\r\n                <div id=\"nt-debug-content\">${initial.htmlContent}</div>\r\n                <div style=\"margin-top: 20px; display: flex; gap: 8px; justify-content: flex-end; border-top: 1px solid #666; padding-top: 10px;\">\r\n                    <button class=\"menu_button\" id=\"debug-refresh\" style=\"background: #2a2a2a; color: #FFFF99; border: 1px solid #90EE90;\">Refresh</button>\r\n                    <button class=\"menu_button\" id=\"debug-close\" style=\"background: #2a2a2a; color: #90EE90; border: 1px solid #90EE90;\">Close</button>\r\n                </div>\r\n            </div>\r\n        `);\r\n\r\n        const overlay = $(`\r\n            <div class=\"nametracker-overlay\" style=\"\r\n                position: fixed;\r\n                top: 0;\r\n                left: 0;\r\n                width: 100%;\r\n                height: 100%;\r\n                background: rgba(0,0,0,0.7);\r\n                z-index: 9998;\r\n            \"></div>\r\n        `);\r\n\r\n        $('body').append(overlay).append(modal);\r\n\r\n        const removeModal = () => {\r\n            modal.remove();\r\n            overlay.remove();\r\n        };\r\n\r\n        modal.find('#debug-close').on('click', removeModal);\r\n        overlay.on('click', removeModal);\r\n\r\n        // Log initial to console\r\n        console.log('[NT-Debug]', initial.debugInfo);\r\n\r\n        // Refresh handler: recompute and update content in-place\r\n        modal.find('#debug-refresh').on('click', async () => {\r\n            try {\r\n                const refreshed = await buildDebugContent();\r\n                modal.find('#nt-debug-content').html(refreshed.htmlContent);\r\n                console.log('[NT-Debug]', refreshed.debugInfo);\r\n            } catch (e) {\r\n                console.error('[NT-Debug] Refresh failed:', e);\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * Load and inject settings HTML\r\n * @param {string} extensionFolderPath - Path to extension folder\r\n * @returns {Promise<void>}\r\n */\r\nexport async function loadSettingsHTML(extensionFolderPath) {\r\n    return withErrorBoundary('loadSettingsHTML', async () => {\r\n        try {\r\n            // Load the settings HTML\r\n            const settingsHtml = await $.get(`${extensionFolderPath}/settings.html`);\r\n\r\n            // Append to the extensions settings panel\r\n            $('#extensions_settings').append(settingsHtml);\r\n\r\n            debug.log();\r\n        } catch (error) {\r\n            console.error('Failed to load settings HTML:', error);\r\n            throw new NameTrackerError(`Failed to load settings HTML: ${error.message}`);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Dump entire SillyTavern context to console for debugging\r\n * Shows all properties, values, and structure in readable format\r\n * @returns {void}\r\n */\r\nasync function dumpContextToConsole() {\r\n    return withErrorBoundary('dumpContextToConsole', async () => {\r\n        try {\r\n            const dump = await stContext.dumpContextToConsole();\r\n            notifications.success('Context dumped to console - Press F12 to view', 'Context Dump');\r\n\r\n            // Also show a brief summary in a dialog\r\n            const summary = {\r\n                'Total Properties': dump.availableProperties.length,\r\n                'Key Properties Found': Object.keys(dump.detailedBreakdown).filter(k => k in dump.detailedBreakdown).length,\r\n                'Timestamp': dump.timestamp,\r\n            };\r\n\r\n            console.log('%c[Name Tracker] QUICK SUMMARY:', 'color: #ffaa00; font-weight: bold; font-size: 12px;');\r\n            console.table(summary);\r\n\r\n        } catch (error) {\r\n            debug.log(`Failed to dump context: ${error.message}`);\r\n            notifications.error(`Failed to dump context: ${error.message}`, 'Context Dump');\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Update UI elements based on current settings\r\n * @returns {Promise<void>}\r\n */\r\nexport async function updateUI() {\r\n    return withErrorBoundary('updateUI', async () => {\r\n        // Update all form elements with current settings\r\n        $('#name_tracker_enabled').prop('checked', await getSetting('enabled', true));\r\n        $('#name_tracker_auto_analyze').prop('checked', await getSetting('autoAnalyze', true));\r\n        $('#name_tracker_message_frequency').val(await getSetting('messageFrequency', 10));\r\n        $('#name_tracker_llm_source').val(await getSetting('llmSource', 'sillytavern'));\r\n        $('#name_tracker_ollama_endpoint').val(await getSetting('ollamaEndpoint', 'http://localhost:11434'));\r\n        $('#name_tracker_ollama_model').val(await getSetting('ollamaModel', ''));\r\n        $('#name_tracker_confidence_threshold').val(await getSetting('confidenceThreshold', 70));\r\n        $('#name_tracker_lorebook_position').val(await getSetting('lorebookPosition', 0));\r\n        $('#name_tracker_lorebook_depth').val(await getSetting('lorebookDepth', 1));\r\n        $('#name_tracker_lorebook_cooldown').val(await getSetting('lorebookCooldown', 5));\r\n        $('#name_tracker_lorebook_probability').val(await getSetting('lorebookProbability', 100));\r\n        $('#name_tracker_lorebook_enabled').prop('checked', await getSetting('lorebookEnabled', true));\r\n        $('#name_tracker_debug_mode').prop('checked', await getSetting('debugMode', false));\r\n\r\n        // Update character list\r\n        await updateCharacterList();\r\n        // Note: updateStatusDisplay() is called via CHAT_LOADED event, not here\r\n        // (calling it here would show 0 messages since chat hasn't loaded yet)\r\n\r\n        debug.log();\r\n    });\r\n}\r\n","/**\r\n * Message Processing Module\r\n *\r\n * Handles two-phase character detection (lightweight name scan  focused LLM processing),\r\n * batch processing with character-specific context windows, and SillyTavern event integration.\r\n */\r\n\r\nimport { createModuleLogger } from '../core/debug.js';\r\nimport { withErrorBoundary, NameTrackerError } from '../core/errors.js';\r\nimport { get_settings, set_settings, getLLMConfig, getCharacters, setCharacters } from '../core/settings.js';\r\nimport { stContext } from '../core/context.js';\r\nimport { NotificationManager } from '../utils/notifications.js';\r\nimport { callLLMAnalysis, buildCharacterRoster, getMaxPromptLength, calculateMessageTokens } from './llm.js';\r\nimport { createCharacter, updateCharacter, findExistingCharacter, findPotentialMatch, isIgnoredCharacter, detectMergeOpportunities, mergeCharacters } from './characters.js';\r\nimport { updateLorebookEntry, loadCharactersFromLorebook } from './lorebook.js';\r\nimport { updateCharacterList, updateStatusDisplay } from './ui.js';\r\n\r\nconst debug = createModuleLogger('processing');\r\nconst notifications = new NotificationManager('Message Processing');\r\n\r\n// ============================================================================\r\n// DEBUG CONFIGURATION\r\n// ============================================================================\r\nconst DEBUG_LOGGING = false; // Default off to reduce console noise\r\n\r\nfunction debugLog(message, data = null) {\r\n    if (DEBUG_LOGGING) {\r\n        console.log(`[NT-Processing] ${message}`, data || '');\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// CONFIGURATION CONSTANTS - Core processing parameters\r\n// ============================================================================\r\n// These values drive the processing pipeline. Future user-exposed settings\r\n// should reference these constant names for easy discovery and updates.\r\n\r\n// Context Management\r\nconst CONTEXT_TARGET_PERCENT = 80;      // Target percentage of context window to use\r\nconst OVERLAP_SIZE = 3;                 // Messages to overlap between batches for continuity\r\nconst MIN_CONTEXT_TARGET = 50;          // Minimum allowed context target (floor for auto-reduction)\r\n\r\n// Name Detection\r\nconst CAPITALIZED_WORD_REGEX = /\\b[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*\\b/g;  // Matches capitalized names\r\nconst QUOTED_NAME_REGEX = /\"([^\"]+)\"/g;  // Matches quoted names\r\nconst POSSESSIVE_REGEX = /(\\b[A-Z][a-z]+)'s\\b/g;  // Matches possessive forms\r\n\r\n// Processing Control\r\n// const BATCH_TIMEOUT_MS = 30000;         // Maximum time for a single batch to process (reserved for future)\r\nconst MAX_RETRY_ATTEMPTS = 3;           // Maximum retries before halting processing\r\nconst CONTEXT_REDUCTION_STEP = 5;       // Percentage to reduce context target on each failure\r\n\r\n// Batch Size Constraints (token-based, but with message-count limits for safety)\r\n// Reduced for incremental update strategy - smaller batches yield better focused character updates\r\nconst MIN_MESSAGES_PER_BATCH = 3;       // Never create batches smaller than this (unless last batch)\r\nconst MAX_MESSAGES_PER_BATCH = 10;      // Cap batches at this size even if tokens allow more\r\nconst TARGET_MESSAGES_PER_BATCH = 7;    // Aim for this size when possible (optimal for focused analysis)\r\nconst TARGET_MESSAGE_PERCENT = 35;      // Use 35% of max context for message data (conservative)\r\n\r\n// Error Recovery\r\nconst ENABLE_AUTO_RECOVERY = true;      // Enable automatic context reduction on failure\r\n// const PRESERVE_PROCESSING_STATE = true; // Always save character state even on errors (reserved for future)\r\n\r\n// ============================================================================\r\n// SHARED HELPER FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate available token budget for message data\r\n * @param {number} maxPromptTokens - Maximum tokens available from context\r\n * @returns {number} Available tokens for message content\r\n */\r\nfunction calculateAvailableTokens(maxPromptTokens) {\r\n    // Use only 35% of max context for messages (conservative to avoid overwhelming the model)\r\n    // This leaves room for: system prompt (~1000 tokens) + response (up to 4000 tokens)\r\n    return Math.floor(maxPromptTokens * (TARGET_MESSAGE_PERCENT / 100));\r\n}\r\n\r\n/**\r\n * Create batches of messages based on token limits\r\n * @param {Array} messages - Messages to batch\r\n * @param {number} availableTokens - Token budget per batch\r\n * @param {boolean} enforceMessageLimit - Whether to enforce MAX_MESSAGES_PER_BATCH\r\n * @returns {Promise<Array>} Array of message batches\r\n */\r\nasync function createMessageBatches(messages, availableTokens, enforceMessageLimit = true) {\r\n    const batches = [];\r\n    let currentBatch = [];\r\n    let currentTokens = 0;\r\n\r\n    for (const msg of messages) {\r\n        const msgTokens = await calculateMessageTokens([msg]);\r\n\r\n        // Check if batch would exceed limits\r\n        const wouldExceedTokens = currentTokens + msgTokens > availableTokens;\r\n        const wouldExceedMessageCount = enforceMessageLimit && currentBatch.length >= MAX_MESSAGES_PER_BATCH;\r\n\r\n        if ((wouldExceedTokens || wouldExceedMessageCount) && currentBatch.length > 0) {\r\n            // Current batch is full, start new one\r\n            batches.push(currentBatch);\r\n            currentBatch = [msg];\r\n            currentTokens = msgTokens;\r\n        } else {\r\n            // Add to current batch\r\n            currentBatch.push(msg);\r\n            currentTokens += msgTokens;\r\n        }\r\n    }\r\n\r\n    // Add final batch\r\n    if (currentBatch.length > 0) {\r\n        batches.push(currentBatch);\r\n    }\r\n\r\n    return batches;\r\n}\r\n\r\n// Processing state\r\nlet processingQueue = [];\r\nlet isProcessing = false;\r\nlet abortScan = false;\r\n\r\n// Throughput tracking for progress bar metrics\r\nlet batchTimestamps = []; // Store last 10 batch completion timestamps\r\nconst THROUGHPUT_WINDOW_SIZE = 10;\r\nconst currentProcessingState = {\r\n    totalBatches: 0,\r\n    currentBatch: 0,\r\n    failedCharacters: [],\r\n    lastError: null,\r\n    contextTarget: CONTEXT_TARGET_PERCENT,\r\n};\r\n\r\n/**\r\n * Process analysis results from LLM\r\n * @param {Array} analyzedCharacters - Array of character data from LLM\r\n * @returns {Promise<void>}\r\n */\r\nexport async function processAnalysisResults(analyzedCharacters) {\r\n    return withErrorBoundary('processAnalysisResults', async () => {\r\n        debugLog('processAnalysisResults', {\r\n            inputType: typeof analyzedCharacters,\r\n            isArray: Array.isArray(analyzedCharacters),\r\n            length: analyzedCharacters?.length,\r\n        });\r\n\r\n        if (!analyzedCharacters || !Array.isArray(analyzedCharacters)) {\r\n            console.warn('[NT-Processing]   Invalid input - not an array:', analyzedCharacters);\r\n            debug.log();\r\n            return;\r\n        }\r\n\r\n        debugLog(`Processing ${analyzedCharacters.length} characters`);\r\n\r\n        for (const analyzedChar of analyzedCharacters) {\r\n            try {\r\n                await processCharacterData(analyzedChar);\r\n            } catch (error) {\r\n                console.error(`[NT-Processing]  Error processing character ${analyzedChar.name}:`, error);\r\n                console.error('[NT-Processing] Error stack:', error.stack);\r\n                // Continue with other characters\r\n            }\r\n        }\r\n\r\n        debugLog('All characters processed');\r\n        console.log('[NT-Processing]  About to call updateCharacterList()');\r\n        const listResult = await updateCharacterList();\r\n        console.log('[NT-Processing]  updateCharacterList() returned:', listResult);\r\n        const statusResult = await updateStatusDisplay();\r\n        console.log('[NT-Processing]  updateStatusDisplay() returned:', statusResult);\r\n        const currentChars = await getCharacters();\r\n        console.log('[NT-Processing]  Current characters in storage:', currentChars);\r\n    });\r\n}\r\n\r\n/**\r\n * Process individual character data from LLM analysis\r\n * @param {Object} analyzedChar - Character data from LLM\r\n * @returns {Promise<void>}\r\n */\r\nasync function processCharacterData(analyzedChar) {\r\n    return withErrorBoundary('processCharacterData', async () => {\r\n        console.log('[NT-Processing]  processCharacterData() for:', analyzedChar?.name);\r\n        debugLog('Processing character data', analyzedChar?.name);\r\n\r\n        if (!analyzedChar.name || analyzedChar.name.trim() === '') {\r\n            console.warn('[NT-CharData]   Character has no name, skipping');\r\n            debug.log();\r\n            return;\r\n        }\r\n\r\n        const characterName = analyzedChar.name.trim();\r\n        debugLog('Character name', characterName);\r\n\r\n        // Check if character is ignored\r\n        const isIgnored = await isIgnoredCharacter(characterName);\r\n        if (isIgnored) {\r\n            debugLog('Character ignored, skipping', characterName);\r\n            debug.log();\r\n            return;\r\n        }\r\n\r\n        // Check for main character detection\r\n        const isMainChar = characterName.toLowerCase().includes('{{char}}') ||\r\n                  analyzedChar.isMainCharacter === true ||\r\n                  analyzedChar.role === 'main';\r\n        debugLog('Is main char', isMainChar);\r\n\r\n        // Check if character already exists\r\n        const existingChar = await findExistingCharacter(characterName);\r\n        debugLog('Existing character found', !!existingChar);\r\n\r\n        if (existingChar) {\r\n            // Update existing character\r\n            await updateCharacter(existingChar, analyzedChar, false, isMainChar);\r\n            await updateLorebookEntry(existingChar, existingChar.preferredName);\r\n            debug.log();\r\n        } else {\r\n            // Check for potential matches (similar names)\r\n            const potentialMatch = await findPotentialMatch(analyzedChar);\r\n            debugLog('Potential match found', !!potentialMatch);\r\n\r\n            if (potentialMatch) {\r\n                // Update potential match and add as alias\r\n                await updateCharacter(potentialMatch, analyzedChar, true, isMainChar);\r\n                await updateLorebookEntry(potentialMatch, potentialMatch.preferredName);\r\n                debug.log();\r\n            } else {\r\n                // Create new character\r\n                const newCharacter = await createCharacter(analyzedChar, isMainChar);\r\n                console.log('[NT-Processing]  Created character:', newCharacter?.preferredName);\r\n                await updateLorebookEntry(newCharacter, newCharacter.preferredName);\r\n                debug.log();\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n// ============================================================================\r\n// TWO-PHASE DETECTION SYSTEM\r\n// ============================================================================\r\n\r\n/**\r\n * PHASE 1: Lightweight name extraction from message batch\r\n * Uses regex patterns to find all potential character names without LLM\r\n * @param {Array} messages - Messages to scan for names\r\n * @returns {Array} Array of unique name candidates found\r\n */\r\nexport async function scanForNewNames(messages) {\r\n    return withErrorBoundary('scanForNewNames', async () => {\r\n        debugLog(`[PHASE 1] Starting name scan on ${messages.length} messages`);\r\n\r\n        if (!Array.isArray(messages) || messages.length === 0) {\r\n            debugLog('[PHASE 1] No messages to scan');\r\n            return [];\r\n        }\r\n\r\n        const foundNames = new Set();\r\n        const existingCharacters = await getCharacters();\r\n        const existingNames = new Set();\r\n\r\n        debugLog(`[PHASE 1] Existing characters in memory: ${Object.keys(existingCharacters).length}`);\r\n\r\n        // Build set of existing character names and aliases\r\n        for (const char of Object.values(existingCharacters)) {\r\n            existingNames.add(char.preferredName.toLowerCase());\r\n            if (char.aliases && Array.isArray(char.aliases)) {\r\n                char.aliases.forEach(alias => existingNames.add(alias.toLowerCase()));\r\n            }\r\n        }\r\n\r\n        const capitalizedFound = [];\r\n        const quotedFound = [];\r\n        const possessiveFound = [];\r\n\r\n        // Scan messages for potential names\r\n        for (const msg of messages) {\r\n            if (!msg.mes || typeof msg.mes !== 'string') continue;\r\n\r\n            const text = msg.mes;\r\n\r\n            // Extract capitalized words (names)\r\n            const capitalizedMatches = text.match(CAPITALIZED_WORD_REGEX) || [];\r\n            capitalizedMatches.forEach(match => {\r\n                const normalized = match.toLowerCase();\r\n                if (!existingNames.has(normalized) && match.length > 1) {\r\n                    foundNames.add(match);\r\n                    capitalizedFound.push(match);\r\n                }\r\n            });\r\n\r\n            // Extract quoted names\r\n            const quotedMatches = text.match(QUOTED_NAME_REGEX) || [];\r\n            quotedMatches.forEach(match => {\r\n                const name = match.slice(1, -1); // Remove quotes\r\n                const normalized = name.toLowerCase();\r\n                if (!existingNames.has(normalized) && name.length > 1) {\r\n                    foundNames.add(name);\r\n                    quotedFound.push(name);\r\n                }\r\n            });\r\n\r\n            // Extract possessive forms\r\n            const possessiveMatches = text.match(POSSESSIVE_REGEX) || [];\r\n            possessiveMatches.forEach(match => {\r\n                const name = match.replace(/'s$/, '');\r\n                const normalized = name.toLowerCase();\r\n                if (!existingNames.has(normalized)) {\r\n                    foundNames.add(name);\r\n                    possessiveFound.push(name);\r\n                }\r\n            });\r\n        }\r\n\r\n        debugLog(`[PHASE 1] Capitalized names found: ${capitalizedFound.join(', ')}`);\r\n        debugLog(`[PHASE 1] Quoted names found: ${quotedFound.join(', ')}`);\r\n        debugLog(`[PHASE 1] Possessive forms found: ${possessiveFound.join(', ')}`);\r\n        debugLog(`[PHASE 1] Total unique names to process: ${foundNames.size}`);\r\n\r\n        return Array.from(foundNames);\r\n    }, []);\r\n}\r\n\r\n/**\r\n * PHASE 2: Focused LLM analysis for new characters and existing character updates\r\n * Processes new names individually and updates existing characters that were mentioned\r\n * @param {Array} newNames - New character names to analyze\r\n * @param {Array} messages - Message context for character details\r\n * @param {Array} existingMentions - Names of existing characters mentioned in messages\r\n * @returns {Promise<Object>} Results of processing with success/error details\r\n */\r\nexport async function processPhaseTwoAnalysis(newNames, messages, existingMentions = []) {\r\n    return withErrorBoundary('processPhaseTwoAnalysis', async () => {\r\n        debugLog('[PHASE 2] Starting focused LLM analysis');\r\n        debugLog(`[PHASE 2] New characters: ${newNames.length}, Existing mentions: ${existingMentions.length}`);\r\n        debugLog(`[PHASE 2] Current context target: ${currentProcessingState.contextTarget}%`);\r\n\r\n        const results = {\r\n            newCharactersCreated: [],\r\n            existingCharactersUpdated: [],\r\n            failedCharacters: [],\r\n            mergesDetected: [],\r\n        };\r\n\r\n        if (!Array.isArray(messages) || messages.length === 0) {\r\n            debugLog('[PHASE 2] No messages provided, returning empty results');\r\n            return results;\r\n        }\r\n\r\n        try {\r\n            // Process new characters\r\n            if (newNames && newNames.length > 0) {\r\n                debugLog(`[PHASE 2] Processing ${newNames.length} new characters`);\r\n\r\n                for (const newName of newNames) {\r\n                    if (abortScan) {\r\n                        debugLog(`[PHASE 2] Processing aborted by user at character: ${newName}`);\r\n                        break;\r\n                    }\r\n\r\n                    try {\r\n                        await processNewCharacter(newName, messages, results);\r\n                    } catch (error) {\r\n                        debugLog(`[PHASE 2] Failed to process new character ${newName}: ${error.message}`);\r\n                        results.failedCharacters.push({ name: newName, error: error.message });\r\n                        currentProcessingState.failedCharacters.push(newName);\r\n                        currentProcessingState.lastError = error;\r\n\r\n                        // If ENABLE_AUTO_RECOVERY, attempt to reduce context and retry\r\n                        if (ENABLE_AUTO_RECOVERY && currentProcessingState.contextTarget > MIN_CONTEXT_TARGET) {\r\n                            currentProcessingState.contextTarget -= CONTEXT_REDUCTION_STEP;\r\n                            debugLog(`[PHASE 2] Auto-reducing context target to ${currentProcessingState.contextTarget}%`);\r\n                        } else if (results.failedCharacters.length >= MAX_RETRY_ATTEMPTS) {\r\n                            // Halt processing after max retries\r\n                            throw new NameTrackerError(\r\n                                `Processing halted: Maximum retries exceeded. Last error: ${error.message}`,\r\n                                'PROCESSING_MAX_RETRIES',\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Update existing characters mentioned in messages\r\n            if (existingMentions && existingMentions.length > 0) {\r\n                debug.log(`Phase 2: Updating ${existingMentions.length} existing characters`);\r\n\r\n                for (const charName of existingMentions) {\r\n                    if (abortScan) break;\r\n\r\n                    try {\r\n                        const existingChar = await findExistingCharacter(charName);\r\n                        if (existingChar) {\r\n                            await processExistingCharacter(existingChar, messages, results);\r\n                        }\r\n                    } catch (error) {\r\n                        debug.log(`Failed to update character ${charName}: ${error.message}`);\r\n                        results.failedCharacters.push({ name: charName, error: error.message });\r\n                    }\r\n                }\r\n            }\r\n\r\n        } catch (error) {\r\n            debug.log(`Phase 2 analysis error: ${error.message}`);\r\n            throw error;\r\n        }\r\n\r\n        return results;\r\n    }, { newCharactersCreated: [], existingCharactersUpdated: [], failedCharacters: [], mergesDetected: [] });\r\n}\r\n\r\n/**\r\n * Process a new character: LLM analysis  create entry  check for merges\r\n * @private\r\n */\r\nasync function processNewCharacter(name, messages, results) {\r\n    debugLog(`[P2-NewChar] Processing: ${name}`);\r\n\r\n    // Build context with 3-message overlap for this character\r\n    const characterContext = buildCharacterContext(name, messages, OVERLAP_SIZE);\r\n    debugLog(`[P2-NewChar] Context window size: ${characterContext ? characterContext.length : 0} chars`);\r\n\r\n    if (!characterContext || characterContext.length === 0) {\r\n        debugLog(`[P2-NewChar] FAILED: No context for ${name}`);\r\n        throw new NameTrackerError(`No context found for character: ${name}`, 'NO_CONTEXT');\r\n    }\r\n\r\n    // Analyze the character with LLM\r\n    debugLog(`[P2-NewChar] Calling LLM for ${name}`);\r\n    const characterData = await callLLMAnalysis([{ mes: characterContext }], [name], currentProcessingState.contextTarget);\r\n\r\n    if (!characterData || characterData.length === 0) {\r\n        debugLog(`[P2-NewChar] FAILED: LLM returned no data for ${name}`);\r\n        throw new NameTrackerError(`LLM returned no data for character: ${name}`, 'LLM_EMPTY_RESPONSE');\r\n    }\r\n\r\n    debugLog(`[P2-NewChar] LLM returned data: ${JSON.stringify(characterData[0]).substring(0, 200)}...`);\r\n\r\n    // Create the character\r\n    const newCharacter = await createCharacter(characterData[0], false);\r\n    await updateLorebookEntry(newCharacter, newCharacter.preferredName);\r\n\r\n    results.newCharactersCreated.push(newCharacter.preferredName);\r\n    debugLog(`[P2-NewChar] Successfully created: ${newCharacter.preferredName}`);\r\n\r\n    // Re-check merge opportunities now that the character exists in the cache\r\n    const potentialMerges = await detectMergeOpportunities(newCharacter.preferredName);\r\n    if (potentialMerges && potentialMerges.length > 0) {\r\n        debugLog(`[P2-NewChar] Merge opportunities: ${potentialMerges.map(m => `${m.targetName} (${Math.round(m.confidence * 100)}%)`).join(', ')}`);\r\n        results.mergesDetected.push({ source: newCharacter.preferredName, targets: potentialMerges });\r\n\r\n        for (const opportunity of potentialMerges) {\r\n            if (opportunity.targetName === newCharacter.preferredName) {\r\n                continue;\r\n            }\r\n\r\n            if (opportunity.confidence >= 0.9) {\r\n                await mergeCharacters(newCharacter.preferredName, opportunity.targetName);\r\n                notifications.success(`Auto-merged \"${newCharacter.preferredName}\" into \"${opportunity.targetName}\" (${Math.round(opportunity.confidence * 100)}% match)`, 'Character Merged');\r\n                break; // stop after first high-confidence merge\r\n            }\r\n\r\n            if (opportunity.confidence >= 0.7) {\r\n                notifications.info(`Possible duplicate: \"${newCharacter.preferredName}\"  \"${opportunity.targetName}\" (${Math.round(opportunity.confidence * 100)}%). Review in settings if needed.`, 'Merge Suggested');\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Process existing character: build context from last processed message  update entry\r\n * @private\r\n */\r\nasync function processExistingCharacter(existingChar, messages, results) {\r\n    debug.log(`Updating existing character: ${existingChar.preferredName}`);\r\n\r\n    // Build fresh context for this character from the current message window\r\n    const characterContext = buildCharacterContext(existingChar.preferredName, messages, OVERLAP_SIZE);\r\n\r\n    if (!characterContext || characterContext.length === 0) {\r\n        debug.log(`No new context for character ${existingChar.preferredName} since last processing`);\r\n        return;\r\n    }\r\n\r\n    // Analyze updated context for this character\r\n    debugLog(`[P2-Existing] Calling LLM for ${existingChar.preferredName}`);\r\n    const characterData = await callLLMAnalysis([{ mes: characterContext }], [existingChar.preferredName], currentProcessingState.contextTarget);\r\n\r\n    if (!characterData || characterData.length === 0) {\r\n        debugLog(`[P2-Existing] FAILED: LLM returned no data for ${existingChar.preferredName}`);\r\n        throw new NameTrackerError(`LLM returned no data for character: ${existingChar.preferredName}`, 'LLM_EMPTY_RESPONSE');\r\n    }\r\n\r\n    // Update the character with new information\r\n    await updateCharacter(existingChar, characterData[0], true, existingChar.isMainChar);\r\n    await updateLorebookEntry(existingChar, existingChar.preferredName);\r\n\r\n    results.existingCharactersUpdated.push(existingChar.preferredName);\r\n    debugLog(`[P2-Existing] Successfully updated: ${existingChar.preferredName}`);\r\n}\r\n\r\n/**\r\n * Build contextual text window for a character from a set of messages.\r\n * Includes an overlap of messages before and after any detected mentions.\r\n * @param {string} characterName - Name of the character to search for\r\n * @param {Array} messages - Array of chat message objects ({ mes: string })\r\n * @param {number} overlapSize - Number of messages to include before/after mentions\r\n * @returns {string} Joined context text or empty string if no mentions\r\n */\r\nfunction buildCharacterContext(characterName, messages, overlapSize) {\r\n    if (!characterName || !Array.isArray(messages) || messages.length === 0) {\r\n        return '';\r\n    }\r\n\r\n    const nameLower = String(characterName).toLowerCase();\r\n    const mentionIndices = [];\r\n\r\n    for (let i = 0; i < messages.length; i++) {\r\n        const text = messages[i]?.mes || '';\r\n        if (typeof text === 'string' && text.toLowerCase().includes(nameLower)) {\r\n            mentionIndices.push(i);\r\n        }\r\n    }\r\n\r\n    if (mentionIndices.length === 0) {\r\n        return '';\r\n    }\r\n\r\n    const minIdx = Math.max(0, Math.min(...mentionIndices) - overlapSize);\r\n    const maxIdx = Math.min(messages.length - 1, Math.max(...mentionIndices) + overlapSize);\r\n\r\n    const windowTexts = [];\r\n    for (let i = minIdx; i <= maxIdx; i++) {\r\n        const text = messages[i]?.mes;\r\n        if (text) {\r\n            windowTexts.push(text);\r\n        }\r\n    }\r\n\r\n    return windowTexts.join('\\n\\n');\r\n}\r\n\r\n/**\r\n * Build context starting from a specific message point (for continuing character updates)\r\n * @private\r\n */\r\n// Note: Deprecated helper removed; continuing updates now use buildCharacterContext()\r\n\r\n/**\r\n * Harvest and analyze messages\r\n * @param {number} messageCount - Number of recent messages to analyze\r\n * @param {boolean} showProgress - Whether to show progress notifications\r\n * @returns {Promise<void>}\r\n */\r\nexport async function harvestMessages(messageCount, showProgress = true) {\r\n    return withErrorBoundary('harvestMessages', async () => {\r\n        if (!await get_settings('enabled', true)) {\r\n            debug.log();\r\n            return;\r\n        }\r\n\r\n        // Check API connection for SillyTavern mode\r\n        const llmConfig = await getLLMConfig();\r\n        if (llmConfig.source === 'sillytavern') {\r\n            const context = stContext.getContext();\r\n            if (!context.onlineStatus) {\r\n                notifications.warning('Please connect to an API (OpenAI, Claude, etc.) before analyzing messages');\r\n                return;\r\n            }\r\n        }\r\n\r\n        const context = stContext.getContext();\r\n        if (!context.chat || context.chat.length === 0) {\r\n            debug.log();\r\n            notifications.info('No messages in chat to analyze');\r\n            return;\r\n        }\r\n\r\n        // Get the messages to analyze - count forward and check token limits\r\n        const endIdx = context.chat.length;\r\n        const startIdx = Math.max(0, endIdx - messageCount);\r\n        const messagesToAnalyze = context.chat.slice(startIdx, endIdx);\r\n\r\n        debugLog(`[Batching] Message selection: startIdx=${startIdx}, endIdx=${endIdx}, requesting ${messageCount} messages, got ${messagesToAnalyze.length} messages`);\r\n\r\n        let processedMessages = 0;\r\n\r\n        // Check if messages fit in context window\r\n        const maxPromptResult = await getMaxPromptLength();\r\n        const maxPromptTokens = maxPromptResult.maxPrompt;\r\n        const availableTokens = calculateAvailableTokens(maxPromptTokens);\r\n\r\n        debugLog(`[Batching] Token budget: maxPromptTokens=${maxPromptTokens}, targetPercent=${TARGET_MESSAGE_PERCENT}%, availableTokens=${availableTokens}`);\r\n        debugLog(`[Batching] Context target: ${currentProcessingState.contextTarget}%`);\r\n        debugLog(`[Batching] Estimated reserves: systemPrompt=~1000tok, response=~4000tok, messages=${availableTokens}tok`);\r\n\r\n        // Calculate actual token count for the requested messages\r\n        const messageTokens = await calculateMessageTokens(messagesToAnalyze);\r\n\r\n        debugLog(`[Batching] Total tokens for ${messagesToAnalyze.length} messages: ${messageTokens} tokens`);\r\n\r\n        // If too large, split into batches\r\n        if (messageTokens > availableTokens) {\r\n            debugLog(`[Batching] Messages exceed token limit (${messageTokens} > ${availableTokens}), creating batches`);\r\n\r\n            // Create batches using shared helper\r\n            const batches = await createMessageBatches(messagesToAnalyze, availableTokens, true);\r\n\r\n            // Log batch details for debugging\r\n            const batchDetails = await Promise.all(batches.map(async (batch, i) => {\r\n                const tokens = await calculateMessageTokens(batch);\r\n                return `Batch ${i + 1}: ${batch.length}msg/${tokens}tok`;\r\n            }));\r\n\r\n            debugLog(`[Batching] Created ${batches.length} total batches: ${batchDetails.join(' | ')}`);\r\n            debugLog(`[Batching] Constraints applied: MIN=${MIN_MESSAGES_PER_BATCH}, TARGET=${TARGET_MESSAGES_PER_BATCH}, MAX=${MAX_MESSAGES_PER_BATCH}, TokenLimit=${availableTokens}`);\r\n\r\n            // Reset abort flag\r\n            abortScan = false;\r\n\r\n            // Reset throughput tracking\r\n            batchTimestamps = [];\r\n\r\n            // Calculate average batch size for user notification\r\n            const avgBatchSize = Math.round(messagesToAnalyze.length / batches.length);\r\n            const notification = `Analyzing ${messagesToAnalyze.length} messages in ${batches.length} batches (~${avgBatchSize} messages each). This may take a while. Continue?`;\r\n\r\n            if (showProgress) {\r\n                // Ask user before proceeding with large analysis\r\n                const shouldProceed = confirm(notification);\r\n                if (!shouldProceed) {\r\n                    debugLog('[Batching] User cancelled batch processing');\r\n                    abortScan = true;\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // Show progress bar\r\n            showProgressBar(0, batches.length, 'Starting analysis...');\r\n\r\n            let successfulBatches = 0;\r\n            let failedBatches = 0;\r\n            const uniqueCharacters = new Set();\r\n\r\n            debugLog(`[Batching] Starting batch processing loop: ${batches.length} batches`);\r\n\r\n            // Process each batch\r\n            for (let i = 0; i < batches.length; i++) {\r\n                // Check if user aborted\r\n                if (abortScan) {\r\n                    debugLog(`[BatchProcessing] User aborted at batch ${i + 1}/${batches.length}`);\r\n                    hideProgressBar();\r\n                    notifications.warning('Analysis aborted');\r\n                    return;\r\n                }\r\n\r\n                const batch = batches[i];\r\n\r\n                // Calculate actual message range for this batch\r\n                const batchStartMsg = batches.slice(0, i).reduce((sum, b) => sum + b.length, 0);\r\n                const batchStart = startIdx + batchStartMsg;\r\n                const batchEnd = batchStart + batch.length;\r\n\r\n                debugLog(`[BatchProcessing] Processing batch ${i + 1}/${batches.length}: messages ${batchStart}-${batchEnd - 1} (${batch.length} messages)`);\r\n\r\n                try {\r\n                    showProgressBar(i + 1, batches.length, `Analyzing messages ${batchStart + 1}-${batchEnd}...`);\r\n\r\n                    // Build roster of characters found so far\r\n                    const characterRoster = await buildCharacterRoster();\r\n\r\n                    // Call LLM for analysis\r\n                    const analysis = await callLLMAnalysis(batch, characterRoster);\r\n\r\n                    console.log('[NT-Batch]  LLM analysis returned');\r\n                    console.log('[NT-Batch]    Type:', typeof analysis);\r\n                    console.log('[NT-Batch]    Value:', analysis);\r\n                    console.log('[NT-Batch]    Has characters?:', analysis && 'characters' in analysis);\r\n                    console.log('[NT-Batch]    Characters type:', typeof analysis?.characters);\r\n                    console.log('[NT-Batch]    Characters is Array?:', Array.isArray(analysis?.characters));\r\n                    console.log('[NT-Batch]    Characters length:', analysis?.characters?.length);\r\n\r\n                    // Process the analysis with enhanced null safety\r\n                    if (!analysis) {\r\n                        console.warn('[NT-Batch]  Analysis returned null/undefined, skipping batch');\r\n                        failedBatches++;\r\n                        continue;\r\n                    }\r\n\r\n                    if (!analysis.characters) {\r\n                        console.warn('[NT-Batch]  Analysis missing characters property, skipping batch');\r\n                        failedBatches++;\r\n                        continue;\r\n                    }\r\n\r\n                    if (!Array.isArray(analysis.characters)) {\r\n                        console.warn('[NT-Batch]  analysis.characters is not an array:', typeof analysis.characters);\r\n                        failedBatches++;\r\n                        continue;\r\n                    }\r\n\r\n                    // Valid analysis - process results\r\n                    console.log('[NT-Batch]  Calling processAnalysisResults with', analysis.characters.length, 'characters');\r\n                    await processAnalysisResults(analysis.characters);\r\n                    analysis.characters.forEach(char => uniqueCharacters.add(char.name));\r\n                    processedMessages += batch.length;\r\n\r\n                    successfulBatches++;\r\n\r\n                    // Track batch completion time for throughput metrics\r\n                    batchTimestamps.push(Date.now());\r\n                    if (batchTimestamps.length > THROUGHPUT_WINDOW_SIZE) {\r\n                        batchTimestamps.shift(); // Keep only last N timestamps\r\n                    }\r\n\r\n                    // Small delay between batches to avoid rate limiting\r\n                    if (i < batches.length - 1) {\r\n                        await new Promise(resolve => setTimeout(resolve, 500));\r\n                    }\r\n\r\n                } catch (error) {\r\n                    debugLog(`[BatchProcessing] ERROR in batch ${i + 1}: ${error.message}`);\r\n                    debugLog(`[BatchProcessing] Context: messages ${batchStart}-${batchEnd - 1}, batch size ${batch.length}, token count calc error`);\r\n                    console.error(`Error processing batch ${i + 1}:`, error);\r\n                    failedBatches++;\r\n                    notifications.error(`Batch ${i + 1} failed: ${error.message}`);\r\n                    // Continue to next batch automatically to avoid blocking popups\r\n                }\r\n            }\r\n\r\n            // Hide progress bar\r\n            hideProgressBar();\r\n\r\n            // Show summary\r\n            const summary = `Analysis complete!\r\n\r\nBatches processed: ${successfulBatches}/${batches.length}\r\nUnique characters found: ${uniqueCharacters.size}\r\nFailed batches: ${failedBatches}`;\r\n\r\n            debugLog(`[BatchProcessing] Batch analysis complete: ${successfulBatches}/${batches.length} successful, ${failedBatches} failed, ${uniqueCharacters.size} characters found`);\r\n\r\n            if (failedBatches > 0) {\r\n                notifications.warning(summary, 'Batch Analysis', { timeOut: 8000 });\r\n            } else {\r\n                notifications.success(summary, 'Batch Analysis', { timeOut: 8000 });\r\n            }\r\n\r\n            // Persist scan progress and update UI\r\n            if (processedMessages > 0) {\r\n                const existingCount = await get_settings('messageCounter', 0);\r\n                await set_settings('messageCounter', existingCount + processedMessages);\r\n                await set_settings('lastScannedMessageId', endIdx - 1);\r\n            }\r\n\r\n            // Always update UI after batch processing (success or partial failure)\r\n            await updateCharacterList();\r\n            await updateStatusDisplay();\r\n\r\n            return;\r\n        }\r\n\r\n        // Messages fit in one batch - process normally\r\n        if (showProgress) {\r\n            notifications.info(`Analyzing ${messagesToAnalyze.length} messages for character information...`);\r\n        }\r\n\r\n        try {\r\n            // Build roster of characters found so far\r\n            const characterRoster = await buildCharacterRoster();\r\n\r\n            // Call LLM for analysis with character context\r\n            const analysis = await callLLMAnalysis(messagesToAnalyze, characterRoster);\r\n\r\n            debug.log();\r\n\r\n            // Process the analysis\r\n            if (analysis.characters && Array.isArray(analysis.characters)) {\r\n                await processAnalysisResults(analysis.characters);\r\n                processedMessages += messagesToAnalyze.length;\r\n\r\n                if (showProgress) {\r\n                    notifications.success(`Found ${analysis.characters.length} character(s) in messages`);\r\n                }\r\n            } else {\r\n                debug.log();\r\n            }\r\n\r\n        } catch (error) {\r\n            console.error('Error during harvest:', error);\r\n            notifications.error(`Analysis failed: ${error.message}`, 'Name Tracker');\r\n        } finally {\r\n            // Always update UI after LLM processing (success or failure)\r\n            // Persist scan progress\r\n            if (processedMessages > 0) {\r\n                const existingCount = await get_settings('messageCounter', 0);\r\n                await set_settings('messageCounter', existingCount + processedMessages);\r\n                await set_settings('lastScannedMessageId', endIdx - 1);\r\n            }\r\n\r\n            await updateCharacterList();\r\n            await updateStatusDisplay();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Handle new message event\r\n * @param {number} messageId - ID of the new message\r\n * @returns {Promise<void>}\r\n */\r\nexport async function onMessageReceived(messageId) {\r\n    return withErrorBoundary('onMessageReceived', async () => {\r\n        if (!await get_settings('enabled', true) || !await get_settings('autoAnalyze', true)) {\r\n            return;\r\n        }\r\n\r\n        const context = stContext.getContext();\r\n        const chat = context.chat;\r\n\r\n        if (!chat || chat.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Get the current message index\r\n        const currentMessageIndex = chat.length - 1;\r\n\r\n        // Check if this message was already scanned\r\n        const lastScannedId = await get_settings('lastScannedMessageId', -1);\r\n        if (currentMessageIndex <= lastScannedId) {\r\n            debug.log();\r\n            return;\r\n        }\r\n\r\n        // Detect if messages were deleted (current index jumped backwards)\r\n        if (lastScannedId >= 0 && currentMessageIndex < lastScannedId) {\r\n            debug.log();\r\n\r\n            // Prompt user for rescan decision\r\n            const shouldRescan = await showRescanModal(currentMessageIndex, lastScannedId);\r\n\r\n            if (shouldRescan.rescan) {\r\n                await set_settings('lastScannedMessageId', shouldRescan.fromMessage - 1);\r\n\r\n                // Queue a full scan from the specified message\r\n                await addToQueue(async () => {\r\n                    await harvestMessages(currentMessageIndex - shouldRescan.fromMessage + 1, true);\r\n                });\r\n\r\n                return;\r\n            } else {\r\n                // Reset to current position without scanning\r\n                await set_settings('lastScannedMessageId', currentMessageIndex);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Check if we've reached the next scan milestone\r\n        const messageFreq = await get_settings('messageFrequency', 10);\r\n        const messagesSinceLastScan = currentMessageIndex - lastScannedId;\r\n\r\n        if (messagesSinceLastScan >= messageFreq) {\r\n            debug.log();\r\n\r\n            // Queue harvest\r\n            await addToQueue(async () => {\r\n                await harvestMessages(messageFreq, true);\r\n                // Update last scanned message ID after successful harvest\r\n                await set_settings('lastScannedMessageId', currentMessageIndex);\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Show rescan modal when message deletion is detected\r\n * @param {number} currentMessageIndex - Current message index\r\n * @param {number} lastScannedId - Last scanned message ID\r\n * @returns {Promise<Object>} Rescan decision\r\n */\r\nasync function showRescanModal(currentMessageIndex, lastScannedId) {\r\n    return new Promise((resolve) => {\r\n        const modal = $(`\r\n            <div class=\"name-tracker-rescan-modal\" style=\"position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--SmartThemeBodyColor); border: 2px solid var(--SmartThemeBorderColor); padding: 20px; border-radius: 10px; z-index: 9999; max-width: 500px;\">\r\n                <h3>Message History Changed</h3>\r\n                <p>Messages have been deleted or edited. Would you like to rescan the chat?</p>\r\n                <p>Current last scanned message: ${lastScannedId}<br>\r\n                Current message index: ${currentMessageIndex}</p>\r\n                <div style=\"margin-top: 15px;\">\r\n                    <label>Rescan from message: <input type=\"number\" id=\"rescan-from\" value=\"0\" min=\"0\" max=\"${currentMessageIndex}\" style=\"width: 80px; margin-left: 10px;\"></label>\r\n                </div>\r\n                <div style=\"margin-top: 15px; text-align: right;\">\r\n                    <button id=\"rescan-yes\" class=\"menu_button\">Rescan</button>\r\n                    <button id=\"rescan-no\" class=\"menu_button\">Skip</button>\r\n                </div>\r\n            </div>\r\n        `);\r\n\r\n        $('body').append(modal);\r\n\r\n        modal.find('#rescan-yes').on('click', () => {\r\n            const fromMessage = parseInt(modal.find('#rescan-from').val()) || 0;\r\n            modal.remove();\r\n            resolve({ rescan: true, fromMessage });\r\n        });\r\n\r\n        modal.find('#rescan-no').on('click', () => {\r\n            modal.remove();\r\n            resolve({ rescan: false });\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * Show progress bar for batch scanning with throughput metrics\r\n * @param {number} current - Current batch number (1-indexed)\r\n * @param {number} total - Total number of batches\r\n * @param {string} status - Status message\r\n */\r\nfunction showProgressBar(current, total, status = '') {\r\n    const progressBarId = 'name_tracker_progress';\r\n    const $existing = $(`.${progressBarId}`);\r\n\r\n    // Calculate throughput metrics if we have enough data\r\n    let throughputText = '';\r\n    if (batchTimestamps.length >= 2 && current > 0) {\r\n        // Calculate batches per minute from last N timestamps\r\n        const recentTimestamps = batchTimestamps.slice(-Math.min(THROUGHPUT_WINDOW_SIZE, batchTimestamps.length));\r\n        const timeSpan = recentTimestamps[recentTimestamps.length - 1] - recentTimestamps[0];\r\n        const batchesCompleted = recentTimestamps.length - 1;\r\n\r\n        if (timeSpan > 0 && batchesCompleted > 0) {\r\n            const batchesPerMin = (batchesCompleted / (timeSpan / 60000)).toFixed(1);\r\n            const remainingBatches = total - current;\r\n            const estimatedMinutes = Math.ceil(remainingBatches / (batchesCompleted / (timeSpan / 60000)));\r\n            throughputText = `  ${batchesPerMin} batches/min  ~${estimatedMinutes}min remaining`;\r\n        }\r\n    }\r\n\r\n    if ($existing.length > 0) {\r\n        // Update existing progress bar\r\n        if (status) $existing.find('.title').text(status + throughputText);\r\n        $existing.find('.progress').text(current);\r\n        $existing.find('.total').text(total);\r\n        $existing.find('progress').val(current).attr('max', total);\r\n        return;\r\n    }\r\n\r\n    // Create new progress bar\r\n    const bar = $(`\r\n        <div class=\"${progressBarId} name_tracker_progress_bar flex-container justifyspacebetween alignitemscenter\" style=\"\r\n            padding: 10px;\r\n            margin: 5px 0;\r\n            background: var(--SmartThemeBlurTintColor);\r\n            border: 1px solid var(--SmartThemeBorderColor);\r\n            border-radius: 5px;\r\n        \">\r\n            <div class=\"title\" style=\"flex: 1; font-weight: bold;\">${status || 'Name Tracker Scan'}${throughputText}</div>\r\n            <div style=\"margin: 0 10px;\">(<span class=\"progress\">${current}</span> / <span class=\"total\">${total}</span>)</div>\r\n            <progress value=\"${current}\" max=\"${total}\" style=\"flex: 2; margin: 0 10px;\"></progress>\r\n            <button class=\"menu_button fa-solid fa-stop\" title=\"Abort scan\" style=\"padding: 5px 10px;\"></button>\r\n        </div>\r\n    `);\r\n\r\n    // Add click event to abort the scan\r\n    bar.find('button').on('click', function() {\r\n        abortScan = true;\r\n        hideProgressBar();\r\n        notifications.warning('Scan aborted by user');\r\n    });\r\n\r\n    // Append to the main chat area (#sheld)\r\n    $('#sheld').append(bar);\r\n}\r\n\r\n/**\r\n * Hide and remove progress bar\r\n */\r\nfunction hideProgressBar() {\r\n    const progressBarId = 'name_tracker_progress';\r\n    const $existing = $(`.${progressBarId}`);\r\n    if ($existing.length > 0) {\r\n        $existing.fadeOut(300, function() {\r\n            $(this).remove();\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Scan entire chat in batches from oldest to newest\r\n * @returns {Promise<void>}\r\n */\r\nexport async function scanEntireChat() {\r\n    return withErrorBoundary('scanEntireChat', async () => {\r\n        // CRITICAL: Ensure lorebook is initialized BEFORE processing\r\n        console.log('[NT-Processing]  Ensuring lorebook is initialized before scan...');\r\n        const { initializeLorebook } = await import('./lorebook.js');\r\n        await initializeLorebook();\r\n        console.log('[NT-Processing]  Lorebook initialization complete');\r\n\r\n        const context = stContext.getContext();\r\n\r\n        if (!context.chat || context.chat.length === 0) {\r\n            notifications.warning('No chat messages to scan');\r\n            return;\r\n        }\r\n\r\n        // Check API connection for SillyTavern mode\r\n        const llmConfig = await getLLMConfig();\r\n        if (llmConfig.source === 'sillytavern') {\r\n            if (!context.onlineStatus) {\r\n                notifications.warning('Please connect to an API (OpenAI, Claude, etc.) before analyzing messages');\r\n                return;\r\n            }\r\n        }\r\n\r\n        const totalMessages = context.chat.length;\r\n\r\n        // Calculate optimal batch size based on context window\r\n        const maxPromptResult = await getMaxPromptLength();\r\n        const maxPromptTokens = maxPromptResult.maxPrompt;\r\n        const availableTokens = calculateAvailableTokens(maxPromptTokens);\r\n\r\n        // Build batches using shared helper with message limit enforcement\r\n        const batches = await createMessageBatches(context.chat, availableTokens, true);\r\n\r\n        const numBatches = batches.length;\r\n\r\n        const confirmed = confirm(`This will analyze all ${totalMessages} messages in ${numBatches} batches. This may take a while. Continue?`);\r\n\r\n        if (!confirmed) {\r\n            return;\r\n        }\r\n\r\n        // Reset abort flag\r\n        abortScan = false;\r\n\r\n        // Reset throughput tracking\r\n        batchTimestamps = [];\r\n\r\n        // Show progress bar\r\n        showProgressBar(0, numBatches, 'Starting batch scan...');\r\n\r\n        let successfulBatches = 0;\r\n        let failedBatches = 0;\r\n        let processedMessages = 0;\r\n        const uniqueCharacters = new Set(); // Track unique character names\r\n\r\n        // Process from oldest to newest\r\n        for (let i = 0; i < numBatches; i++) {\r\n            // Check if user aborted\r\n            if (abortScan) {\r\n                debug.log();\r\n                break;\r\n            }\r\n\r\n            const batchMessages = batches[i];\r\n\r\n            // Calculate message range for progress display\r\n            const startIdx = batches.slice(0, i).reduce((sum, b) => sum + b.length, 0);\r\n            const endIdx = startIdx + batchMessages.length;\r\n\r\n            try {\r\n                showProgressBar(i + 1, numBatches, `Processing messages ${startIdx + 1}-${endIdx}...`);\r\n\r\n                // Build roster of characters found so far\r\n                const characterRoster = await buildCharacterRoster();\r\n\r\n                // Call LLM for analysis with character context\r\n                const analysis = await callLLMAnalysis(batchMessages, characterRoster);\r\n\r\n                // Process the analysis with null safety\r\n                if (!analysis) {\r\n                    console.warn(`[NT-Processing] Batch ${i + 1}: Analysis returned null/undefined, skipping`);\r\n                    failedBatches++;\r\n                    continue;\r\n                }\r\n\r\n                if (!analysis.characters) {\r\n                    console.warn(`[NT-Processing] Batch ${i + 1}: Analysis missing characters property, skipping`);\r\n                    failedBatches++;\r\n                    continue;\r\n                }\r\n\r\n                if (!Array.isArray(analysis.characters)) {\r\n                    console.warn(`[NT-Processing] Batch ${i + 1}: analysis.characters is not an array (${typeof analysis.characters}), skipping`);\r\n                    failedBatches++;\r\n                    continue;\r\n                }\r\n\r\n                // Process valid analysis results\r\n                await processAnalysisResults(analysis.characters);\r\n                // Track unique characters\r\n                analysis.characters.forEach(char => uniqueCharacters.add(char.name));\r\n                processedMessages += batchMessages.length;\r\n\r\n                successfulBatches++;\r\n\r\n                // Track batch completion time for throughput metrics\r\n                batchTimestamps.push(Date.now());\r\n                if (batchTimestamps.length > THROUGHPUT_WINDOW_SIZE) {\r\n                    batchTimestamps.shift(); // Keep only last N timestamps\r\n                }\r\n\r\n                // Small delay between batches\r\n                if (i < numBatches - 1) {\r\n                    await new Promise(resolve => setTimeout(resolve, 1000));\r\n                }\r\n\r\n            } catch (error) {\r\n                console.error(`Error processing batch ${i + 1}:`, error);\r\n                failedBatches++;\r\n                notifications.error(`Batch ${i + 1} failed: ${error.message}`);\r\n                // Continue to next batch automatically to avoid blocking popups\r\n            }\r\n        }\r\n\r\n        // Hide progress bar\r\n        hideProgressBar();\r\n\r\n        // Update scan completion status\r\n        await set_settings('lastScannedMessageId', totalMessages - 1);\r\n\r\n        if (processedMessages > 0) {\r\n            const existingCount = await get_settings('messageCounter', 0);\r\n            await set_settings('messageCounter', existingCount + processedMessages);\r\n        }\r\n\r\n        // Always update UI after scan (success, partial failure, or abort)\r\n        await updateCharacterList();\r\n        await updateStatusDisplay();\r\n\r\n        // Show summary\r\n        const summary = `Full chat scan complete!\\n\\nMessages: ${totalMessages}\\nBatches: ${successfulBatches}/${numBatches}\\nCharacters found: ${uniqueCharacters.size}\\nFailed: ${failedBatches}`;\r\n\r\n        // Ensure summary is a string (defense against undefined values)\r\n        const safeSummary = String(summary || 'Scan completed');\r\n\r\n        if (failedBatches > 0) {\r\n            notifications.warning(safeSummary, 'Scan Complete', { timeOut: 10000 });\r\n        } else {\r\n            notifications.success(safeSummary, 'Scan Complete', { timeOut: 10000 });\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Add task to processing queue\r\n * @param {Function} task - Async function to execute\r\n * @returns {Promise<void>}\r\n */\r\nexport async function addToQueue(task) {\r\n    return withErrorBoundary('addToQueue', async () => {\r\n        processingQueue.push(task);\r\n\r\n        if (!isProcessing) {\r\n            await processQueue();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Process queued tasks\r\n * @returns {Promise<void>}\r\n */\r\nexport async function processQueue() {\r\n    return withErrorBoundary('processQueue', async () => {\r\n        if (isProcessing || processingQueue.length === 0) {\r\n            return;\r\n        }\r\n\r\n        isProcessing = true;\r\n\r\n        while (processingQueue.length > 0) {\r\n            const task = processingQueue.shift();\r\n            try {\r\n                await task();\r\n            } catch (error) {\r\n                console.error('Error processing queue task:', error);\r\n            }\r\n        }\r\n\r\n        isProcessing = false;\r\n    });\r\n}\r\n\r\n/**\r\n * Handle chat changed event\r\n * @returns {Promise<void>}\r\n */\r\nexport async function onChatChanged() {\r\n    return withErrorBoundary('onChatChanged', async () => {\r\n        debug.log(' Chat changed - clearing and reloading characters from lorebook');\r\n\r\n        // Clear processing state\r\n        processingQueue = [];\r\n        isProcessing = false;\r\n        abortScan = false;\r\n\r\n        // Reset scan state\r\n        await set_settings('lastScannedMessageId', -1);\r\n        await set_settings('messageCounter', 0);\r\n\r\n        // REC-15: Clear in-memory characters and reload from lorebook\r\n        // This ensures each chat has isolated character state persisted in its lorebook\r\n        debug.log(' Clearing in-memory characters...');\r\n        await setCharacters({});\r\n        \r\n        debug.log(' Loading characters from chat lorebook...');\r\n        const lorebookCharacters = await loadCharactersFromLorebook();\r\n        \r\n        if (Object.keys(lorebookCharacters).length > 0) {\r\n            await setCharacters(lorebookCharacters);\r\n            debug.log(` Loaded ${Object.keys(lorebookCharacters).length} characters from lorebook`);\r\n        } else {\r\n            debug.log(' No characters in lorebook - starting fresh');\r\n        }\r\n\r\n        // Always update UI when chat changes\r\n        await updateCharacterList();\r\n        await updateStatusDisplay();\r\n\r\n        debug.log(' Chat change complete');\r\n    });\r\n}\r\n\r\n/**\r\n * Clear the processing queue\r\n */\r\nexport function clearProcessingQueue() {\r\n    processingQueue = [];\r\n    isProcessing = false;\r\n    debug.log();\r\n}\r\n\r\n/**\r\n * Get processing status\r\n * @returns {Object} Processing status information\r\n */\r\nexport function getProcessingStatus() {\r\n    return {\r\n        isProcessing,\r\n        queueLength: processingQueue.length,\r\n        abortScan,\r\n    };\r\n}\r\n\r\n/**\r\n * Abort current scan operation\r\n */\r\nexport function abortCurrentScan() {\r\n    abortScan = true;\r\n    hideProgressBar();\r\n    debug.log();\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nc = undefined;","\n      import API from \"!./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!./node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!./node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!./node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!./node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!./node_modules/css-loader/dist/cjs.js!./style.css\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\noptions.insert = insertFn.bind(null, \"head\");\noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!./node_modules/css-loader/dist/cjs.js!./style.css\";\n       export default content && content.locals ? content.locals : undefined;\n","/**\r\n * Name Tracker Extension for SillyTavern - Modular Version\r\n * Main entry point and orchestration\r\n */\r\n\r\n// Import CSS\r\nimport '../style.css';\r\n\r\n// Core infrastructure\r\nimport debugLogger from './core/debug.js';\r\nimport { errorHandler } from './core/errors.js';\r\nimport sillyTavernContext from './core/context.js';\r\nimport { get_settings, getSetting, setChatData, getChatData } from './core/settings.js';\r\n\r\n// Utilities\r\nimport notifications from './utils/notifications.js';\r\nimport { /* escapeHtml, generateUID */ } from './utils/helpers.js';\r\n\r\n// Feature modules\r\nimport { /* initializeCharacterManager */ } from './modules/characters.js';\r\nimport { /* initializeLLMManager */ } from './modules/llm.js';\r\n// initializeLorebook is now called lazily when needed, not during extension load\r\nimport { onMessageReceived } from './modules/processing.js';\r\nimport { initializeUIHandlers, initializeMenuButtons, bindSettingsHandlers, updateUI } from './modules/ui.js';\r\n\r\n// Immediate import validation\r\nconsole.log('[STnametracker] Main index.js: Import validation');\r\nconsole.log('[STnametracker] Main index.js: initializeUIHandlers import =', typeof initializeUIHandlers, initializeUIHandlers);\r\nconsole.log('[STnametracker] Main index.js: initializeMenuButtons import =', typeof initializeMenuButtons, initializeMenuButtons);\r\nconsole.log('[STnametracker] Main index.js: bindSettingsHandlers import =', typeof bindSettingsHandlers, bindSettingsHandlers);\r\nconsole.log('[STnametracker] Main index.js: updateUI import =', typeof updateUI, updateUI);\r\n\r\n// Extension name constant - MUST match manifest\r\nconst extensionName = 'STnametracker';\r\nconst extensionFolderPath = `scripts/extensions/third-party/${extensionName}`;\r\n\r\n/**\r\n * Get extension settings - Required for SillyTavern integration\r\n * This is the pattern that SillyTavern expects\r\n * @returns {Object} Extension settings object\r\n */\r\n// Kept for potential future use with SillyTavern API\r\n// eslint-disable-next-line no-unused-vars\r\nfunction getExtensionSettings() {\r\n    // Use global extension_settings that SillyTavern provides\r\n    return window.extension_settings?.[extensionName] || {};\r\n}\r\n\r\n// Create the logger AFTER the getSettings function is defined\r\nconst logger = debugLogger.createModuleLogger('Main');\r\n\r\n/**\r\n * Name Tracker Extension main class\r\n */\r\nclass NameTrackerExtension {\r\n    constructor() {\r\n        this.initialized = false;\r\n        this.modules = new Map();\r\n    }\r\n\r\n    /**\r\n     * Initialize the extension\r\n     * @returns {Promise<void>}\r\n     */\r\n    async initialize() {\r\n        console.log('[STnametracker] Enter initialize() method');\r\n        return errorHandler.withErrorBoundary('Main', async () => {\r\n            console.log('[STnametracker] Inside error boundary');\r\n            if (this.initialized) {\r\n                console.log('[STnametracker] Already initialized, skipping');\r\n                return;\r\n            }\r\n\r\n            console.log('[STnametracker] Starting initialization sequence');\r\n            logger.log('Starting Name Tracker Extension v2.1.0');\r\n\r\n            // Initialize core systems\r\n            console.log('[STnametracker] Step 1: Initializing core systems...');\r\n            await this.initializeCore();\r\n            console.log('[STnametracker] Step 1: Core systems completed');\r\n\r\n            // Initialize feature modules\r\n            console.log('[STnametracker] Step 2: Initializing feature modules...');\r\n            await this.initializeModules();\r\n            console.log('[STnametracker] Step 2: Feature modules completed');\r\n\r\n            // Setup UI\r\n            console.log('[STnametracker] Step 3: Initializing UI...');\r\n            await this.initializeUI();\r\n            console.log('[STnametracker] Step 3: UI completed');\r\n\r\n            // Register event listeners\r\n            console.log('[STnametracker] Step 4: Registering event listeners...');\r\n            this.registerEventListeners();\r\n            console.log('[STnametracker] Step 4: Event listeners completed');\r\n\r\n            this.initialized = true;\r\n            console.log('[STnametracker] Marking as initialized');\r\n            logger.log('Name Tracker Extension initialized successfully');\r\n            console.log('[STnametracker] Full initialization sequence completed successfully');\r\n\r\n        }, {\r\n            retries: 2,\r\n            fallback: async (error) => {\r\n                logger.error('Failed to initialize extension:', error);\r\n                notifications.error('Failed to initialize', 'Extension Error');\r\n                return false;\r\n            },\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Initialize core infrastructure\r\n     * @returns {Promise<void>}\r\n     */\r\n    async initializeCore() {\r\n        console.log('[STnametracker] initializeCore: Starting...');\r\n        logger.debug('Initializing core systems...');\r\n\r\n        // Connect debug system to settings\r\n        console.log('[STnametracker] initializeCore: Connecting debug system...');\r\n        debugLogger.isDebugEnabled = () => getSetting('debugMode', false);\r\n        console.log('[STnametracker] initializeCore: Debug system connected');\r\n\r\n        // Settings are auto-initialized when accessed\r\n        console.log('[STnametracker] initializeCore: Settings ready');\r\n\r\n        // Setup error recovery strategies\r\n        this.setupErrorRecovery();\r\n\r\n        logger.debug('Core systems initialized');\r\n    }\r\n\r\n    /**\r\n     * Initialize feature modules\r\n     * @returns {Promise<void>}\r\n     */\r\n    async initializeModules() {\r\n        logger.debug('Initializing feature modules...');\r\n        console.log('[STnametracker] initializeModules: Module initialization skipped');\r\n        console.log('[STnametracker] initializeModules: Lorebook will be initialized when first needed');\r\n\r\n        // Note: We no longer initialize lorebook during extension load because\r\n        // context.chatId is undefined at that point. Instead, lorebook initialization\r\n        // happens automatically when scanEntireChat() or other processing functions\r\n        // are called, at which point a chat is guaranteed to be active.\r\n\r\n        logger.debug('Feature modules ready (lazy initialization)');\r\n    }\r\n\r\n    /**\r\n     * Initialize UI components\r\n     * @returns {Promise<void>}\r\n     */\r\n    async initializeUI() {\r\n        console.log('[STnametracker] initializeUI: Starting UI initialization...');\r\n        logger.debug('Initializing UI...');\r\n\r\n        try {\r\n            // Load settings HTML using proper jQuery pattern\r\n            console.log('[STnametracker] initializeUI: Loading settings HTML from:', `${extensionFolderPath}/settings.html`);\r\n            const settingsHtml = await $.get(`${extensionFolderPath}/settings.html`);\r\n            console.log('[STnametracker] initializeUI: Settings HTML loaded, length:', settingsHtml.length);\r\n\r\n            console.log('[STnametracker] initializeUI: Finding #extensions_settings element...');\r\n            const targetElement = $('#extensions_settings');\r\n            console.log('[STnametracker] initializeUI: Target element found:', targetElement.length > 0);\r\n\r\n            targetElement.append(settingsHtml);\r\n            console.log('[STnametracker] initializeUI: Settings HTML appended');\r\n\r\n            // Initialize UI handlers\r\n            console.log('[STnametracker] initializeUI: Initializing UI handlers...');\r\n            await initializeUIHandlers();\r\n            console.log('[STnametracker] initializeUI: UI handlers initialized');\r\n\r\n            console.log('[STnametracker] initializeUI: Initializing menu buttons...');\r\n            await initializeMenuButtons();\r\n            console.log('[STnametracker] initializeUI: Menu buttons initialized');\r\n\r\n            // Bind settings form handlers\r\n            console.log('[STnametracker] initializeUI: Binding settings handlers...');\r\n            await bindSettingsHandlers();\r\n            console.log('[STnametracker] initializeUI: Settings handlers bound');\r\n\r\n            // Update UI to reflect current settings\r\n            console.log('[STnametracker] initializeUI: Updating UI...');\r\n            await updateUI();\r\n            console.log('[STnametracker] initializeUI: UI updated');\r\n\r\n            logger.debug('UI initialized');\r\n        } catch (error) {\r\n            logger.error('Failed to initialize UI:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register SillyTavern event listeners\r\n     */\r\n    registerEventListeners() {\r\n        logger.debug('Registering event listeners...');\r\n\r\n        try {\r\n            // Get event objects from SillyTavern context\r\n            const context = sillyTavernContext.getContext();\r\n            const eventSource = context.eventSource;\r\n            const event_types = context.event_types;\r\n\r\n            if (!eventSource || !event_types) {\r\n                logger.warn('SillyTavern event system not available');\r\n                return;\r\n            }\r\n\r\n            // Register for SillyTavern events\r\n            eventSource.on(event_types.MESSAGE_RECEIVED, async (messageId) => {\r\n                logger.debug('Message received event:', messageId);\r\n                await onMessageReceived(messageId);\r\n            });\r\n\r\n            eventSource.on(event_types.MESSAGE_SENT, async (messageId) => {\r\n                logger.debug('Message sent event:', messageId);\r\n                await onMessageReceived(messageId);\r\n            });\r\n\r\n            eventSource.on(event_types.CHAT_CHANGED, async () => {\r\n                logger.debug('Chat changed event received');\r\n                // Reset chat-level data when chat changes\r\n                await setChatData({ characters: {}, lastScannedMessageId: -1 });\r\n            });\r\n\r\n            eventSource.on(event_types.CHAT_LOADED, async () => {\r\n                logger.debug('Chat loaded event received - updating status display');\r\n                // Import updateStatusDisplay dynamically to avoid circular dependency\r\n                const { updateStatusDisplay } = await import('./modules/ui.js');\r\n                await updateStatusDisplay();\r\n            });\r\n\r\n            logger.debug('Event listeners registered');\r\n        } catch (error) {\r\n            logger.error('Failed to register event listeners:', error);\r\n        }\r\n    }\r\n    /**\r\n     * Setup error recovery strategies\r\n     */\r\n    setupErrorRecovery() {\r\n        // Network error recovery\r\n        errorHandler.registerRecoveryStrategy('NETWORK_ERROR', async (error) => {\r\n            logger.warn('Attempting network error recovery');\r\n            await errorHandler.delay(2000);\r\n            notifications.info('Retrying network operation...');\r\n            return null; // Signal to retry original operation\r\n        });\r\n\r\n        // Data format error recovery\r\n        errorHandler.registerRecoveryStrategy('DATA_FORMAT_ERROR', async (error) => {\r\n            logger.warn('Data format error, clearing cache');\r\n            // TODO: Clear relevant caches when modules are implemented\r\n            return null;\r\n        });\r\n\r\n        // Critical error handler\r\n        errorHandler.onCriticalError((error) => {\r\n            logger.error('Critical error occurred:', error);\r\n            // TODO: Save state for debugging when modules are implemented\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get extension status for debugging\r\n     * @returns {Promise<Object>} Status information\r\n     */\r\n    async getStatus() {\r\n        return {\r\n            initialized: this.initialized,\r\n            context: sillyTavernContext.getStatus(),\r\n            settings: { initialized: true, moduleCount: Object.keys(await get_settings()).length },\r\n            debug: debugLogger.getPerformanceSummary(),\r\n            errors: errorHandler.getRecentErrors(5).length,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Shutdown the extension\r\n     * @returns {Promise<void>}\r\n     */\r\n    async shutdown() {\r\n        return errorHandler.withErrorBoundary('Main', async () => {\r\n            logger.log('Shutting down Name Tracker Extension');\r\n\r\n            // TODO: Cleanup modules\r\n            // TODO: Remove event listeners\r\n            // TODO: Save state\r\n\r\n            this.initialized = false;\r\n            debugLogger.clear();\r\n\r\n            logger.log('Extension shutdown complete');\r\n        }, { silent: true });\r\n    }\r\n}\r\n\r\n// Create extension instance\r\nconst nameTrackerExtension = new NameTrackerExtension();\r\n\r\n// Initialize extension when jQuery is ready - SillyTavern pattern\r\njQuery(async () => {\r\n    console.log('[STnametracker] jQuery ready, starting extension load...');\r\n    try {\r\n        console.log('[STnametracker] Logger available, initializing...');\r\n        logger.log('Name Tracker Extension loading...');\r\n\r\n        // Initialize extension_settings for this extension\r\n        console.log('[STnametracker] Setting up extension_settings...');\r\n        if (!window.extension_settings) {\r\n            console.log('[STnametracker] Creating window.extension_settings');\r\n            window.extension_settings = {};\r\n        }\r\n        console.log('[STnametracker] Current extension_settings keys:', Object.keys(window.extension_settings));\r\n        window.extension_settings[extensionName] = window.extension_settings[extensionName] || {};\r\n\r\n        // Call get_settings() to trigger default merge and persistence\r\n        console.log('[STnametracker] Initializing defaults...');\r\n        const initialSettings = await get_settings();\r\n        console.log('[STnametracker] Settings initialized with defaults.');\r\n        console.log('[STnametracker]   llmSource:', initialSettings.llmSource);\r\n        console.log('[STnametracker]   messageFrequency:', initialSettings.messageFrequency);\r\n        console.log('[STnametracker]   lorebookPosition:', initialSettings.lorebookPosition);\r\n        console.log('[STnametracker]   lorebookScanDepth:', initialSettings.lorebookScanDepth);\r\n        console.log('[STnametracker]   lorebookProbability:', initialSettings.lorebookProbability);\r\n        console.log('[STnametracker] Total extension_settings keys:', Object.keys(window.extension_settings[extensionName]).length);\r\n        console.log('[STnametracker] Extension settings keys:', Object.keys(window.extension_settings[extensionName]).slice(0, 10).join(', '));\r\n\r\n        console.log('[STnametracker] Starting main initialization...');\r\n        await nameTrackerExtension.initialize();\r\n        console.log('[STnametracker] Main initialization completed');\r\n\r\n        // Make extension available globally for debugging\r\n        window.nameTrackerExtension = nameTrackerExtension;\r\n\r\n        // Add debug commands to browser console\r\n        window.ntDebug = {\r\n            status: () => nameTrackerExtension.getStatus(),\r\n            errors: () => errorHandler.getRecentErrors(),\r\n            settings: async () => await get_settings(),\r\n            chatData: async () => await getChatData(),\r\n            clear: () => debugLogger.clear(),\r\n        };\r\n\r\n        logger.log('Name Tracker Extension loaded successfully');\r\n        console.log('[STnametracker] Extension loaded. Use ntDebug.status() for diagnostics.');\r\n\r\n    } catch (error) {\r\n        console.error('[STnametracker] Failed to initialize:', error);\r\n        notifications.error('Extension failed to load', 'Critical Error');\r\n    }\r\n});\r\n\r\nexport default nameTrackerExtension;\r\n"],"names":[],"ignoreList":[],"sourceRoot":""}