{"version":3,"file":"index.js","mappings":"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","sources":["webpack://sillytavern-nametracker/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js","webpack://sillytavern-nametracker/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js","webpack://sillytavern-nametracker/./style.css","webpack://sillytavern-nametracker/./src/core/context.js","webpack://sillytavern-nametracker/./node_modules/style-loader/dist/runtime/styleTagTransform.js","webpack://sillytavern-nametracker/./src/modules/lorebook.js","webpack://sillytavern-nametracker/./node_modules/css-loader/dist/runtime/api.js","webpack://sillytavern-nametracker/./node_modules/css-loader/dist/runtime/sourceMaps.js","webpack://sillytavern-nametracker/./src/core/errors.js","webpack://sillytavern-nametracker/./node_modules/style-loader/dist/runtime/insertStyleElement.js","webpack://sillytavern-nametracker/./src/core/settings.js","webpack://sillytavern-nametracker/./src/modules/characters.js","webpack://sillytavern-nametracker/./node_modules/style-loader/dist/runtime/insertBySelector.js","webpack://sillytavern-nametracker/./src/utils/notifications.js","webpack://sillytavern-nametracker/./src/modules/llm.js","webpack://sillytavern-nametracker/./src/core/debug.js","webpack://sillytavern-nametracker/./node_modules/style-loader/dist/runtime/styleDomAPI.js","webpack://sillytavern-nametracker/./src/utils/helpers.js","webpack://sillytavern-nametracker/webpack/bootstrap","webpack://sillytavern-nametracker/webpack/runtime/compat get default export","webpack://sillytavern-nametracker/webpack/runtime/define property getters","webpack://sillytavern-nametracker/webpack/runtime/hasOwnProperty shorthand","webpack://sillytavern-nametracker/webpack/runtime/nonce","webpack://sillytavern-nametracker/./style.css?f696","webpack://sillytavern-nametracker/./src/modules/processing.js","webpack://sillytavern-nametracker/./src/modules/ui.js","webpack://sillytavern-nametracker/./src/index.js"],"sourcesContent":["\"use strict\";\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce = typeof __webpack_nonce__ !== \"undefined\" ? __webpack_nonce__ : null;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;","\"use strict\";\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"./node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"./node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `/* Styles for the Name Tracker extension */\r\n\r\n.name-tracker-settings {\r\n    padding: 5px;\r\n}\r\n\r\n.name-tracker_block {\r\n    margin-bottom: 10px;\r\n}\r\n\r\n.name-tracker_block h4 {\r\n    margin-top: 10px;\r\n    margin-bottom: 10px;\r\n    font-weight: bold;\r\n}\r\n\r\n/* Status Display */\r\n.name-tracker-status-block {\r\n    background-color: var(--SmartThemeBlurTintColor);\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    border-radius: 5px;\r\n    padding: 10px;\r\n}\r\n\r\n.name-tracker-status {\r\n    font-weight: bold;\r\n    color: var(--SmartThemeBodyColor);\r\n    padding: 5px;\r\n    text-align: center;\r\n}\r\n\r\n/* Character List */\r\n.name-tracker-character-list {\r\n    max-height: 400px;\r\n    overflow-y: auto;\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    border-radius: 5px;\r\n    padding: 5px;\r\n    margin-top: 5px;\r\n}\r\n\r\n.name-tracker-character {\r\n    padding: 10px;\r\n    margin-bottom: 10px;\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    border-radius: 5px;\r\n    background-color: var(--SmartThemeBlurTintColor);\r\n}\r\n\r\n.name-tracker-character:last-child {\r\n    margin-bottom: 0;\r\n}\r\n\r\n/* Active/loaded character styling (characters that are loaded in SillyTavern) */\r\n.name-tracker-character.main-character {\r\n    border-left: 3px solid #4CAF50;\r\n    background-color: rgba(76, 175, 80, 0.05);\r\n}\r\n\r\n.character-header {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    margin-bottom: 5px;\r\n}\r\n\r\n.character-name {\r\n    font-weight: bold;\r\n    font-size: 1.1em;\r\n    color: var(--SmartThemeBodyColor);\r\n}\r\n\r\n.character-name .fa-user {\r\n    color: #4CAF50;\r\n    margin-right: 5px;\r\n}\r\n\r\n.character-name.ignored {\r\n    color: var(--SmartThemeQuoteColor);\r\n    text-decoration: line-through;\r\n}\r\n\r\n.character-badge {\r\n    display: inline-block;\r\n    padding: 2px 8px;\r\n    border-radius: 3px;\r\n    font-size: 0.75em;\r\n    font-weight: bold;\r\n    margin-left: 5px;\r\n}\r\n\r\n.character-badge.main-char {\r\n    background-color: #4CAF50;\r\n    color: #fff;\r\n}\r\n\r\n.character-badge.ignored {\r\n    background-color: #666;\r\n    color: #fff;\r\n}\r\n\r\n.character-badge.unresolved {\r\n    background-color: #ff9800;\r\n    color: #000;\r\n}\r\n\r\n/* Lorebook entry editor modal */\r\n.lorebook-entry-editor h3 {\r\n    margin-top: 0;\r\n    margin-bottom: 20px;\r\n    color: var(--SmartThemeBodyColor);\r\n}\r\n\r\n.editor-section {\r\n    margin-bottom: 15px;\r\n}\r\n\r\n.editor-section label {\r\n    display: block;\r\n    font-weight: bold;\r\n    margin-bottom: 5px;\r\n    color: var(--SmartThemeBodyColor);\r\n}\r\n\r\n.editor-section small {\r\n    display: block;\r\n    margin-top: 3px;\r\n    color: var(--SmartThemeQuoteColor);\r\n    font-size: 0.85em;\r\n}\r\n\r\n.editor-section input,\r\n.editor-section textarea {\r\n    width: 100%;\r\n    box-sizing: border-box;\r\n}\r\n\r\n.character-aliases {\r\n    font-size: 0.9em;\r\n    color: var(--SmartThemeQuoteColor);\r\n    margin-bottom: 8px;\r\n    font-style: italic;\r\n}\r\n\r\n.lorebook-entry-id {\r\n    display: inline-block;\r\n    margin-left: 10px;\r\n    padding: 2px 6px;\r\n    background: var(--SmartThemeBlurTintColor);\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    border-radius: 3px;\r\n    font-family: monospace;\r\n    font-size: 0.85em;\r\n    font-style: normal;\r\n    color: var(--SmartThemeQuoteColor);\r\n}\r\n\r\n.character-details {\r\n    font-size: 0.85em;\r\n    color: var(--SmartThemeBodyColor);\r\n    margin: 8px 0;\r\n    padding: 8px;\r\n    background: var(--SmartThemeBlurTintColor);\r\n    border-left: 2px solid var(--SmartThemeBorderColor);\r\n    border-radius: 3px;\r\n    line-height: 1.4;\r\n}\r\n\r\n.character-actions {\r\n    display: flex;\r\n    gap: 5px;\r\n    flex-wrap: wrap;\r\n    margin-top: 8px;\r\n}\r\n\r\n.character-actions .menu_button {\r\n    flex: 1;\r\n    min-width: 100px;\r\n    padding: 5px 10px;\r\n    font-size: 0.9em;\r\n}\r\n\r\n.menu_button.compact {\r\n    padding: 5px 10px;\r\n    font-size: 0.9em;\r\n}\r\n\r\n.name-tracker-empty {\r\n    color: var(--SmartThemeQuoteColor);\r\n    font-style: italic;\r\n    text-align: center;\r\n    padding: 20px;\r\n}\r\n\r\n/* Ollama Settings */\r\n.ollama-settings {\r\n    background-color: var(--SmartThemeBlurTintColor);\r\n    border-left: 3px solid var(--SmartThemeBorderColor);\r\n    padding: 10px;\r\n    margin-top: 5px;\r\n    border-radius: 5px;\r\n}\r\n\r\n/* Merge Dialog */\r\n.merge-dialog {\r\n    padding: 15px;\r\n}\r\n\r\n.merge-dialog p {\r\n    margin-bottom: 10px;\r\n}\r\n\r\n.merge-dialog strong {\r\n    color: var(--SmartThemeBodyColor);\r\n    font-weight: bold;\r\n}\r\n\r\n.merge-warning {\r\n    color: #ff9800;\r\n    font-size: 0.9em;\r\n    margin-top: 10px;\r\n    padding: 10px;\r\n    background-color: rgba(255, 152, 0, 0.1);\r\n    border-left: 3px solid #ff9800;\r\n    border-radius: 3px;\r\n}\r\n\r\n/* Button states */\r\nbutton:disabled {\r\n    opacity: 0.5;\r\n    cursor: not-allowed;\r\n}\r\n\r\n/* Flex utilities */\r\n.flexGap5 {\r\n    gap: 5px;\r\n}\r\n\r\n.flex1 {\r\n    flex: 1;\r\n}\r\n\r\n/* Progress indicator */\r\n.name-tracker-progress {\r\n    margin: 10px 0;\r\n    padding: 10px;\r\n    background-color: var(--SmartThemeBlurTintColor);\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    border-radius: 5px;\r\n    text-align: center;\r\n}\r\n\r\n.name-tracker-progress .progress-text {\r\n    margin-bottom: 5px;\r\n    font-weight: bold;\r\n}\r\n\r\n.name-tracker-progress .progress-bar {\r\n    width: 100%;\r\n    height: 20px;\r\n    background-color: var(--black50a);\r\n    border-radius: 10px;\r\n    overflow: hidden;\r\n}\r\n\r\n.name-tracker-progress .progress-fill {\r\n    height: 100%;\r\n    background-color: var(--SmartThemeQuoteColor);\r\n    transition: width 0.3s ease;\r\n}\r\n\r\n/* Character details preview (for potential future use) */\r\n.character-details {\r\n    display: none;\r\n    margin-top: 10px;\r\n    padding: 10px;\r\n    background-color: var(--black30a);\r\n    border-radius: 5px;\r\n    font-size: 0.9em;\r\n}\r\n\r\n.character-details.expanded {\r\n    display: block;\r\n}\r\n\r\n.character-details-section {\r\n    margin-bottom: 8px;\r\n}\r\n\r\n.character-details-section:last-child {\r\n    margin-bottom: 0;\r\n}\r\n\r\n.character-details-label {\r\n    font-weight: bold;\r\n    color: var(--SmartThemeQuoteColor);\r\n    margin-right: 5px;\r\n}\r\n\r\n/* Responsive adjustments */\r\n@media (max-width: 768px) {\r\n    .character-actions {\r\n        flex-direction: column;\r\n    }\r\n    \r\n    .character-actions .menu_button {\r\n        width: 100%;\r\n    }\r\n}\r\n\r\n/* Animation for new characters */\r\n@keyframes fadeIn {\r\n    from {\r\n        opacity: 0;\r\n        transform: translateY(-10px);\r\n    }\r\n    to {\r\n        opacity: 1;\r\n        transform: translateY(0);\r\n    }\r\n}\r\n\r\n.name-tracker-character.new {\r\n    animation: fadeIn 0.3s ease;\r\n}\r\n\r\n/* System Prompt Editor */\r\n.system-prompt-editor h3 {\r\n    margin-top: 0;\r\n    margin-bottom: 10px;\r\n    color: var(--SmartThemeBodyColor);\r\n}\r\n\r\n.system-prompt-editor p {\r\n    margin-bottom: 10px;\r\n    color: var(--SmartThemeQuoteColor);\r\n    font-size: 0.9em;\r\n}\r\n\r\n#system_prompt_editor {\r\n    background-color: var(--SmartThemeBlurTintColor);\r\n    color: var(--SmartThemeBodyColor);\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    border-radius: 3px;\r\n    padding: 10px;\r\n    resize: vertical;\r\n}\r\n\r\n#system_prompt_editor:focus {\r\n    outline: none;\r\n    border-color: var(--SmartThemeEmColor);\r\n}\r\n\r\n.system-prompt-actions button {\r\n    min-width: 100px;\r\n}\r\n\r\n#system_prompt_reset {\r\n    margin-right: auto;\r\n}\r\n\r\n\r\n`, \"\",{\"version\":3,\"sources\":[\"webpack://./style.css\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"/* Styles for the Name Tracker extension */\\r\\n\\r\\n.name-tracker-settings {\\r\\n    padding: 5px;\\r\\n}\\r\\n\\r\\n.name-tracker_block {\\r\\n    margin-bottom: 10px;\\r\\n}\\r\\n\\r\\n.name-tracker_block h4 {\\r\\n    margin-top: 10px;\\r\\n    margin-bottom: 10px;\\r\\n    font-weight: bold;\\r\\n}\\r\\n\\r\\n/* Status Display */\\r\\n.name-tracker-status-block {\\r\\n    background-color: var(--SmartThemeBlurTintColor);\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 5px;\\r\\n    padding: 10px;\\r\\n}\\r\\n\\r\\n.name-tracker-status {\\r\\n    font-weight: bold;\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n    padding: 5px;\\r\\n    text-align: center;\\r\\n}\\r\\n\\r\\n/* Character List */\\r\\n.name-tracker-character-list {\\r\\n    max-height: 400px;\\r\\n    overflow-y: auto;\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 5px;\\r\\n    padding: 5px;\\r\\n    margin-top: 5px;\\r\\n}\\r\\n\\r\\n.name-tracker-character {\\r\\n    padding: 10px;\\r\\n    margin-bottom: 10px;\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 5px;\\r\\n    background-color: var(--SmartThemeBlurTintColor);\\r\\n}\\r\\n\\r\\n.name-tracker-character:last-child {\\r\\n    margin-bottom: 0;\\r\\n}\\r\\n\\r\\n/* Active/loaded character styling (characters that are loaded in SillyTavern) */\\r\\n.name-tracker-character.main-character {\\r\\n    border-left: 3px solid #4CAF50;\\r\\n    background-color: rgba(76, 175, 80, 0.05);\\r\\n}\\r\\n\\r\\n.character-header {\\r\\n    display: flex;\\r\\n    justify-content: space-between;\\r\\n    align-items: center;\\r\\n    margin-bottom: 5px;\\r\\n}\\r\\n\\r\\n.character-name {\\r\\n    font-weight: bold;\\r\\n    font-size: 1.1em;\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n}\\r\\n\\r\\n.character-name .fa-user {\\r\\n    color: #4CAF50;\\r\\n    margin-right: 5px;\\r\\n}\\r\\n\\r\\n.character-name.ignored {\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n    text-decoration: line-through;\\r\\n}\\r\\n\\r\\n.character-badge {\\r\\n    display: inline-block;\\r\\n    padding: 2px 8px;\\r\\n    border-radius: 3px;\\r\\n    font-size: 0.75em;\\r\\n    font-weight: bold;\\r\\n    margin-left: 5px;\\r\\n}\\r\\n\\r\\n.character-badge.main-char {\\r\\n    background-color: #4CAF50;\\r\\n    color: #fff;\\r\\n}\\r\\n\\r\\n.character-badge.ignored {\\r\\n    background-color: #666;\\r\\n    color: #fff;\\r\\n}\\r\\n\\r\\n.character-badge.unresolved {\\r\\n    background-color: #ff9800;\\r\\n    color: #000;\\r\\n}\\r\\n\\r\\n/* Lorebook entry editor modal */\\r\\n.lorebook-entry-editor h3 {\\r\\n    margin-top: 0;\\r\\n    margin-bottom: 20px;\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n}\\r\\n\\r\\n.editor-section {\\r\\n    margin-bottom: 15px;\\r\\n}\\r\\n\\r\\n.editor-section label {\\r\\n    display: block;\\r\\n    font-weight: bold;\\r\\n    margin-bottom: 5px;\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n}\\r\\n\\r\\n.editor-section small {\\r\\n    display: block;\\r\\n    margin-top: 3px;\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n    font-size: 0.85em;\\r\\n}\\r\\n\\r\\n.editor-section input,\\r\\n.editor-section textarea {\\r\\n    width: 100%;\\r\\n    box-sizing: border-box;\\r\\n}\\r\\n\\r\\n.character-aliases {\\r\\n    font-size: 0.9em;\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n    margin-bottom: 8px;\\r\\n    font-style: italic;\\r\\n}\\r\\n\\r\\n.lorebook-entry-id {\\r\\n    display: inline-block;\\r\\n    margin-left: 10px;\\r\\n    padding: 2px 6px;\\r\\n    background: var(--SmartThemeBlurTintColor);\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 3px;\\r\\n    font-family: monospace;\\r\\n    font-size: 0.85em;\\r\\n    font-style: normal;\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n}\\r\\n\\r\\n.character-details {\\r\\n    font-size: 0.85em;\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n    margin: 8px 0;\\r\\n    padding: 8px;\\r\\n    background: var(--SmartThemeBlurTintColor);\\r\\n    border-left: 2px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 3px;\\r\\n    line-height: 1.4;\\r\\n}\\r\\n\\r\\n.character-actions {\\r\\n    display: flex;\\r\\n    gap: 5px;\\r\\n    flex-wrap: wrap;\\r\\n    margin-top: 8px;\\r\\n}\\r\\n\\r\\n.character-actions .menu_button {\\r\\n    flex: 1;\\r\\n    min-width: 100px;\\r\\n    padding: 5px 10px;\\r\\n    font-size: 0.9em;\\r\\n}\\r\\n\\r\\n.menu_button.compact {\\r\\n    padding: 5px 10px;\\r\\n    font-size: 0.9em;\\r\\n}\\r\\n\\r\\n.name-tracker-empty {\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n    font-style: italic;\\r\\n    text-align: center;\\r\\n    padding: 20px;\\r\\n}\\r\\n\\r\\n/* Ollama Settings */\\r\\n.ollama-settings {\\r\\n    background-color: var(--SmartThemeBlurTintColor);\\r\\n    border-left: 3px solid var(--SmartThemeBorderColor);\\r\\n    padding: 10px;\\r\\n    margin-top: 5px;\\r\\n    border-radius: 5px;\\r\\n}\\r\\n\\r\\n/* Merge Dialog */\\r\\n.merge-dialog {\\r\\n    padding: 15px;\\r\\n}\\r\\n\\r\\n.merge-dialog p {\\r\\n    margin-bottom: 10px;\\r\\n}\\r\\n\\r\\n.merge-dialog strong {\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n    font-weight: bold;\\r\\n}\\r\\n\\r\\n.merge-warning {\\r\\n    color: #ff9800;\\r\\n    font-size: 0.9em;\\r\\n    margin-top: 10px;\\r\\n    padding: 10px;\\r\\n    background-color: rgba(255, 152, 0, 0.1);\\r\\n    border-left: 3px solid #ff9800;\\r\\n    border-radius: 3px;\\r\\n}\\r\\n\\r\\n/* Button states */\\r\\nbutton:disabled {\\r\\n    opacity: 0.5;\\r\\n    cursor: not-allowed;\\r\\n}\\r\\n\\r\\n/* Flex utilities */\\r\\n.flexGap5 {\\r\\n    gap: 5px;\\r\\n}\\r\\n\\r\\n.flex1 {\\r\\n    flex: 1;\\r\\n}\\r\\n\\r\\n/* Progress indicator */\\r\\n.name-tracker-progress {\\r\\n    margin: 10px 0;\\r\\n    padding: 10px;\\r\\n    background-color: var(--SmartThemeBlurTintColor);\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 5px;\\r\\n    text-align: center;\\r\\n}\\r\\n\\r\\n.name-tracker-progress .progress-text {\\r\\n    margin-bottom: 5px;\\r\\n    font-weight: bold;\\r\\n}\\r\\n\\r\\n.name-tracker-progress .progress-bar {\\r\\n    width: 100%;\\r\\n    height: 20px;\\r\\n    background-color: var(--black50a);\\r\\n    border-radius: 10px;\\r\\n    overflow: hidden;\\r\\n}\\r\\n\\r\\n.name-tracker-progress .progress-fill {\\r\\n    height: 100%;\\r\\n    background-color: var(--SmartThemeQuoteColor);\\r\\n    transition: width 0.3s ease;\\r\\n}\\r\\n\\r\\n/* Character details preview (for potential future use) */\\r\\n.character-details {\\r\\n    display: none;\\r\\n    margin-top: 10px;\\r\\n    padding: 10px;\\r\\n    background-color: var(--black30a);\\r\\n    border-radius: 5px;\\r\\n    font-size: 0.9em;\\r\\n}\\r\\n\\r\\n.character-details.expanded {\\r\\n    display: block;\\r\\n}\\r\\n\\r\\n.character-details-section {\\r\\n    margin-bottom: 8px;\\r\\n}\\r\\n\\r\\n.character-details-section:last-child {\\r\\n    margin-bottom: 0;\\r\\n}\\r\\n\\r\\n.character-details-label {\\r\\n    font-weight: bold;\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n    margin-right: 5px;\\r\\n}\\r\\n\\r\\n/* Responsive adjustments */\\r\\n@media (max-width: 768px) {\\r\\n    .character-actions {\\r\\n        flex-direction: column;\\r\\n    }\\r\\n    \\r\\n    .character-actions .menu_button {\\r\\n        width: 100%;\\r\\n    }\\r\\n}\\r\\n\\r\\n/* Animation for new characters */\\r\\n@keyframes fadeIn {\\r\\n    from {\\r\\n        opacity: 0;\\r\\n        transform: translateY(-10px);\\r\\n    }\\r\\n    to {\\r\\n        opacity: 1;\\r\\n        transform: translateY(0);\\r\\n    }\\r\\n}\\r\\n\\r\\n.name-tracker-character.new {\\r\\n    animation: fadeIn 0.3s ease;\\r\\n}\\r\\n\\r\\n/* System Prompt Editor */\\r\\n.system-prompt-editor h3 {\\r\\n    margin-top: 0;\\r\\n    margin-bottom: 10px;\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n}\\r\\n\\r\\n.system-prompt-editor p {\\r\\n    margin-bottom: 10px;\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n    font-size: 0.9em;\\r\\n}\\r\\n\\r\\n#system_prompt_editor {\\r\\n    background-color: var(--SmartThemeBlurTintColor);\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 3px;\\r\\n    padding: 10px;\\r\\n    resize: vertical;\\r\\n}\\r\\n\\r\\n#system_prompt_editor:focus {\\r\\n    outline: none;\\r\\n    border-color: var(--SmartThemeEmColor);\\r\\n}\\r\\n\\r\\n.system-prompt-actions button {\\r\\n    min-width: 100px;\\r\\n}\\r\\n\\r\\n#system_prompt_reset {\\r\\n    margin-right: auto;\\r\\n}\\r\\n\\r\\n\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","/**\r\n * SillyTavern context abstraction layer for Name Tracker extension\r\n * Provides a thin wrapper around SillyTavern.getContext() with error handling\r\n */\r\n\r\nimport debugLogger from './debug.js';\r\nimport { errorHandler } from './errors.js';\r\n\r\nconst logger = debugLogger.createModuleLogger('Context');\r\n\r\nclass SillyTavernContext {\r\n    constructor() {\r\n        this._context = null;\r\n        this._lastUpdate = 0;\r\n        this._updateInterval = 1000; // Cache context for 1 second\r\n    }\r\n\r\n    /**\r\n     * Get fresh SillyTavern context\r\n     * @returns {Object} SillyTavern context object\r\n     */\r\n    getContext() {\r\n        const now = Date.now();\r\n        if (!this._context || (now - this._lastUpdate) > this._updateInterval) {\r\n            try {\r\n                this._context = SillyTavern.getContext();\r\n                this._lastUpdate = now;\r\n            } catch (error) {\r\n                logger.error('Failed to get SillyTavern context:', error);\r\n                throw new Error('SillyTavern context not available');\r\n            }\r\n        }\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * Get current chat\r\n     * @returns {Array} Current chat messages\r\n     */\r\n    getChat() {\r\n        return this.getContext().chat || [];\r\n    }\r\n\r\n    /**\r\n     * Get current chat metadata\r\n     * @returns {Object} Chat metadata object\r\n     */\r\n    getChatMetadata() {\r\n        return this.getContext().chatMetadata || {};\r\n    }\r\n\r\n    /**\r\n     * Get current chat ID\r\n     * @returns {string|null} Chat identifier\r\n     */\r\n    getChatId() {\r\n        return this.getContext().chatId || null;\r\n    }\r\n\r\n    /**\r\n     * Get current character ID\r\n     * @returns {number|null} Character index\r\n     */\r\n    getCharacterId() {\r\n        return this.getContext().characterId;\r\n    }\r\n\r\n    /**\r\n     * Get characters list\r\n     * @returns {Array} Available characters\r\n     */\r\n    getCharacters() {\r\n        return this.getContext().characters || [];\r\n    }\r\n\r\n    /**\r\n     * Get user name (name1)\r\n     * @returns {string} User's persona name\r\n     */\r\n    getUserName() {\r\n        return this.getContext().name1 || 'User';\r\n    }\r\n\r\n    /**\r\n     * Get extension settings object\r\n     * @returns {Object} Extension settings\r\n     */\r\n    getExtensionSettings() {\r\n        return this.getContext().extensionSettings || {};\r\n    }\r\n\r\n    /**\r\n     * Save extension settings\r\n     * @returns {Promise<void>}\r\n     */\r\n    async saveExtensionSettings() {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            if (context.saveSettingsDebounced) {\r\n                context.saveSettingsDebounced();\r\n            } else {\r\n                logger.warn('saveSettingsDebounced not available');\r\n            }\r\n        }, { silent: true });\r\n    }\r\n\r\n    /**\r\n     * Save chat metadata\r\n     * @returns {Promise<void>}\r\n     */\r\n    async saveChatMetadata() {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            if (context.saveMetadata) {\r\n                await context.saveMetadata();\r\n            } else {\r\n                logger.warn('saveMetadata not available');\r\n            }\r\n        }, { silent: true });\r\n    }\r\n\r\n    /**\r\n     * Generate quiet prompt (background LLM call)\r\n     * @param {Object} options - Generation options\r\n     * @returns {Promise<string>} Generated text\r\n     */\r\n    async generateQuietPrompt(options) {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            if (!context.generateQuietPrompt) {\r\n                throw new Error('generateQuietPrompt not available');\r\n            }\r\n            return await context.generateQuietPrompt(options);\r\n        }, { retries: 1 });\r\n    }\r\n\r\n    /**\r\n     * Load world info (lorebook)\r\n     * @param {string} lorebookName - Name of lorebook to load\r\n     * @returns {Promise<Object|null>} Lorebook data\r\n     */\r\n    async loadWorldInfo(lorebookName) {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            if (!context.loadWorldInfo) {\r\n                throw new Error('loadWorldInfo not available');\r\n            }\r\n            return await context.loadWorldInfo(lorebookName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Save world info (lorebook)\r\n     * @param {string} lorebookName - Name of lorebook\r\n     * @param {Object} data - Lorebook data\r\n     * @param {boolean} create - Create if doesn't exist\r\n     * @returns {Promise<void>}\r\n     */\r\n    async saveWorldInfo(lorebookName, data, create = false) {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            if (!context.saveWorldInfo) {\r\n                throw new Error('saveWorldInfo not available');\r\n            }\r\n            return await context.saveWorldInfo(lorebookName, data, create);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Save world info entry\r\n     * @param {string} lorebookName - Lorebook name\r\n     * @param {Object} entryData - Entry data\r\n     * @returns {Promise<void>}\r\n     */\r\n    async saveWorldInfoEntry(lorebookName, entryData) {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            if (!context.saveWorldInfoEntry) {\r\n                throw new Error('saveWorldInfoEntry not available');\r\n            }\r\n            return await context.saveWorldInfoEntry(lorebookName, entryData);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get event source for listening to SillyTavern events\r\n     * @returns {Object} Event source object\r\n     */\r\n    getEventSource() {\r\n        const context = this.getContext();\r\n        return context.eventSource;\r\n    }\r\n\r\n    /**\r\n     * Get event types constants\r\n     * @returns {Object} Event types\r\n     */\r\n    getEventTypes() {\r\n        const context = this.getContext();\r\n        return context.event_types;\r\n    }\r\n\r\n    /**\r\n     * Call generic popup\r\n     * @param {string} content - HTML content\r\n     * @param {number} type - Popup type\r\n     * @param {string} input - Input placeholder\r\n     * @param {Object} options - Additional options\r\n     * @returns {Promise<any>} Popup result\r\n     */\r\n    async callGenericPopup(content, type, input = '', options = {}) {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            if (!context.callGenericPopup) {\r\n                throw new Error('callGenericPopup not available');\r\n            }\r\n            return await context.callGenericPopup(content, type, input, options);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if SillyTavern context is available\r\n     * @returns {boolean} Context availability\r\n     */\r\n    isContextAvailable() {\r\n        try {\r\n            return !!this.getContext();\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear cached context (force refresh on next access)\r\n     */\r\n    clearCache() {\r\n        this._context = null;\r\n        this._lastUpdate = 0;\r\n        logger.debug('Cleared context cache');\r\n    }\r\n\r\n    /**\r\n     * Get context status information for debugging\r\n     * @returns {Object} Context status\r\n     */\r\n    getStatus() {\r\n        return {\r\n            available: this.isContextAvailable(),\r\n            cached: !!this._context,\r\n            lastUpdate: this._lastUpdate,\r\n            chatId: this.getChatId(),\r\n            characterId: this.getCharacterId(),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Dump entire context object to console for debugging\r\n     * Shows all properties and their values in a readable format\r\n     */\r\n    dumpContextToConsole() {\r\n        try {\r\n            const context = this.getContext();\r\n            \r\n            // Create a formatted dump\r\n            const dump = {\r\n                timestamp: new Date().toISOString(),\r\n                availableProperties: Object.keys(context),\r\n                fullContext: context,\r\n                detailedBreakdown: {}\r\n            };\r\n\r\n            // Add detailed breakdown of key properties\r\n            const keyProps = [\r\n                'maxContext', 'maxTokens', 'amount_gen', 'token_limit',\r\n                'extensionSettings', 'settings', 'chat', 'chatMetadata',\r\n                'characters', 'world_info', 'botId', 'characterId', 'chatId',\r\n                'impersonate', 'groups'\r\n            ];\r\n\r\n            for (const prop of keyProps) {\r\n                if (prop in context) {\r\n                    dump.detailedBreakdown[prop] = {\r\n                        type: typeof context[prop],\r\n                        value: context[prop],\r\n                        isNull: context[prop] === null,\r\n                        isUndefined: context[prop] === undefined\r\n                    };\r\n                }\r\n            }\r\n\r\n            // Log to console with formatting\r\n            console.group('%c[Name Tracker] COMPLETE CONTEXT DUMP', 'color: #00ff00; font-weight: bold; font-size: 14px;');\r\n            console.log('%cTimestamp:', 'color: #ffaa00; font-weight: bold;', dump.timestamp);\r\n            console.log('%cTotal Properties:', 'color: #ffaa00; font-weight: bold;', dump.availableProperties.length);\r\n            console.log('%cAll Property Names:', 'color: #00aaff; font-weight: bold;', dump.availableProperties.join(', '));\r\n            console.log('%cDetailed Property Breakdown:', 'color: #ff00ff; font-weight: bold;', dump.detailedBreakdown);\r\n            console.log('%cFull Context Object:', 'color: #00ff00; font-weight: bold;', context);\r\n            console.log('%cJSON Dump (for copying):', 'color: #ffff00; font-weight: bold;', JSON.stringify(dump, null, 2));\r\n            console.groupEnd();\r\n\r\n            return dump;\r\n        } catch (error) {\r\n            console.error('[Name Tracker] ERROR dumping context:', error);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n\r\n// Create singleton instance\r\nconst sillyTavernContext = new SillyTavernContext();\r\n\r\nexport { sillyTavernContext as stContext };\r\nexport default sillyTavernContext;\r\n","\"use strict\";\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;","/**\r\n * Lorebook Management Module\r\n *\r\n * Handles chat-level lorebook creation, entry formatting, and SillyTavern integration\r\n * for the Name Tracker extension.\r\n */\r\n\r\n// Early debugging\r\nconsole.log('[LOREBOOK] Starting module load...');\r\n\r\nimport { createModuleLogger } from '../core/debug.js';\r\nimport { withErrorBoundary, NameTrackerError } from '../core/errors.js';\r\nimport {\r\n    get_settings, getCharacters, getCharacter, setCharacter, getLorebookConfig,\r\n} from '../core/settings.js';\r\nimport { stContext } from '../core/context.js';\r\nimport { generateUID } from '../utils/helpers.js';\r\nimport { NotificationManager } from '../utils/notifications.js';\r\n\r\n// Post-import debugging\r\nconsole.log('[LOREBOOK] Imports completed. Types:');\r\nconsole.log('[LOREBOOK] createModuleLogger:', typeof createModuleLogger);\r\nconsole.log('[LOREBOOK] withErrorBoundary:', typeof withErrorBoundary);\r\nconsole.log('[LOREBOOK] NameTrackerError:', typeof NameTrackerError);\r\n\r\n// Try to create debug logger with explicit error handling\r\nlet debug;\r\ntry {\r\n    console.log('[LOREBOOK] About to call createModuleLogger...');\r\n    debug = createModuleLogger('lorebook');\r\n    console.log('[LOREBOOK] Debug logger created successfully:', debug);\r\n} catch (error) {\r\n    console.error('[LOREBOOK] Failed to create debug logger:', error);\r\n    console.error('[LOREBOOK] Error stack:', error.stack);\r\n    // Create fallback logger\r\n    debug = {\r\n        log: console.log.bind(console, '[LOREBOOK]'),\r\n        error: console.error.bind(console, '[LOREBOOK]'),\r\n        warn: console.warn.bind(console, '[LOREBOOK]'),\r\n        debug: console.debug.bind(console, '[LOREBOOK]'),\r\n    };\r\n}\r\nconst notifications = new NotificationManager('Lorebook Management');\r\n\r\n// Lorebook state\r\nlet lorebookName = null;\r\n\r\n/**\r\n * Initialize or get the lorebook for this chat\r\n * @returns {Promise<string|null>} Lorebook name if successful, null if no chat\r\n */\r\nexport async function initializeLorebook() {\r\n    return withErrorBoundary('initializeLorebook', async () => {\r\n        const context = stContext.getContext();\r\n\r\n        if (!context.chatId) {\r\n            debug.log('No active chat, skipping lorebook initialization');\r\n            lorebookName = null;\r\n            return null;\r\n        }\r\n\r\n        const METADATA_KEY = 'world_info';\r\n        const chatMetadata = context.chatMetadata;\r\n\r\n        if (!chatMetadata) {\r\n            debug.log('No chat metadata available, skipping lorebook initialization');\r\n            lorebookName = null;\r\n            return null;\r\n        }\r\n\r\n        // Check if chat already has a bound lorebook\r\n        if (chatMetadata[METADATA_KEY]) {\r\n            lorebookName = chatMetadata[METADATA_KEY];\r\n            debug.log(`Using existing chat lorebook: ${lorebookName}`);\r\n            return lorebookName;\r\n        }\r\n\r\n        // Create a new chat-bound lorebook name\r\n        const bookName = `NameTracker_${context.chatId}`\r\n            .replace(/[^a-z0-9 -]/gi, '_')\r\n            .replace(/_{2,}/g, '_')\r\n            .substring(0, 64);\r\n\r\n        debug.log(`Creating new chat lorebook: ${bookName}`);\r\n        lorebookName = bookName;\r\n\r\n        // Bind it to the chat metadata\r\n        chatMetadata[METADATA_KEY] = lorebookName;\r\n\r\n        // Save chat metadata using context API\r\n        try {\r\n            await context.saveMetadata();\r\n            debug.log(`Bound lorebook to chat: ${lorebookName}`);\r\n\r\n            // Ensure the lorebook file exists (create empty if needed)\r\n            const worldInfo = await context.loadWorldInfo(lorebookName);\r\n            if (!worldInfo) {\r\n                debug.log();\r\n                await context.saveWorldInfo(lorebookName, { entries: {} }, true);\r\n            }\r\n\r\n            // Notify user\r\n            notifications.info(`Chat lorebook \"${lorebookName}\" created and bound to this chat`, { timeOut: 5000 });\r\n        } catch (error) {\r\n            console.error('Failed to initialize lorebook:', error);\r\n            lorebookName = null;\r\n            throw new NameTrackerError(`Failed to initialize lorebook: ${error.message}`);\r\n        }\r\n\r\n        return lorebookName;\r\n    });\r\n}\r\n\r\n/**\r\n * Update or create lorebook entry for a character\r\n * @param {Object} character - Character data\r\n * @param {string} characterName - Character name\r\n * @returns {Promise<void>}\r\n */\r\nexport async function updateLorebookEntry(character, characterName) {\r\n    return withErrorBoundary('updateLorebookEntry', async () => {\r\n        debug.log(`updateLorebookEntry called for: ${characterName}`);\r\n        debug.log('  Character data:', character);\r\n\r\n        if (!lorebookName) {\r\n            debug.log('No lorebook initialized, skipping entry update');\r\n            return;\r\n        }\r\n\r\n        const context = stContext.getContext();\r\n        const lorebookConfig = getLorebookConfig();\r\n\r\n        // Build the entry content in a readable format\r\n        const contentParts = [];\r\n\r\n        // Physical Age / Mental Age\r\n        if (character.physicalAge || character.mentalAge) {\r\n            const ageInfo = [];\r\n            if (character.physicalAge) ageInfo.push(`Physical: ${character.physicalAge}`);\r\n            if (character.mentalAge) ageInfo.push(`Mental: ${character.mentalAge}`);\r\n            contentParts.push(`**Age:** ${ageInfo.join(', ')}`);\r\n        }\r\n\r\n        // Physical (consolidated body description)\r\n        if (character.physical) {\r\n            contentParts.push(`\\n**Physical Description:**\\n${character.physical}`);\r\n        }\r\n\r\n        // Personality (consolidated traits, likes, dislikes)\r\n        if (character.personality) {\r\n            contentParts.push(`\\n**Personality:**\\n${character.personality}`);\r\n        }\r\n\r\n        // Sexuality\r\n        if (character.sexuality) {\r\n            contentParts.push(`\\n**Sexuality:**\\n${character.sexuality}`);\r\n        }\r\n\r\n        // Race/Ethnicity\r\n        if (character.raceEthnicity) {\r\n            contentParts.push(`**Race/Ethnicity:** ${character.raceEthnicity}`);\r\n        }\r\n\r\n        // Role & Skills\r\n        if (character.roleSkills) {\r\n            contentParts.push(`\\n**Role & Skills:**\\n${character.roleSkills}`);\r\n        }\r\n\r\n        // Last Interaction\r\n        if (character.lastInteraction) {\r\n            contentParts.push(`\\n**Last Interaction with {{user}}:**\\n${character.lastInteraction}`);\r\n        }\r\n\r\n        // Relationships\r\n        if (character.relationships && character.relationships.length > 0) {\r\n            contentParts.push('\\n**Relationships:**');\r\n            character.relationships.forEach(rel => {\r\n                contentParts.push(`- ${rel}`);\r\n            });\r\n        }\r\n\r\n        const content = contentParts.join('\\n');\r\n\r\n        // Build the keys array (name + aliases)\r\n        const keys = [character.preferredName];\r\n        if (character.aliases) {\r\n            keys.push(...character.aliases);\r\n        }\r\n\r\n        // Load the world info to check if entry exists\r\n        let worldInfo = await context.loadWorldInfo(lorebookName);\r\n\r\n        if (!worldInfo) {\r\n            debug.log();\r\n            // Match SillyTavern's world info structure\r\n            worldInfo = {\r\n                entries: {},\r\n            };\r\n        }\r\n\r\n        // Calculate dynamic cooldown\r\n        const messageFreq = get_settings('messageFrequency', 10);\r\n        const calculatedCooldown = Math.max(1, Math.floor(messageFreq * 0.75));\r\n\r\n        let existingUid = null;\r\n\r\n        // Check if this character already has a lorebook entry\r\n        if (character.lorebookEntryId && worldInfo.entries && worldInfo.entries[character.lorebookEntryId]) {\r\n            // Update existing entry\r\n            existingUid = character.lorebookEntryId;\r\n            const existingEntry = worldInfo.entries[existingUid];\r\n\r\n            existingEntry.key = keys;\r\n            existingEntry.content = content;\r\n            existingEntry.enabled = lorebookConfig.enabled;\r\n            existingEntry.position = lorebookConfig.position;\r\n            existingEntry.probability = lorebookConfig.probability;\r\n            existingEntry.depth = lorebookConfig.depth;\r\n            existingEntry.scanDepth = lorebookConfig.scanDepth;\r\n            existingEntry.cooldown = calculatedCooldown;\r\n\r\n            debug.log();\r\n        } else {\r\n            // Create new entry\r\n            const newUid = generateUID();\r\n\r\n            const newEntry = {\r\n                uid: newUid,\r\n                key: keys,\r\n                keysecondary: [],\r\n                comment: `Auto-generated entry for ${character.preferredName}`,\r\n                content: content,\r\n                constant: false,\r\n                selective: true,\r\n                contextConfig: {\r\n                    prefix: '',\r\n                    suffix: '',\r\n                    tokenBudget: 0,\r\n                    reservedTokens: 0,\r\n                    budgetPriority: 400,\r\n                    trimDirection: 'doNotTrim',\r\n                    insertionOrder: 0,\r\n                    maximumTrimType: 'sentence',\r\n                    insertionPosition: 'before',\r\n                },\r\n                enabled: lorebookConfig.enabled,\r\n                position: lorebookConfig.position,\r\n                excludeRecursion: false,\r\n                preventRecursion: false,\r\n                delayUntilRecursion: false,\r\n                probability: lorebookConfig.probability,\r\n                useProbability: true,\r\n                depth: lorebookConfig.depth,\r\n                selectiveLogic: 0,\r\n                group: '',\r\n                scanDepth: lorebookConfig.scanDepth,\r\n                caseSensitive: null,\r\n                matchWholeWords: null,\r\n                useGroupScoring: null,\r\n                automationId: '',\r\n                role: 0,\r\n                vectorized: false,\r\n                sticky: 0,\r\n                cooldown: calculatedCooldown,\r\n                delay: 0,\r\n            };\r\n\r\n            // World info entries are stored as an object with UID as key\r\n            worldInfo.entries[newUid] = newEntry;\r\n            character.lorebookEntryId = newUid;\r\n\r\n            debug.log();\r\n        }\r\n\r\n        // Save the lorebook\r\n        try {\r\n            await context.saveWorldInfo(lorebookName, worldInfo, true);\r\n\r\n            // Verify the save worked by reloading\r\n            const verifyWorldInfo = await context.loadWorldInfo(lorebookName);\r\n            const targetUid = existingUid || character.lorebookEntryId;\r\n\r\n            if (verifyWorldInfo && verifyWorldInfo.entries && verifyWorldInfo.entries[targetUid]) {\r\n                debug.log();\r\n            } else {\r\n                console.error('[Name Tracker] WARNING: Lorebook verification failed - entries may not have been saved!');\r\n            }\r\n\r\n            debug.log();\r\n        } catch (error) {\r\n            console.error('[Name Tracker] Error saving lorebook:', error);\r\n            debug.log();\r\n            throw error; // Re-throw so caller knows it failed\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Create lorebook content from character data (JSON format)\r\n * @param {Object} character - Character data\r\n * @returns {string} JSON string representation\r\n */\r\nexport function createLorebookContent(character) {\r\n    return withErrorBoundary('createLorebookContent', () => {\r\n        const content = {\r\n            name: character.preferredName,\r\n            aliases: character.aliases,\r\n            physical: character.physical,\r\n            mental: character.mental,\r\n            relationships: character.relationships,\r\n        };\r\n\r\n        return JSON.stringify(content, null, 2);\r\n    });\r\n}\r\n\r\n/**\r\n * View character in lorebook editor\r\n * @param {string} characterName - Name of character to view\r\n * @returns {Promise<void>}\r\n */\r\nexport async function viewInLorebook(characterName) {\r\n    return withErrorBoundary('viewInLorebook', async () => {\r\n        const character = getCharacter(characterName);\r\n\r\n        if (!character) {\r\n            throw new NameTrackerError('Character not found');\r\n        }\r\n\r\n        if (!lorebookName) {\r\n            notifications.warning('No active chat or lorebook');\r\n            return;\r\n        }\r\n\r\n        // Import the openWorldInfoEditor function from SillyTavern\r\n        const context = stContext.getContext();\r\n\r\n        // Open the lorebook editor\r\n        if (typeof context.openWorldInfoEditor === 'function') {\r\n            await context.openWorldInfoEditor(lorebookName);\r\n            notifications.success(`Opened lorebook for ${characterName}`);\r\n        } else {\r\n            // Fallback: show the world info panel if openWorldInfoEditor doesn't exist\r\n            $('#WorldInfo').click();\r\n            notifications.info(`Please select \"${lorebookName}\" from the World Info panel`);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Delete a character's lorebook entry\r\n * @param {Object} character - Character data\r\n * @returns {Promise<boolean>} True if deleted successfully\r\n */\r\nexport async function deleteLorebookEntry(character) {\r\n    return withErrorBoundary('deleteLorebookEntry', async () => {\r\n        if (!lorebookName || !character.lorebookEntryId) {\r\n            debug.log();\r\n            return false;\r\n        }\r\n\r\n        const context = stContext.getContext();\r\n\r\n        try {\r\n            const worldInfo = await context.loadWorldInfo(lorebookName);\r\n            if (worldInfo && worldInfo.entries && worldInfo.entries[character.lorebookEntryId]) {\r\n                delete worldInfo.entries[character.lorebookEntryId];\r\n                await context.saveWorldInfo(lorebookName, worldInfo, true);\r\n\r\n                debug.log();\r\n                return true;\r\n            }\r\n        } catch (error) {\r\n            console.error('Error deleting lorebook entry:', error);\r\n            return false;\r\n        }\r\n\r\n        return false;\r\n    });\r\n}\r\n\r\n/**\r\n * Purge all tracked character entries from lorebook\r\n * @param {Array} characters - Array of character objects to purge\r\n * @returns {Promise<number>} Number of entries deleted\r\n */\r\nexport async function purgeLorebookEntries(characters) {\r\n    return withErrorBoundary('purgeLorebookEntries', async () => {\r\n        if (!lorebookName) {\r\n            debug.log();\r\n            return 0;\r\n        }\r\n\r\n        const context = stContext.getContext();\r\n        let deletedCount = 0;\r\n\r\n        try {\r\n            const worldInfo = await context.loadWorldInfo(lorebookName);\r\n\r\n            if (worldInfo && worldInfo.entries) {\r\n                // Get all entry IDs from our tracked characters\r\n                const entryIds = characters\r\n                    .map(char => char.lorebookEntryId)\r\n                    .filter(id => id !== undefined && id !== null);\r\n\r\n                // Delete each entry\r\n                for (const entryId of entryIds) {\r\n                    if (worldInfo.entries[entryId]) {\r\n                        delete worldInfo.entries[entryId];\r\n                        deletedCount++;\r\n                        debug.log();\r\n                    }\r\n                }\r\n\r\n                // Save the lorebook\r\n                await context.saveWorldInfo(lorebookName, worldInfo, true);\r\n            }\r\n        } catch (error) {\r\n            console.error('Error purging lorebook entries:', error);\r\n            throw new NameTrackerError(`Failed to purge lorebook entries: ${error.message}`);\r\n        }\r\n\r\n        return deletedCount;\r\n    });\r\n}\r\n\r\n/**\r\n * Adopt existing lorebook entries into character cache\r\n * This allows manual entries or previous data to be imported\r\n * @returns {Promise<number>} Number of entries adopted\r\n */\r\nexport async function adoptExistingEntries() {\r\n    return withErrorBoundary('adoptExistingEntries', async () => {\r\n        if (!lorebookName) {\r\n            debug.log();\r\n            return 0;\r\n        }\r\n\r\n        const context = stContext.getContext();\r\n        let adoptedCount = 0;\r\n\r\n        try {\r\n            const worldInfo = await context.loadWorldInfo(lorebookName);\r\n\r\n            if (!worldInfo || !worldInfo.entries) {\r\n                debug.log();\r\n                return 0;\r\n            }\r\n\r\n            const characters = getCharacters();\r\n\r\n            // Look for entries that might belong to our extension\r\n            for (const [entryId, entry] of Object.entries(worldInfo.entries)) {\r\n                if (!entry.key || !Array.isArray(entry.key) || entry.key.length === 0) {\r\n                    continue;\r\n                }\r\n\r\n                const primaryName = entry.key[0];\r\n\r\n                // Check if this entry represents a character we should track\r\n                if (!characters[primaryName] && entry.comment?.includes('Auto-generated entry for')) {\r\n                    // Try to parse the content to recreate character data\r\n                    const character = {\r\n                        preferredName: primaryName,\r\n                        aliases: entry.key.slice(1),\r\n                        physical: '',\r\n                        personality: '',\r\n                        sexuality: '',\r\n                        raceEthnicity: '',\r\n                        roleSkills: '',\r\n                        lastInteraction: '',\r\n                        relationships: [],\r\n                        ignored: false,\r\n                        confidence: 50,\r\n                        lorebookEntryId: entryId,\r\n                        lastUpdated: Date.now(),\r\n                        isMainChar: false,\r\n                    };\r\n\r\n                    // Store the adopted character\r\n                    setCharacter(primaryName, character);\r\n                    adoptedCount++;\r\n\r\n                    debug.log();\r\n                }\r\n            }\r\n\r\n            if (adoptedCount > 0) {\r\n                notifications.success(`Adopted ${adoptedCount} existing lorebook entries`);\r\n            }\r\n\r\n        } catch (error) {\r\n            console.error('Error adopting existing entries:', error);\r\n            throw new NameTrackerError(`Failed to adopt existing entries: ${error.message}`);\r\n        }\r\n\r\n        return adoptedCount;\r\n    });\r\n}\r\n\r\n/**\r\n * Get the current lorebook name\r\n * @returns {string|null} Current lorebook name\r\n */\r\nexport function getCurrentLorebookName() {\r\n    return lorebookName;\r\n}\r\n\r\n/**\r\n * Reset lorebook state (called on chat change)\r\n */\r\nexport function resetLorebookState() {\r\n    lorebookName = null;\r\n    debug.log();\r\n}\r\n\r\n/**\r\n * Get lorebook statistics\r\n * @returns {Promise<Object>} Lorebook statistics\r\n */\r\nexport async function getLorebookStats() {\r\n    return withErrorBoundary('getLorebookStats', async () => {\r\n        if (!lorebookName) {\r\n            return {\r\n                name: null,\r\n                entryCount: 0,\r\n                trackedEntries: 0,\r\n                orphanedEntries: 0,\r\n            };\r\n        }\r\n\r\n        const context = stContext.getContext();\r\n\r\n        try {\r\n            const worldInfo = await context.loadWorldInfo(lorebookName);\r\n            const characters = getCharacters();\r\n\r\n            if (!worldInfo || !worldInfo.entries) {\r\n                return {\r\n                    name: lorebookName,\r\n                    entryCount: 0,\r\n                    trackedEntries: 0,\r\n                    orphanedEntries: 0,\r\n                };\r\n            }\r\n\r\n            const totalEntries = Object.keys(worldInfo.entries).length;\r\n            const trackedIds = Object.values(characters)\r\n                .map(char => char.lorebookEntryId)\r\n                .filter(id => id);\r\n            const trackedEntries = trackedIds.length;\r\n            const orphanedEntries = totalEntries - trackedEntries;\r\n\r\n            return {\r\n                name: lorebookName,\r\n                entryCount: totalEntries,\r\n                trackedEntries,\r\n                orphanedEntries,\r\n            };\r\n        } catch (error) {\r\n            console.error('Error getting lorebook stats:', error);\r\n            return {\r\n                name: lorebookName,\r\n                entryCount: 0,\r\n                trackedEntries: 0,\r\n                orphanedEntries: 0,\r\n                error: error.message,\r\n            };\r\n        }\r\n    });\r\n}\r\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};","\"use strict\";\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n  if (!cssMapping) {\n    return content;\n  }\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    return [content].concat([sourceMapping]).join(\"\\n\");\n  }\n  return [content].join(\"\\n\");\n};","/**\r\n * Error handling and recovery system for Name Tracker extension\r\n * Provides error boundaries, graceful degradation, and transaction rollback\r\n */\r\n\r\nimport debugLogger from './debug.js';\r\n\r\nconst logger = debugLogger.createModuleLogger('ErrorHandler');\r\n\r\nclass NameTrackerError extends Error {\r\n    constructor(message, code, module, recoverable = true) {\r\n        super(message);\r\n        this.name = 'NameTrackerError';\r\n        this.code = code;\r\n        this.module = module;\r\n        this.recoverable = recoverable;\r\n        this.timestamp = Date.now();\r\n    }\r\n}\r\n\r\nclass ErrorHandler {\r\n    constructor() {\r\n        this.errorHistory = [];\r\n        this.transactionStack = [];\r\n        this.recoveryStrategies = new Map();\r\n        this.criticalErrorCallbacks = [];\r\n    }\r\n\r\n    /**\r\n     * Create error boundary for a module operation\r\n     * @param {string} moduleName - Module name\r\n     * @param {Function} operation - Operation to execute\r\n     * @param {Object} options - Error handling options\r\n     * @returns {Promise<any>} Operation result or error recovery result\r\n     */\r\n    async withErrorBoundary(moduleName, operation, options = {}) {\r\n        const {\r\n            fallback = null,\r\n            retries = 0,\r\n            silent = false,\r\n            operationId = null,\r\n        } = options;\r\n\r\n        let lastError = null;\r\n        const startTime = Date.now();\r\n\r\n        if (operationId) {\r\n            logger.trace(operationId, `Starting operation in ${moduleName}`);\r\n        }\r\n\r\n        for (let attempt = 0; attempt <= retries; attempt++) {\r\n            try {\r\n                const result = await operation();\r\n\r\n                if (operationId) {\r\n                    logger.trace(operationId, `Operation completed successfully in ${moduleName}`);\r\n                }\r\n\r\n                return result;\r\n            } catch (error) {\r\n                console.log(`[STnametracker] Error caught in ${moduleName}:`, error);\r\n                lastError = error;\r\n\r\n                if (attempt < retries) {\r\n                    console.log(`[STnametracker] Retrying operation in ${moduleName}, attempt ${attempt + 1}/${retries + 1}:`, error.message);\r\n                    logger.warn(`Retrying operation in ${moduleName}, attempt ${attempt + 1}/${retries + 1}:`, error.message);\r\n                    await this.delay(Math.pow(2, attempt) * 100); // Exponential backoff\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        // All retries failed\r\n        console.log(`[STnametracker] All retries failed in ${moduleName}, tracking error:`, lastError);\r\n        const trackedError = this.trackError(lastError, moduleName, {\r\n            operation: operation.name || 'anonymous',\r\n            duration: Date.now() - startTime,\r\n            retries: retries,\r\n            operationId: operationId,\r\n        });\r\n\r\n        if (!silent) {\r\n            console.log(`[STnametracker] Notifying user of error in ${moduleName}`);\r\n            this.notifyUser(trackedError);\r\n        }\r\n\r\n        // Try recovery strategy\r\n        if (fallback) {\r\n            try {\r\n                logger.debug(`Attempting fallback for ${moduleName}:`, trackedError.code);\r\n                return await fallback(trackedError);\r\n            } catch (fallbackError) {\r\n                logger.error(`Fallback failed for ${moduleName}:`, fallbackError);\r\n            }\r\n        }\r\n\r\n        // Check if we have a recovery strategy\r\n        const recovery = this.recoveryStrategies.get(trackedError.code);\r\n        if (recovery) {\r\n            try {\r\n                return await recovery(trackedError);\r\n            } catch (recoveryError) {\r\n                logger.error(`Recovery strategy failed for ${trackedError.code}:`, recoveryError);\r\n            }\r\n        }\r\n\r\n        throw trackedError;\r\n    }\r\n\r\n    /**\r\n     * Track and categorize errors\r\n     * @param {Error} error - Original error\r\n     * @param {string} moduleName - Module where error occurred\r\n     * @param {Object} context - Additional context\r\n     * @returns {NameTrackerError} Tracked error\r\n     */\r\n    trackError(error, moduleName, context = {}) {\r\n        let trackedError;\r\n\r\n        if (error instanceof NameTrackerError) {\r\n            trackedError = error;\r\n        } else {\r\n            // Categorize common error types\r\n            const code = this.categorizeError(error, moduleName);\r\n            trackedError = new NameTrackerError(\r\n                error.message,\r\n                code,\r\n                moduleName,\r\n                this.isRecoverable(error, code),\r\n            );\r\n        }\r\n\r\n        trackedError.context = context;\r\n        this.errorHistory.push(trackedError);\r\n\r\n        // Keep only last 100 errors\r\n        if (this.errorHistory.length > 100) {\r\n            this.errorHistory.shift();\r\n        }\r\n\r\n        logger.error(`Error in ${moduleName}:`, {\r\n            code: trackedError.code,\r\n            message: trackedError.message,\r\n            context: context,\r\n        });\r\n\r\n        return trackedError;\r\n    }\r\n\r\n    /**\r\n     * Categorize error types for better handling\r\n     * @param {Error} error - Original error\r\n     * @param {string} moduleName - Module name\r\n     * @returns {string} Error code\r\n     */\r\n    categorizeError(error, moduleName) {\r\n        if (error.message.includes('fetch') || error.message.includes('network')) {\r\n            return 'NETWORK_ERROR';\r\n        }\r\n\r\n        if (error.message.includes('JSON') || error.message.includes('parse')) {\r\n            return 'DATA_FORMAT_ERROR';\r\n        }\r\n\r\n        if (error.message.includes('context') || error.message.includes('SillyTavern')) {\r\n            return 'CONTEXT_ERROR';\r\n        }\r\n\r\n        if (error.name === 'TypeError') {\r\n            return 'TYPE_ERROR';\r\n        }\r\n\r\n        if (moduleName === 'LLM' && (error.message.includes('quota') || error.message.includes('rate'))) {\r\n            return 'API_LIMIT_ERROR';\r\n        }\r\n\r\n        return 'UNKNOWN_ERROR';\r\n    }\r\n\r\n    /**\r\n     * Determine if an error is recoverable\r\n     * @param {Error} error - Original error\r\n     * @param {string} code - Error code\r\n     * @returns {boolean} Whether error is recoverable\r\n     */\r\n    isRecoverable(error, code) {\r\n        const nonRecoverableErrors = [\r\n            'CONTEXT_ERROR',\r\n            'TYPE_ERROR',\r\n        ];\r\n\r\n        return !nonRecoverableErrors.includes(code);\r\n    }\r\n\r\n    /**\r\n     * Start a transaction for rollback capability\r\n     * @param {string} transactionId - Unique transaction identifier\r\n     * @param {Object} initialState - State to potentially rollback to\r\n     */\r\n    startTransaction(transactionId, initialState) {\r\n        this.transactionStack.push({\r\n            id: transactionId,\r\n            state: JSON.stringify(initialState),\r\n            timestamp: Date.now(),\r\n        });\r\n\r\n        logger.debug(`Started transaction: ${transactionId}`);\r\n    }\r\n\r\n    /**\r\n     * Commit a transaction (remove from rollback stack)\r\n     * @param {string} transactionId - Transaction identifier\r\n     */\r\n    commitTransaction(transactionId) {\r\n        const index = this.transactionStack.findIndex(t => t.id === transactionId);\r\n        if (index !== -1) {\r\n            this.transactionStack.splice(index, 1);\r\n            logger.debug(`Committed transaction: ${transactionId}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rollback a transaction\r\n     * @param {string} transactionId - Transaction identifier\r\n     * @returns {Object|null} Previous state or null if not found\r\n     */\r\n    rollbackTransaction(transactionId) {\r\n        const index = this.transactionStack.findIndex(t => t.id === transactionId);\r\n        if (index !== -1) {\r\n            const transaction = this.transactionStack.splice(index, 1)[0];\r\n            logger.debug(`Rolled back transaction: ${transactionId}`);\r\n            return JSON.parse(transaction.state);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Register a recovery strategy for specific error codes\r\n     * @param {string} errorCode - Error code to handle\r\n     * @param {Function} strategy - Recovery function\r\n     */\r\n    registerRecoveryStrategy(errorCode, strategy) {\r\n        this.recoveryStrategies.set(errorCode, strategy);\r\n        logger.debug(`Registered recovery strategy for: ${errorCode}`);\r\n    }\r\n\r\n    /**\r\n     * Register callback for critical errors\r\n     * @param {Function} callback - Function to call on critical errors\r\n     */\r\n    onCriticalError(callback) {\r\n        this.criticalErrorCallbacks.push(callback);\r\n    }\r\n\r\n    /**\r\n     * Notify user of errors via toastr\r\n     * @param {NameTrackerError} error - Error to display\r\n     */\r\n    notifyUser(error) {\r\n        const message = `Name Tracker: ${error.message}`;\r\n\r\n        if (error.recoverable) {\r\n            toastr.warning(message, 'Warning', { timeOut: 5000 });\r\n        } else {\r\n            toastr.error(message, 'Error', { timeOut: 8000 });\r\n\r\n            // Notify critical error callbacks\r\n            this.criticalErrorCallbacks.forEach(callback => {\r\n                try {\r\n                    callback(error);\r\n                } catch (callbackError) {\r\n                    logger.error('Critical error callback failed:', callbackError);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get recent error history\r\n     * @param {number} count - Number of recent errors to return\r\n     * @returns {Array} Recent errors\r\n     */\r\n    getRecentErrors(count = 10) {\r\n        return this.errorHistory.slice(-count);\r\n    }\r\n\r\n    /**\r\n     * Clear error history\r\n     */\r\n    clearHistory() {\r\n        this.errorHistory = [];\r\n        logger.debug('Cleared error history');\r\n    }\r\n\r\n    /**\r\n     * Utility delay function for retries\r\n     * @param {number} ms - Milliseconds to delay\r\n     * @returns {Promise} Delay promise\r\n     */\r\n    delay(ms) {\r\n        return new Promise(resolve => setTimeout(resolve, ms));\r\n    }\r\n}\r\n\r\n// Create singleton instance\r\nconst errorHandler = new ErrorHandler();\r\n\r\nexport { errorHandler, NameTrackerError };\r\nexport const withErrorBoundary = errorHandler.withErrorBoundary.bind(errorHandler);\r\nexport default errorHandler;\r\n","\"use strict\";\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;","/**\r\n * Simplified settings management for Name Tracker extension\r\n * Uses SillyTavern standard patterns with preserved error handling\r\n */\r\n\r\nimport { errorHandler } from './errors.js';\r\nimport { createModuleLogger } from './debug.js';\r\nimport { stContext } from './context.js';\r\n\r\nconst MODULE_NAME = 'STnametracker';\r\nconst debug = createModuleLogger('Settings');\r\n\r\n// Default settings structure\r\nconst DEFAULT_SETTINGS = Object.freeze({\r\n    enabled: true,\r\n    autoAnalyze: true,\r\n    messageFrequency: 10,\r\n    llmSource: 'sillytavern', // 'sillytavern' or 'ollama'\r\n    ollamaEndpoint: 'http://localhost:11434',\r\n    ollamaModel: '',\r\n    confidenceThreshold: 70,\r\n    lorebookPosition: 0, // after character defs\r\n    lorebookDepth: 1,\r\n    lorebookCooldown: 5,\r\n    lorebookScanDepth: 1,\r\n    lorebookProbability: 100,\r\n    lorebookEnabled: true,\r\n    debugMode: false,\r\n    systemPrompt: null, // null means use default\r\n    lastScannedMessageId: -1,\r\n    totalCharactersDetected: 0,\r\n    lastAnalysisTime: null,\r\n    analysisCache: new Map(),\r\n});\r\n\r\n// Default chat-level data structure\r\nconst DEFAULT_CHAT_DATA = Object.freeze({\r\n    characters: {},\r\n    lastScannedMessageId: -1,\r\n    analysisHistory: [],\r\n    lorebookEntries: {},\r\n    processingStats: {\r\n        totalProcessed: 0,\r\n        charactersFound: 0,\r\n        lastProcessedTime: null,\r\n    },\r\n});\r\n\r\n/**\r\n * Get current settings with defaults\r\n * @returns {Object} Current settings\r\n */\r\nfunction get_settings() {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        // Ensure extension_settings exists\r\n        if (typeof extension_settings === 'undefined') {\r\n            console.warn('[STnametracker] extension_settings not available');\r\n            return { ...DEFAULT_SETTINGS };\r\n        }\r\n\r\n        // Initialize if not exists\r\n        if (!extension_settings[MODULE_NAME]) {\r\n            extension_settings[MODULE_NAME] = { ...DEFAULT_SETTINGS };\r\n        }\r\n\r\n        // Merge with defaults to ensure all properties exist\r\n        const settings = { ...DEFAULT_SETTINGS, ...extension_settings[MODULE_NAME] };\r\n        return settings;\r\n    }, { ...DEFAULT_SETTINGS });\r\n}\r\n\r\n/**\r\n * Update settings and save\r\n * @param {Object} newSettings - Settings to update\r\n */\r\nfunction set_settings(newSettings) {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        // Ensure extension_settings exists\r\n        if (typeof extension_settings === 'undefined') {\r\n            console.warn('[STnametracker] extension_settings not available for saving');\r\n            return;\r\n        }\r\n\r\n        // Initialize if not exists\r\n        if (!extension_settings[MODULE_NAME]) {\r\n            extension_settings[MODULE_NAME] = { ...DEFAULT_SETTINGS };\r\n        }\r\n\r\n        // Update settings\r\n        Object.assign(extension_settings[MODULE_NAME], newSettings);\r\n\r\n        // Save to SillyTavern\r\n        if (typeof saveSettingsDebounced !== 'undefined') {\r\n            saveSettingsDebounced();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Get current chat characters\r\n * @returns {Object} Chat characters data\r\n */\r\nfunction getCharacters() {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        try {\r\n            const metadata = stContext.getChatMetadata();\r\n\r\n            // Initialize if not exists\r\n            if (!metadata[MODULE_NAME]) {\r\n                metadata[MODULE_NAME] = { ...DEFAULT_CHAT_DATA };\r\n            }\r\n\r\n            return metadata[MODULE_NAME].characters || {};\r\n        } catch (error) {\r\n            debug.warn('Failed to get characters:', error.message);\r\n            return {};\r\n        }\r\n    }, {});\r\n}\r\n\r\n/**\r\n * Update chat characters and save\r\n * @param {Object} characters - Characters data to save\r\n */\r\nfunction setCharacters(characters) {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        try {\r\n            const metadata = stContext.getChatMetadata();\r\n\r\n            // Initialize if not exists\r\n            if (!metadata[MODULE_NAME]) {\r\n                metadata[MODULE_NAME] = { ...DEFAULT_CHAT_DATA };\r\n            }\r\n\r\n            // Update characters\r\n            metadata[MODULE_NAME].characters = characters;\r\n\r\n            // Save to SillyTavern\r\n            stContext.saveChatMetadata().catch(err => {\r\n                debug.warn('Failed to save chat metadata:', err.message);\r\n            });\r\n        } catch (error) {\r\n            debug.warn('Failed to set characters:', error.message);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Get chat-level data\r\n * @returns {Object} Chat metadata\r\n */\r\nfunction getChatData() {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        try {\r\n            const metadata = stContext.getChatMetadata();\r\n\r\n            // Initialize if not exists\r\n            if (!metadata[MODULE_NAME]) {\r\n                metadata[MODULE_NAME] = { ...DEFAULT_CHAT_DATA };\r\n            }\r\n\r\n            return metadata[MODULE_NAME];\r\n        } catch (error) {\r\n            debug.warn('Failed to get chat data:', error.message);\r\n            return { ...DEFAULT_CHAT_DATA };\r\n        }\r\n    }, { ...DEFAULT_CHAT_DATA });\r\n}\r\n\r\n/**\r\n * Update chat-level data\r\n * @param {Object} data - Data to update\r\n */\r\nfunction setChatData(data) {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        try {\r\n            const metadata = stContext.getChatMetadata();\r\n\r\n            // Initialize if not exists\r\n            if (!metadata[MODULE_NAME]) {\r\n                metadata[MODULE_NAME] = { ...DEFAULT_CHAT_DATA };\r\n            }\r\n\r\n            // Update data\r\n            Object.assign(metadata[MODULE_NAME], data);\r\n\r\n            // Save to SillyTavern\r\n            stContext.saveChatMetadata().catch(err => {\r\n                debug.warn('Failed to save chat metadata:', err.message);\r\n            });\r\n        } catch (error) {\r\n            debug.warn('Failed to set chat data:', error.message);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Add a character to the current chat\r\n * @param {string} name - Character name\r\n * @param {Object} characterData - Character data\r\n */\r\nfunction addCharacter(name, characterData) {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        const characters = getCharacters();\r\n        characters[name] = characterData;\r\n        setCharacters(characters);\r\n    });\r\n}\r\n\r\n/**\r\n * Remove a character from the current chat\r\n * @param {string} name - Character name to remove\r\n */\r\nfunction removeCharacter(name) {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        const characters = getCharacters();\r\n        delete characters[name];\r\n        setCharacters(characters);\r\n    });\r\n}\r\n\r\n/**\r\n * Get a specific setting value\r\n * @param {string} key - Setting key\r\n * @param {*} defaultValue - Default value if not found\r\n * @returns {*} Setting value\r\n */\r\nfunction getSetting(key, defaultValue) {\r\n    const settings = get_settings();\r\n    return settings[key] !== undefined ? settings[key] : defaultValue;\r\n}\r\n\r\n/**\r\n * Set a specific setting value\r\n * @param {string} key - Setting key\r\n * @param {*} value - Setting value\r\n */\r\nfunction setSetting(key, value) {\r\n    const update = {};\r\n    update[key] = value;\r\n    set_settings(update);\r\n}\r\n\r\n/**\r\n * Get a single character by name\r\n * @param {string} name - Character name\r\n * @returns {Object|null} Character data or null if not found\r\n */\r\nfunction getCharacter(name) {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        if (!name || typeof name !== 'string') {\r\n            console.warn('[STnametracker] Invalid character name:', name);\r\n            return null;\r\n        }\r\n        const chars = getCharacters();\r\n        return chars[name] || null;\r\n    }, null);\r\n}\r\n\r\n/**\r\n * Set a character by name\r\n * @param {string} name - Character name\r\n * @param {Object} character - Character data\r\n */\r\nfunction setCharacter(name, character) {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        if (!name || typeof name !== 'string') {\r\n            throw new Error('Character name must be a non-empty string');\r\n        }\r\n        if (!character || typeof character !== 'object') {\r\n            throw new Error('Character data must be an object');\r\n        }\r\n        const chars = { ...getCharacters() };\r\n        chars[name] = character;\r\n        setCharacters(chars);\r\n        debug.log(`Set character: ${name}`);\r\n    });\r\n}\r\n\r\n/**\r\n * Get LLM configuration\r\n * @returns {Object} LLM configuration object\r\n */\r\nfunction getLLMConfig() {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        const llmSource = getSetting('llmSource');\r\n        console.log('[NT-LLMConfig] llmSource setting:', llmSource);\r\n        console.log('[NT-LLMConfig] All extension_settings keys:', Object.keys(extension_settings.sillytavern_nametracker || {}));\r\n        return {\r\n            source: llmSource,\r\n            ollamaEndpoint: getSetting('ollamaEndpoint'),\r\n            ollamaModel: getSetting('ollamaModel'),\r\n            systemPrompt: getSetting('systemPrompt'),\r\n        };\r\n    }, { source: 'sillytavern', ollamaEndpoint: 'http://localhost:11434', ollamaModel: '', systemPrompt: null });\r\n}\r\n\r\n/**\r\n * Get lorebook configuration\r\n * @returns {Object} Lorebook configuration object\r\n */\r\nfunction getLorebookConfig() {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        return {\r\n            position: getSetting('lorebookPosition'),\r\n            depth: getSetting('lorebookDepth'),\r\n            cooldown: getSetting('lorebookCooldown'),\r\n            scanDepth: getSetting('lorebookScanDepth'),\r\n            probability: getSetting('lorebookProbability'),\r\n            enabled: getSetting('lorebookEnabled'),\r\n        };\r\n    }, { position: 0, depth: 1, cooldown: 5, scanDepth: 1, probability: 100, enabled: true });\r\n}\r\n\r\n/**\r\n * Alias for get_settings for compatibility\r\n * @returns {Object} Current settings\r\n */\r\nfunction getSettings() {\r\n    return get_settings();\r\n}\r\n\r\n/**\r\n * Get chat metadata value\r\n * @param {string} key - Metadata key\r\n * @returns {any} Metadata value\r\n */\r\nfunction get_chat_metadata(key) {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        try {\r\n            const metadata = stContext.getChatMetadata();\r\n\r\n            if (!metadata[MODULE_NAME]) {\r\n                metadata[MODULE_NAME] = { ...DEFAULT_CHAT_DATA };\r\n            }\r\n\r\n            return metadata[MODULE_NAME][key];\r\n        } catch (error) {\r\n            debug.warn('Failed to get chat metadata:', error.message);\r\n            return DEFAULT_CHAT_DATA[key];\r\n        }\r\n    }, DEFAULT_CHAT_DATA[key]);\r\n}\r\n\r\n/**\r\n * Set chat metadata value\r\n * @param {string} key - Metadata key\r\n * @param {any} value - New value\r\n */\r\nfunction set_chat_metadata(key, value) {\r\n    return errorHandler.withErrorBoundary('Settings', () => {\r\n        try {\r\n            const metadata = stContext.getChatMetadata();\r\n\r\n            if (!metadata[MODULE_NAME]) {\r\n                metadata[MODULE_NAME] = { ...DEFAULT_CHAT_DATA };\r\n            }\r\n\r\n            metadata[MODULE_NAME][key] = value;\r\n            debug.log(`Updated chat data ${key}`);\r\n\r\n            stContext.saveChatMetadata().catch(err => {\r\n                debug.warn('Failed to save chat metadata:', err.message);\r\n            });\r\n        } catch (error) {\r\n            debug.warn('Failed to set chat metadata:', error.message);\r\n        }\r\n    });\r\n}\r\n\r\nexport {\r\n    MODULE_NAME,\r\n    DEFAULT_SETTINGS,\r\n    DEFAULT_CHAT_DATA,\r\n    get_settings,\r\n    set_settings,\r\n    getCharacters,\r\n    setCharacters,\r\n    getChatData,\r\n    setChatData,\r\n    addCharacter,\r\n    removeCharacter,\r\n    getSetting,\r\n    setSetting,\r\n    getCharacter,\r\n    setCharacter,\r\n    getLLMConfig,\r\n    getLorebookConfig,\r\n    getSettings,\r\n    get_chat_metadata,\r\n    set_chat_metadata,\r\n};\r\n","/**\r\n * Character Management Module\r\n *\r\n * Handles character CRUD operations, merging, alias detection, relationship management,\r\n * and per-character processing state tracking for the Name Tracker extension.\r\n */\r\n\r\nimport { updateLorebookEntry } from './lorebook.js';\r\nimport { createModuleLogger } from '../core/debug.js';\r\nimport { withErrorBoundary, NameTrackerError } from '../core/errors.js';\r\nimport {\r\n    getCharacters, getCharacter, setCharacter, removeCharacter,\r\n    get_settings, set_chat_metadata,\r\n} from '../core/settings.js';\r\nimport { NotificationManager } from '../utils/notifications.js';\r\n\r\nconst debug = createModuleLogger('characters');\r\nconst notifications = new NotificationManager('Character Management');\r\n\r\n// ============================================================================\r\n// DEBUG CONFIGURATION\r\n// ============================================================================\r\nconst DEBUG_LOGGING = true; // Set to false in production after testing\r\n\r\nfunction debugLog(message, data = null) {\r\n    if (DEBUG_LOGGING) {\r\n        console.log(`[NT-Characters] ${message}`, data || '');\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// CONFIGURATION CONSTANTS - Merge confidence thresholds and detection parameters\r\n// ============================================================================\r\n\r\n// Merge Confidence Tiers (as percentages: 0-100)\r\nconst MERGE_CONFIDENCE_HIGH = 0.9;      // 90%+ - Automatic merge (e.g., exact substring: \"Jazz\"/\"Jasmine\")\r\nconst MERGE_CONFIDENCE_MEDIUM = 0.7;    // 70%+ - User prompt required (e.g., phonetic similarity)\r\n// eslint-disable-next-line no-unused-vars\r\nconst MERGE_CONFIDENCE_LOW = 0.5;       // 50%+ - No automatic action (may indicate false positives)\r\n\r\n// Substring Matching Thresholds\r\nconst MIN_SUBSTRING_LENGTH = 3;         // Minimum length for substring detection\r\nconst SUBSTRING_MATCH_BONUS = 0.95;     // High confidence for substring matches\r\n\r\n// Character management state\r\nlet undoHistory = []; // Store last 3 merge operations\r\n\r\n/**\r\n * Character data structure\r\n * @typedef {Object} CharacterData\r\n * @property {string} preferredName - The preferred/canonical name\r\n * @property {string[]} aliases - List of alternative names\r\n * @property {string} physicalAge - Physical age description\r\n * @property {string} mentalAge - Mental age description\r\n * @property {string} physical - Physical description\r\n * @property {string} personality - Personality traits\r\n * @property {string} sexuality - Sexual orientation/preferences\r\n * @property {string} raceEthnicity - Race/ethnicity information\r\n * @property {string} roleSkills - Role and skills description\r\n * @property {string} lastInteraction - Last interaction with user\r\n * @property {string[]} relationships - Relationships with other characters\r\n * @property {boolean} ignored - Whether character is ignored\r\n * @property {number} confidence - Confidence score (0-100)\r\n * @property {string|null} lorebookEntryId - Associated lorebook entry ID\r\n * @property {number} lastUpdated - Timestamp of last update\r\n * @property {boolean} isMainChar - Whether this is the main character\r\n * @property {number} lastMessageProcessed - ID of last message processed for this character\r\n */\r\n\r\n/**\r\n * Check if a character is in the ignored list\r\n * @param {string} name - Character name to check\r\n * @returns {boolean} True if character is ignored\r\n */\r\nexport function isIgnoredCharacter(name) {\r\n    return withErrorBoundary('isIgnoredCharacter', () => {\r\n        const chars = getCharacters();\r\n        return Object.values(chars).some(\r\n            char => char.ignored && (char.preferredName === name || char.aliases.includes(name)),\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Find existing character by name or alias\r\n * @param {string} name - Name to search for\r\n * @returns {CharacterData|null} Character data if found, null otherwise\r\n */\r\nexport function findExistingCharacter(name) {\r\n    return withErrorBoundary('findExistingCharacter', () => {\r\n        const chars = getCharacters();\r\n        const found = Object.values(chars).find(\r\n            char => char.preferredName === name || char.aliases.includes(name),\r\n        ) || null;\r\n        debugLog(`[FindChar] Searching for '${name}': ${found ? 'FOUND as ' + found.preferredName : 'NOT FOUND'}`);\r\n        return found;\r\n    });\r\n}\r\n\r\n/**\r\n * Find potential match for a new character based on confidence threshold\r\n * @param {Object} analyzedChar - Character data from LLM analysis\r\n * @returns {Promise<CharacterData|null>} Potential match if found\r\n */\r\nexport async function findPotentialMatch(analyzedChar) {\r\n    return withErrorBoundary('findPotentialMatch', async () => {\r\n        const chars = getCharacters();\r\n        const threshold = get_settings('confidenceThreshold', 70);\r\n\r\n        debug.log();\r\n\r\n        // Simple matching logic - can be enhanced with LLM-based similarity\r\n        for (const existingChar of Object.values(chars)) {\r\n            // Check for name similarity (simple approach)\r\n            const similarity = calculateNameSimilarity(analyzedChar.name, existingChar.preferredName);\r\n\r\n            if (similarity >= threshold) {\r\n                debug.log();\r\n                return existingChar;\r\n            }\r\n\r\n            // Check aliases\r\n            for (const alias of existingChar.aliases) {\r\n                const aliasSimilarity = calculateNameSimilarity(analyzedChar.name, alias);\r\n                if (aliasSimilarity >= threshold) {\r\n                    debug.log();\r\n                    return existingChar;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    });\r\n}\r\n\r\n/**\r\n * Calculate simple name similarity (0-100)\r\n * @param {string} name1 - First name to compare\r\n * @param {string} name2 - Second name to compare\r\n * @returns {number} Similarity score 0-100\r\n */\r\nexport function calculateNameSimilarity(name1, name2) {\r\n    return withErrorBoundary('calculateNameSimilarity', () => {\r\n        name1 = name1.toLowerCase();\r\n        name2 = name2.toLowerCase();\r\n\r\n        // Exact match\r\n        if (name1 === name2) {\r\n            return 100;\r\n        }\r\n\r\n        // One contains the other\r\n        if (name1.includes(name2) || name2.includes(name1)) {\r\n            return 85;\r\n        }\r\n\r\n        // Check if they share significant parts\r\n        const words1 = name1.split(/\\s+/);\r\n        const words2 = name2.split(/\\s+/);\r\n\r\n        const commonWords = words1.filter(w => words2.includes(w));\r\n        if (commonWords.length > 0) {\r\n            return 70;\r\n        }\r\n\r\n        // No significant similarity\r\n        return 0;\r\n    });\r\n}\r\n\r\n/**\r\n * Filter and clean aliases\r\n * Removes character's own name, relationship words, and other invalid aliases\r\n * @param {string[]} aliases - Array of alias strings\r\n * @param {string} characterName - The character's actual name\r\n * @returns {string[]} Cleaned array of unique aliases\r\n */\r\nexport function cleanAliases(aliases, characterName) {\r\n    return withErrorBoundary('cleanAliases', () => {\r\n        if (!aliases || !Array.isArray(aliases)) {\r\n            return [];\r\n        }\r\n\r\n        // Common relationship/role words that shouldn't be aliases\r\n        const invalidAliases = [\r\n            'son', 'daughter', 'mother', 'father', 'mom', 'dad', 'parent',\r\n            'brother', 'sister', 'sibling', 'cousin', 'uncle', 'aunt',\r\n            'friend', 'boyfriend', 'girlfriend', 'husband', 'wife', 'spouse',\r\n            'boss', 'employee', 'coworker', 'colleague', 'partner',\r\n            'neighbor', 'roommate', 'child', 'kid', 'baby',\r\n            'man', 'woman', 'person', 'guy', 'girl', 'boy',\r\n            'user', '{{user}}', 'char', '{{char}}',\r\n        ];\r\n\r\n        const lowerName = characterName.toLowerCase();\r\n\r\n        return aliases.filter(alias => {\r\n            if (!alias || typeof alias !== 'string') return false;\r\n\r\n            const lowerAlias = alias.trim().toLowerCase();\r\n\r\n            // Remove if it's the character's own name\r\n            if (lowerAlias === lowerName) return false;\r\n\r\n            // Remove if it's just a relationship word\r\n            if (invalidAliases.includes(lowerAlias)) return false;\r\n\r\n            // Remove if it's too short (likely not a real alias)\r\n            if (lowerAlias.length < 2) return false;\r\n\r\n            return true;\r\n        })\r\n            .map(alias => alias.trim()) // Trim whitespace\r\n            .filter((alias, index, self) => self.indexOf(alias) === index); // Remove duplicates\r\n    });\r\n}\r\n\r\n// ============================================================================\r\n// MERGE DETECTION AND CONFIDENCE SCORING\r\n// ============================================================================\r\n\r\n/**\r\n * Detect potential merge opportunities for a new character\r\n * Finds existing characters that might be the same person with different names\r\n * @param {string} newCharacterName - Name of the newly discovered character\r\n * @returns {Array} Array of potential merge targets with confidence scores\r\n */\r\nexport function detectMergeOpportunities(newCharacterName) {\r\n    return withErrorBoundary('detectMergeOpportunities', () => {\r\n        debugLog(`[MergeDetect] Checking merge opportunities for: ${newCharacterName}`);\r\n\r\n        const potentialMatches = [];\r\n        const existingCharacters = getCharacters();\r\n\r\n        if (!newCharacterName || typeof newCharacterName !== 'string') {\r\n            debugLog('[MergeDetect] Invalid name provided');\r\n            return potentialMatches;\r\n        }\r\n\r\n        // eslint-disable-next-line no-unused-vars\r\n        for (const [_existingName, existingChar] of Object.entries(existingCharacters)) {\r\n            const confidence = calculateMergeConfidence(newCharacterName, existingChar);\r\n\r\n            if (confidence >= MERGE_CONFIDENCE_MEDIUM) {\r\n                const tier = confidence >= MERGE_CONFIDENCE_HIGH ? 'HIGH' : 'MEDIUM';\r\n                const reason = generateMergeReason(newCharacterName, existingChar, confidence);\r\n                potentialMatches.push({\r\n                    targetName: existingChar.preferredName,\r\n                    confidence: confidence,\r\n                    tier: tier,\r\n                    reason: reason,\r\n                });\r\n                debugLog(`[MergeDetect] ${newCharacterName} -> ${existingChar.preferredName}: ${tier} (${Math.round(confidence * 100)}%) - ${reason}`);\r\n            }\r\n        }\r\n\r\n        // Sort by confidence descending\r\n        potentialMatches.sort((a, b) => b.confidence - a.confidence);\r\n\r\n        debugLog(`[MergeDetect] Total merge candidates for ${newCharacterName}: ${potentialMatches.length}`);\r\n\r\n        return potentialMatches;\r\n    }, []);\r\n}\r\n\r\n/**\r\n * Calculate merge confidence between two character names\r\n * Returns value 0-1 (0-100%)\r\n * @private\r\n */\r\nfunction calculateMergeConfidence(newName, existingChar) {\r\n    debugLog(`[CalcConfidence] Comparing '${newName}' vs '${existingChar.preferredName}'`);\r\n\r\n    const existingName = existingChar.preferredName;\r\n    let confidence = 0;\r\n\r\n    // Check for exact substring match (e.g., \"Jazz\" in \"Jasmine\")\r\n    if (isSubstringMatch(newName, existingName)) {\r\n        confidence = SUBSTRING_MATCH_BONUS;\r\n        debugLog('[CalcConfidence] Substring match detected');\r\n    }\r\n    // Check if new name matches any existing alias\r\n    else if (existingChar.aliases && existingChar.aliases.some(alias =>\r\n        newName.toLowerCase() === alias.toLowerCase())) {\r\n        confidence = 0.95;\r\n    }\r\n    // Check for phonetic similarity\r\n    else if (isPhoneticSimilar(newName, existingName)) {\r\n        confidence = 0.8;\r\n    }\r\n    // Check for partial similarity\r\n    else if (isPartialMatch(newName, existingName)) {\r\n        confidence = 0.65;\r\n    }\r\n\r\n    return confidence;\r\n}\r\n\r\n/**\r\n * Check if newName is a substring of existingName (or vice versa)\r\n * Used for detecting nickname relationships like \"Jazz\" for \"Jasmine\"\r\n * @private\r\n */\r\nfunction isSubstringMatch(newName, existingName) {\r\n    const newLower = newName.toLowerCase();\r\n    const existLower = existingName.toLowerCase();\r\n\r\n    // Check if one is a substring of the other, and long enough to be meaningful\r\n    if (newName.length >= MIN_SUBSTRING_LENGTH) {\r\n        return existLower.includes(newLower) || newLower.includes(existLower);\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Basic phonetic similarity check using Levenshtein distance\r\n * @private\r\n */\r\nfunction isPhoneticSimilar(str1, str2) {\r\n    const distance = levenshteinDistance(str1.toLowerCase(), str2.toLowerCase());\r\n    const maxLength = Math.max(str1.length, str2.length);\r\n    const similarity = 1 - (distance / maxLength);\r\n\r\n    // Consider similar if >75% match\r\n    return similarity >= 0.75;\r\n}\r\n\r\n/**\r\n * Check for partial name match (e.g., first/last name components)\r\n * @private\r\n */\r\nfunction isPartialMatch(newName, existingName) {\r\n    const newParts = newName.toLowerCase().split(/\\s+/);\r\n    const existParts = existingName.toLowerCase().split(/\\s+/);\r\n\r\n    // Check if any part of new name matches parts of existing\r\n    return newParts.some(newPart => existParts.some(existPart =>\r\n        newPart === existPart && newPart.length > 2,\r\n    ));\r\n}\r\n\r\n/**\r\n * Calculate Levenshtein distance between two strings\r\n * @private\r\n */\r\nfunction levenshteinDistance(str1, str2) {\r\n    const track = Array(str2.length + 1).fill(null).map(() =>\r\n        Array(str1.length + 1).fill(null),\r\n    );\r\n\r\n    for (let i = 0; i <= str1.length; i++) {\r\n        track[0][i] = i;\r\n    }\r\n\r\n    for (let j = 0; j <= str2.length; j++) {\r\n        track[j][0] = j;\r\n    }\r\n\r\n    for (let j = 1; j <= str2.length; j++) {\r\n        for (let i = 1; i <= str1.length; i++) {\r\n            const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;\r\n            track[j][i] = Math.min(\r\n                track[j][i - 1] + 1,\r\n                track[j - 1][i] + 1,\r\n                track[j - 1][i - 1] + indicator,\r\n            );\r\n        }\r\n    }\r\n\r\n    return track[str2.length][str1.length];\r\n}\r\n\r\n/**\r\n * Generate human-readable reason for merge suggestion\r\n * @private\r\n */\r\nfunction generateMergeReason(newName, existingChar, confidence) {\r\n    if (confidence >= MERGE_CONFIDENCE_HIGH) {\r\n        if (newName.toLowerCase().includes(existingChar.preferredName.toLowerCase())) {\r\n            return `\"${newName}\" contains \"${existingChar.preferredName}\" (likely nickname)`;\r\n        }\r\n        return `Exact match confidence: ${(confidence * 100).toFixed(0)}%`;\r\n    }\r\n\r\n    return `Phonetic/partial match with confidence: ${(confidence * 100).toFixed(0)}%`;\r\n}\r\n\r\n/**\r\n * Create a new character entry\r\nantml:parameter>\r\n\r\n * @param {Object} analyzedChar - Character data from LLM analysis\r\n * @param {boolean} isMainChar - Whether this is the main character\r\n * @returns {Promise<CharacterData>} Created character data\r\n */\r\nexport async function createCharacter(analyzedChar, isMainChar = false) {\r\n    return withErrorBoundary('createCharacter', async () => {\r\n        debug.log();\r\n\r\n        // Clean and filter aliases\r\n        const aliases = cleanAliases(analyzedChar.aliases || [], analyzedChar.name);\r\n\r\n        const character = {\r\n            preferredName: analyzedChar.name,\r\n            aliases: aliases,\r\n            physicalAge: analyzedChar.physicalAge || '',\r\n            mentalAge: analyzedChar.mentalAge || '',\r\n            physical: analyzedChar.physical || '',\r\n            personality: analyzedChar.personality || '',\r\n            sexuality: analyzedChar.sexuality || '',\r\n            raceEthnicity: analyzedChar.raceEthnicity || '',\r\n            roleSkills: analyzedChar.roleSkills || '',\r\n            lastInteraction: analyzedChar.lastInteraction || '',\r\n            relationships: analyzedChar.relationships || [],\r\n            ignored: false,\r\n            confidence: analyzedChar.confidence || 50,\r\n            lorebookEntryId: null,\r\n            lastUpdated: Date.now(),\r\n            isMainChar: isMainChar || false,\r\n            lastMessageProcessed: -1,  // Track processing state per character\r\n        };\r\n\r\n        debug.log();\r\n\r\n        // Store character in settings\r\n        setCharacter(character.preferredName, character);\r\n\r\n        // Create lorebook entry\r\n        await updateLorebookEntry(character, character.preferredName);\r\n\r\n        debug.log();\r\n\r\n        return character;\r\n    });\r\n}\r\n\r\n/**\r\n * Update character's lastMessageProcessed tracking field\r\n * Called after successful processing of a character to track progress\r\n * @param {string} characterName - Name of the character\r\n * @param {number} messageId - ID of the last processed message for this character\r\n * @returns {boolean} True if successfully updated\r\n */\r\nexport function updateCharacterProcessingState(characterName, messageId) {\r\n    return withErrorBoundary('updateCharacterProcessingState', () => {\r\n        const character = findExistingCharacter(characterName);\r\n\r\n        if (!character) {\r\n            debug.log(`Character not found for state update: ${characterName}`);\r\n            return false;\r\n        }\r\n\r\n        character.lastMessageProcessed = messageId;\r\n        character.lastUpdated = Date.now();\r\n\r\n        setCharacter(character.preferredName, character);\r\n\r\n        debug.log(`Updated processing state for ${characterName}: messageId=${messageId}`);\r\n        return true;\r\n    }, false);\r\n}\r\n\r\n/**\r\n * Update existing character with new information\r\n * @param {CharacterData} existingChar - Existing character data\r\n * @param {Object} analyzedChar - New character data from LLM analysis\r\n * @param {boolean} addAsAlias - Whether to add the analyzed name as an alias\r\n * @param {boolean} isMainChar - Whether this is the main character\r\n * @returns {Promise<CharacterData>} Updated character data\r\n */\r\nexport async function updateCharacter(existingChar, analyzedChar, addAsAlias = false, isMainChar = false) {\r\n    return withErrorBoundary('updateCharacter', async () => {\r\n        debug.log();\r\n\r\n        // Mark as main character if detected\r\n        if (isMainChar) {\r\n            existingChar.isMainChar = true;\r\n        }\r\n\r\n        // If adding as alias, add the analyzed name to aliases if not already present\r\n        if (addAsAlias && analyzedChar.name !== existingChar.preferredName) {\r\n            if (!existingChar.aliases) existingChar.aliases = [];\r\n            if (!existingChar.aliases.includes(analyzedChar.name) &&\r\n                analyzedChar.name.toLowerCase() !== existingChar.preferredName.toLowerCase()) {\r\n                existingChar.aliases.push(analyzedChar.name);\r\n            }\r\n        }\r\n\r\n        // Clean up all aliases using the helper function\r\n        existingChar.aliases = cleanAliases(existingChar.aliases || [], existingChar.preferredName);\r\n\r\n        // Update consolidated fields (new data takes precedence if not empty)\r\n        if (analyzedChar.physicalAge) existingChar.physicalAge = analyzedChar.physicalAge;\r\n        if (analyzedChar.mentalAge) existingChar.mentalAge = analyzedChar.mentalAge;\r\n        if (analyzedChar.physical) existingChar.physical = analyzedChar.physical;\r\n        if (analyzedChar.personality) existingChar.personality = analyzedChar.personality;\r\n        if (analyzedChar.sexuality) existingChar.sexuality = analyzedChar.sexuality;\r\n        if (analyzedChar.raceEthnicity) existingChar.raceEthnicity = analyzedChar.raceEthnicity;\r\n        if (analyzedChar.roleSkills) existingChar.roleSkills = analyzedChar.roleSkills;\r\n\r\n        // lastInteraction is always updated (most recent)\r\n        if (analyzedChar.lastInteraction) existingChar.lastInteraction = analyzedChar.lastInteraction;\r\n\r\n        // Merge relationships array - deduplicate\r\n        if (analyzedChar.relationships && Array.isArray(analyzedChar.relationships)) {\r\n            if (!existingChar.relationships) existingChar.relationships = [];\r\n            for (const rel of analyzedChar.relationships) {\r\n                if (!existingChar.relationships.includes(rel)) {\r\n                    existingChar.relationships.push(rel);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update confidence (average of old and new)\r\n        if (analyzedChar.confidence) {\r\n            existingChar.confidence = Math.round((existingChar.confidence + analyzedChar.confidence) / 2);\r\n        }\r\n\r\n        existingChar.lastUpdated = Date.now();\r\n\r\n        // Update character in settings\r\n        setCharacter(existingChar.preferredName, existingChar);\r\n\r\n        debug.log();\r\n\r\n        return existingChar;\r\n    });\r\n}\r\n\r\n/**\r\n * Merge two characters\r\n * @param {string} sourceName - Name of character to merge from\r\n * @param {string} targetName - Name of character to merge into\r\n * @returns {Promise<void>}\r\n */\r\nexport async function mergeCharacters(sourceName, targetName) {\r\n    return withErrorBoundary('mergeCharacters', async () => {\r\n        const chars = getCharacters();\r\n\r\n        const sourceChar = chars[sourceName];\r\n        const targetChar = chars[targetName];\r\n\r\n        if (!sourceChar || !targetChar) {\r\n            throw new NameTrackerError('One or both characters not found');\r\n        }\r\n\r\n        // Store for undo\r\n        const undoData = {\r\n            operation: 'merge',\r\n            timestamp: Date.now(),\r\n            sourceName: sourceName,\r\n            targetName: targetName,\r\n            sourceData: JSON.parse(JSON.stringify(sourceChar)),\r\n            targetDataBefore: JSON.parse(JSON.stringify(targetChar)),\r\n        };\r\n\r\n        // Add to undo history\r\n        undoHistory.push(undoData);\r\n        if (undoHistory.length > 3) {\r\n            undoHistory.shift();\r\n        }\r\n\r\n        // Merge aliases\r\n        for (const alias of sourceChar.aliases) {\r\n            if (!targetChar.aliases.includes(alias)) {\r\n                targetChar.aliases.push(alias);\r\n            }\r\n        }\r\n\r\n        // Add source name as alias if not the same\r\n        if (sourceChar.preferredName !== targetChar.preferredName &&\r\n            !targetChar.aliases.includes(sourceChar.preferredName)) {\r\n            targetChar.aliases.push(sourceChar.preferredName);\r\n        }\r\n\r\n        // Merge fields (target takes precedence for conflicts, but add new fields)\r\n        if (sourceChar.physicalAge && !targetChar.physicalAge) targetChar.physicalAge = sourceChar.physicalAge;\r\n        if (sourceChar.mentalAge && !targetChar.mentalAge) targetChar.mentalAge = sourceChar.mentalAge;\r\n        if (sourceChar.physical && !targetChar.physical) targetChar.physical = sourceChar.physical;\r\n        if (sourceChar.personality && !targetChar.personality) targetChar.personality = sourceChar.personality;\r\n        if (sourceChar.sexuality && !targetChar.sexuality) targetChar.sexuality = sourceChar.sexuality;\r\n        if (sourceChar.raceEthnicity && !targetChar.raceEthnicity) targetChar.raceEthnicity = sourceChar.raceEthnicity;\r\n        if (sourceChar.roleSkills && !targetChar.roleSkills) targetChar.roleSkills = sourceChar.roleSkills;\r\n        if (sourceChar.lastInteraction && !targetChar.lastInteraction) targetChar.lastInteraction = sourceChar.lastInteraction;\r\n\r\n        // Merge relationships\r\n        for (const rel of sourceChar.relationships) {\r\n            if (!targetChar.relationships.includes(rel)) {\r\n                targetChar.relationships.push(rel);\r\n            }\r\n        }\r\n\r\n        // Update timestamp\r\n        targetChar.lastUpdated = Date.now();\r\n\r\n        // Update target character and delete source\r\n        setCharacter(targetChar.preferredName, targetChar);\r\n        removeCharacter(sourceName);\r\n\r\n        // Save chat data\r\n        // Auto-saved by new settings system\r\n\r\n        debug.log();\r\n        notifications.success(`Merged ${sourceName} into ${targetName}`);\r\n\r\n        return undoData;\r\n    });\r\n}\r\n\r\n/**\r\n * Undo last merge operation\r\n * @returns {Promise<boolean>} True if undo was successful\r\n */\r\nexport async function undoLastMerge() {\r\n    return withErrorBoundary('undoLastMerge', async () => {\r\n        if (undoHistory.length === 0) {\r\n            notifications.warning('No merge operations to undo');\r\n            return false;\r\n        }\r\n\r\n        const lastOp = undoHistory.pop();\r\n\r\n        if (lastOp.operation !== 'merge') {\r\n            notifications.error('Last operation was not a merge');\r\n            return false;\r\n        }\r\n\r\n        // Restore source character\r\n        setCharacter(lastOp.sourceName, lastOp.sourceData);\r\n\r\n        // Restore target character to pre-merge state\r\n        setCharacter(lastOp.targetName, lastOp.targetDataBefore);\r\n\r\n        debug.log();\r\n        notifications.success('Merge undone successfully');\r\n\r\n        return true;\r\n    });\r\n}\r\n\r\n/**\r\n * Toggle ignore status for a character\r\n * @param {string} characterName - Name of character to toggle\r\n * @returns {boolean} New ignore status\r\n */\r\nexport async function toggleIgnoreCharacter(characterName) {\r\n    return withErrorBoundary('toggleIgnoreCharacter', async () => {\r\n        const character = getCharacter(characterName);\r\n\r\n        if (!character) {\r\n            throw new NameTrackerError('Character not found');\r\n        }\r\n\r\n        character.ignored = !character.ignored;\r\n\r\n        setCharacter(characterName, character);\r\n\r\n        // Save chat data\r\n        // Auto-saved by new settings system\r\n\r\n        const status = character.ignored ? 'ignored' : 'unignored';\r\n        notifications.info(`${characterName} ${status}`);\r\n        debug.log();\r\n\r\n        return character.ignored;\r\n    });\r\n}\r\n\r\n/**\r\n * Manually create a new character\r\n * @param {string} characterName - Name of new character\r\n * @returns {Promise<CharacterData>} Created character\r\n */\r\nexport async function createNewCharacter(characterName) {\r\n    return withErrorBoundary('createNewCharacter', async () => {\r\n        if (!characterName || !characterName.trim()) {\r\n            throw new NameTrackerError('Character name is required');\r\n        }\r\n\r\n        const trimmedName = characterName.trim();\r\n\r\n        // Check if character already exists\r\n        if (getCharacter(trimmedName)) {\r\n            throw new NameTrackerError(`Character \"${trimmedName}\" already exists`);\r\n        }\r\n\r\n        // Create basic character structure\r\n        const newChar = {\r\n            name: trimmedName,\r\n            aliases: [],\r\n            physicalAge: '',\r\n            mentalAge: '',\r\n            physical: '',\r\n            personality: '',\r\n            sexuality: '',\r\n            raceEthnicity: '',\r\n            roleSkills: '',\r\n            lastInteraction: '',\r\n            relationships: [],\r\n            confidence: 100, // Manually created = 100% confidence\r\n        };\r\n\r\n        const character = await createCharacter(newChar, false);\r\n\r\n        // Save chat data\r\n        // Auto-saved by new settings system\r\n\r\n        debug.log();\r\n        notifications.success(`Created character: ${trimmedName}`);\r\n\r\n        return character;\r\n    });\r\n}\r\n\r\n/**\r\n * Purge all character entries\r\n * @returns {Promise<number>} Number of characters purged\r\n */\r\nexport async function purgeAllCharacters() {\r\n    return withErrorBoundary('purgeAllCharacters', async () => {\r\n        const chars = getCharacters();\r\n        const characterCount = Object.keys(chars).length;\r\n\r\n        if (characterCount === 0) {\r\n            notifications.info('No characters to purge');\r\n            return 0;\r\n        }\r\n\r\n        // Clear all character data\r\n        set_chat_metadata('characters', {});\r\n\r\n        // Clear undo history\r\n        undoHistory = [];\r\n\r\n        debug.log();\r\n        notifications.success(`Purged ${characterCount} characters`);\r\n\r\n        return characterCount;\r\n    });\r\n}\r\n\r\n/**\r\n * Check if character has unresolved relationships\r\n * @param {CharacterData} character - Character to check\r\n * @returns {boolean} True if character has relationships to unknown characters\r\n */\r\nexport function hasUnresolvedRelationships(character) {\r\n    return withErrorBoundary('hasUnresolvedRelationships', () => {\r\n        if (!character.relationships || character.relationships.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        const chars = getCharacters();\r\n        const knownNames = Object.values(chars).reduce((names, char) => {\r\n            names.add(char.preferredName.toLowerCase());\r\n            char.aliases.forEach(alias => names.add(alias.toLowerCase()));\r\n            return names;\r\n        }, new Set());\r\n\r\n        return character.relationships.some(rel => {\r\n            // Simple check - extract character names from relationship strings\r\n            const words = rel.toLowerCase().split(/\\s+/);\r\n            return words.some(word => {\r\n                return word.length > 2 && !knownNames.has(word);\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * Get undo history\r\n * @returns {Array} Array of undo operations\r\n */\r\nexport function getUndoHistory() {\r\n    return [...undoHistory];\r\n}\r\n\r\n/**\r\n * Clear undo history\r\n */\r\nexport function clearUndoHistory() {\r\n    undoHistory = [];\r\n    debug.log();\r\n}\r\n\r\n/**\r\n * Export all characters as JSON\r\n * @returns {Object} Character data\r\n */\r\nexport function exportCharacters() {\r\n    return withErrorBoundary('exportCharacters', () => {\r\n        return getCharacters();\r\n    });\r\n}\r\n\r\n/**\r\n * Import characters from JSON\r\n * @param {Object} characterData - Character data to import\r\n * @param {boolean} merge - Whether to merge with existing characters\r\n * @returns {Promise<number>} Number of characters imported\r\n */\r\nexport async function importCharacters(characterData, merge = false) {\r\n    return withErrorBoundary('importCharacters', async () => {\r\n        if (!characterData || typeof characterData !== 'object') {\r\n            throw new NameTrackerError('Invalid character data');\r\n        }\r\n\r\n        let importCount = 0;\r\n\r\n        for (const [name, character] of Object.entries(characterData)) {\r\n            if (merge || !getCharacter(name)) {\r\n                setCharacter(name, character);\r\n                importCount++;\r\n            }\r\n        }\r\n\r\n        debug.log();\r\n        notifications.success(`Imported ${importCount} characters`);\r\n\r\n        return importCount;\r\n    });\r\n}\r\n","\"use strict\";\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;","/**\r\n * Notification utilities for Name Tracker extension\r\n * Centralizes toastr notifications with consistent styling\r\n */\r\n\r\nimport debugLogger from '../core/debug.js';\r\n\r\nconst logger = debugLogger.createModuleLogger('Notifications');\r\n\r\nclass NotificationManager {\r\n    constructor() {\r\n        this.defaultOptions = {\r\n            timeOut: 5000,\r\n            extendedTimeOut: 2000,\r\n            closeButton: true,\r\n            progressBar: true,\r\n            preventDuplicates: true,\r\n        };\r\n\r\n        this.prefix = 'Name Tracker: ';\r\n    }\r\n\r\n    /**\r\n     * Show success notification\r\n     * @param {string} message - Message to display\r\n     * @param {string} title - Optional title\r\n     * @param {Object} options - Toastr options\r\n     */\r\n    success(message, title = 'Success', options = {}) {\r\n        const opts = { ...this.defaultOptions, ...options };\r\n        toastr.success(this.prefix + message, title, opts);\r\n        logger.debug('Success notification:', message);\r\n    }\r\n\r\n    /**\r\n     * Show info notification\r\n     * @param {string} message - Message to display\r\n     * @param {string} title - Optional title\r\n     * @param {Object} options - Toastr options\r\n     */\r\n    info(message, title = 'Info', options = {}) {\r\n        const opts = { ...this.defaultOptions, ...options };\r\n        toastr.info(this.prefix + message, title, opts);\r\n        logger.debug('Info notification:', message);\r\n    }\r\n\r\n    /**\r\n     * Show warning notification\r\n     * @param {string} message - Message to display\r\n     * @param {string} title - Optional title\r\n     * @param {Object} options - Toastr options\r\n     */\r\n    warning(message, title = 'Warning', options = {}) {\r\n        const opts = { ...this.defaultOptions, timeOut: 8000, ...options };\r\n        toastr.warning(this.prefix + message, title, opts);\r\n        logger.debug('Warning notification:', message);\r\n    }\r\n\r\n    /**\r\n     * Show error notification\r\n     * @param {string} message - Message to display\r\n     * @param {string} title - Optional title\r\n     * @param {Object} options - Toastr options\r\n     */\r\n    error(message, title = 'Error', options = {}) {\r\n        const opts = {\r\n            ...this.defaultOptions,\r\n            timeOut: 10000,\r\n            extendedTimeOut: 5000,\r\n            ...options,\r\n        };\r\n        toastr.error(this.prefix + message, title, opts);\r\n        logger.error('Error notification:', message);\r\n    }\r\n\r\n    /**\r\n     * Show persistent notification that doesn't auto-close\r\n     * @param {string} message - Message to display\r\n     * @param {string} title - Optional title\r\n     * @param {string} type - Notification type (info, success, warning, error)\r\n     */\r\n    persistent(message, title = 'Notice', type = 'info') {\r\n        const opts = {\r\n            ...this.defaultOptions,\r\n            timeOut: 0,\r\n            extendedTimeOut: 0,\r\n        };\r\n\r\n        switch (type) {\r\n            case 'success':\r\n                toastr.success(this.prefix + message, title, opts);\r\n                break;\r\n            case 'warning':\r\n                toastr.warning(this.prefix + message, title, opts);\r\n                break;\r\n            case 'error':\r\n                toastr.error(this.prefix + message, title, opts);\r\n                break;\r\n            default:\r\n                toastr.info(this.prefix + message, title, opts);\r\n        }\r\n\r\n        logger.debug('Persistent notification:', message);\r\n    }\r\n\r\n    /**\r\n     * Show progress notification for long operations\r\n     * @param {string} message - Message to display\r\n     * @param {number} progress - Progress percentage (0-100)\r\n     * @param {string} id - Unique ID for updating the same notification\r\n     * @returns {string} Notification ID for updates\r\n     */\r\n    progress(message, progress = 0, id = null) {\r\n        const notificationId = id || `progress_${Date.now()}`;\r\n        const progressHtml = `\r\n            <div style=\"margin-bottom: 8px;\">${this.prefix}${message}</div>\r\n            <div style=\"background: #333; border-radius: 3px; overflow: hidden;\">\r\n                <div style=\"background: #007acc; height: 6px; width: ${progress}%; transition: width 0.3s ease;\"></div>\r\n            </div>\r\n            <div style=\"text-align: center; font-size: 11px; margin-top: 4px;\">${progress}%</div>\r\n        `;\r\n\r\n        const opts = {\r\n            timeOut: 0,\r\n            extendedTimeOut: 0,\r\n            closeButton: false,\r\n            progressBar: false,\r\n            preventDuplicates: false,\r\n            toastId: notificationId,\r\n        };\r\n\r\n        // Remove existing notification with same ID\r\n        toastr.remove();\r\n\r\n        toastr.info(progressHtml, '', opts);\r\n        logger.debug('Progress notification:', message, `${progress}%`);\r\n\r\n        return notificationId;\r\n    }\r\n\r\n    /**\r\n     * Clear all notifications\r\n     */\r\n    clear() {\r\n        toastr.clear();\r\n        logger.debug('Cleared all notifications');\r\n    }\r\n\r\n    /**\r\n     * Show a confirmation-style notification with action buttons\r\n     * @param {string} message - Message to display\r\n     * @param {Function} onConfirm - Callback for confirm action\r\n     * @param {Function} onCancel - Callback for cancel action\r\n     * @param {string} title - Optional title\r\n     */\r\n    confirm(message, onConfirm, onCancel = null, title = 'Confirm') {\r\n        const confirmId = `confirm_${Date.now()}`;\r\n        const confirmHtml = `\r\n            <div style=\"margin-bottom: 12px;\">${message}</div>\r\n            <div style=\"text-align: right;\">\r\n                <button class=\"btn btn-sm btn-secondary me-2\" onclick=\"nameTrackerNotifications.handleConfirmCancel('${confirmId}')\">Cancel</button>\r\n                <button class=\"btn btn-sm btn-primary\" onclick=\"nameTrackerNotifications.handleConfirmOk('${confirmId}')\">Confirm</button>\r\n            </div>\r\n        `;\r\n\r\n        // Store callbacks globally for onclick handlers\r\n        window.nameTrackerNotifications = window.nameTrackerNotifications || {};\r\n        window.nameTrackerNotifications.confirmCallbacks = window.nameTrackerNotifications.confirmCallbacks || {};\r\n        window.nameTrackerNotifications.confirmCallbacks[confirmId] = { onConfirm, onCancel };\r\n\r\n        window.nameTrackerNotifications.handleConfirmOk = (id) => {\r\n            const callbacks = window.nameTrackerNotifications.confirmCallbacks[id];\r\n            if (callbacks && callbacks.onConfirm) {\r\n                callbacks.onConfirm();\r\n            }\r\n            delete window.nameTrackerNotifications.confirmCallbacks[id];\r\n            toastr.clear();\r\n        };\r\n\r\n        window.nameTrackerNotifications.handleConfirmCancel = (id) => {\r\n            const callbacks = window.nameTrackerNotifications.confirmCallbacks[id];\r\n            if (callbacks && callbacks.onCancel) {\r\n                callbacks.onCancel();\r\n            }\r\n            delete window.nameTrackerNotifications.confirmCallbacks[id];\r\n            toastr.clear();\r\n        };\r\n\r\n        const opts = {\r\n            timeOut: 0,\r\n            extendedTimeOut: 0,\r\n            closeButton: false,\r\n            progressBar: false,\r\n            preventDuplicates: false,\r\n            toastId: confirmId,\r\n        };\r\n\r\n        toastr.info(confirmHtml, this.prefix + title, opts);\r\n        logger.debug('Confirmation notification:', message);\r\n\r\n        return confirmId;\r\n    }\r\n\r\n    /**\r\n     * Get notification status for debugging\r\n     * @returns {Object} Status information\r\n     */\r\n    getStatus() {\r\n        return {\r\n            defaultOptions: this.defaultOptions,\r\n            prefix: this.prefix,\r\n            activeConfirms: Object.keys(window.nameTrackerNotifications?.confirmCallbacks || {}).length,\r\n        };\r\n    }\r\n}\r\n\r\n// Create singleton instance\r\nconst notifications = new NotificationManager();\r\n\r\nlogger.debug('Notifications module loaded');\r\n\r\nexport { NotificationManager };\r\nexport default notifications;\r\n","/**\r\n * LLM Integration Module\r\n *\r\n * Handles LLM API calls to SillyTavern and Ollama for character analysis.\r\n * Includes conservative parameter settings, token management, context window handling,\r\n * and JSON parsing for deterministic character extraction.\r\n */\r\n\r\nimport { createModuleLogger } from '../core/debug.js';\r\nimport { withErrorBoundary, NameTrackerError } from '../core/errors.js';\r\nimport { get_settings, getCharacters, getLLMConfig } from '../core/settings.js';\r\nimport { stContext } from '../core/context.js';\r\nimport { simpleHash } from '../utils/helpers.js';\r\nimport { NotificationManager } from '../utils/notifications.js';\r\n\r\nconst debug = createModuleLogger('llm');\r\nconst notifications = new NotificationManager('LLM Integration');\r\n\r\n// ============================================================================\r\n// DEBUG CONFIGURATION\r\n// ============================================================================\r\nconst DEBUG_LOGGING = true; // Set to false in production after testing\r\n\r\nfunction debugLog(message, data = null) {\r\n    if (DEBUG_LOGGING) {\r\n        console.log(`[NT-LLM] ${message}`, data || '');\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// CONFIGURATION CONSTANTS - Conservative parameters for deterministic output\r\n// ============================================================================\r\n// These hardcoded values ensure reliable JSON extraction with minimal hallucination.\r\n// They override user chat settings specifically for character analysis operations.\r\n\r\n// Generation Parameters (Anti-hallucination configuration)\r\nconst GENERATION_TEMPERATURE = 0.2;     // Very low for deterministic output\r\nconst GENERATION_TOP_P = 0.85;          // Slightly reduced nucleus sampling\r\nconst GENERATION_TOP_K = 25;            // Standard focused sampling\r\nconst GENERATION_REP_PEN = 1.1;         // Slight repetition penalty\r\n\r\n// Context Window Management\r\n// Reserved for future dynamic context management\r\n// eslint-disable-next-line no-unused-vars\r\nconst RESPONSE_BUFFER_PERCENT = 25;     // Reserve 25% for response generation\r\n// eslint-disable-next-line no-unused-vars\r\nconst SAFETY_MARGIN_PERCENT = 10;       // Reserve 10% safety margin\r\n// eslint-disable-next-line no-unused-vars\r\nconst MIN_RESPONSE_TOKENS = 1000;       // Minimum tokens allowed for response\r\n\r\n// Ollama-Specific Parameters\r\n// eslint-disable-next-line no-unused-vars\r\nconst OLLAMA_MIN_PREDICT = 500;         // Minimum tokens to predict\r\n// eslint-disable-next-line no-unused-vars\r\nconst OLLAMA_MAX_PREDICT = 4000;        // Maximum tokens to predict\r\n\r\n// Cache Configuration\r\n// eslint-disable-next-line no-unused-vars\r\nconst CACHE_MAX_ENTRIES = 50;           // Maximum cached analysis results\r\n// eslint-disable-next-line no-unused-vars\r\nconst CACHE_INVALIDATION_TIME = 3600000; // 1 hour cache duration\r\n\r\n// LLM state management\r\nconst analysisCache = new Map(); // Cache for LLM analysis results\r\nlet ollamaModels = []; // Available Ollama models\r\n\r\n/**\r\n * JSON Schema for structured character extraction\r\n * Enforces strict JSON structure for reliable parsing\r\n * Per: https://docs.sillytavern.app/for-contributors/writing-extensions/#structured-outputs\r\n */\r\nconst CHARACTER_EXTRACTION_SCHEMA = {\r\n    name: 'CharacterAnalysis',\r\n    description: 'Structured character information extracted from chat messages',\r\n    strict: true,\r\n    value: {\r\n        '$schema': 'http://json-schema.org/draft-07/schema#',\r\n        'type': 'object',\r\n        'properties': {\r\n            'characters': {\r\n                'type': 'array',\r\n                'description': 'Array of character objects',\r\n                'items': {\r\n                    'type': 'object',\r\n                    'properties': {\r\n                        'name': {\r\n                            'type': 'string',\r\n                            'description': 'Character\\'s preferred name (first and last if provided)',\r\n                        },\r\n                        'aliases': {\r\n                            'type': 'array',\r\n                            'description': 'Alternative names, nicknames, titles',\r\n                            'items': { 'type': 'string' },\r\n                        },\r\n                        'physicalAge': {\r\n                            'type': 'string',\r\n                            'description': 'Apparent age in years or ??? if unknown',\r\n                        },\r\n                        'mentalAge': {\r\n                            'type': 'string',\r\n                            'description': 'Actual age (can differ for immortals) or ??? if unknown',\r\n                        },\r\n                        'physical': {\r\n                            'type': 'string',\r\n                            'description': 'Physical description (2-3 paragraphs)',\r\n                        },\r\n                        'personality': {\r\n                            'type': 'string',\r\n                            'description': 'Personality traits, quirks, habits (2-3 paragraphs)',\r\n                        },\r\n                        'sexuality': {\r\n                            'type': 'string',\r\n                            'description': 'Sexual orientation, preferences if mentioned',\r\n                        },\r\n                        'raceEthnicity': {\r\n                            'type': 'string',\r\n                            'description': 'Race/species/ethnicity if mentioned',\r\n                        },\r\n                        'roleSkills': {\r\n                            'type': 'string',\r\n                            'description': 'Occupation, abilities, talents',\r\n                        },\r\n                        'lastInteraction': {\r\n                            'type': 'string',\r\n                            'description': 'Most recent interaction with user',\r\n                        },\r\n                        'relationships': {\r\n                            'type': 'array',\r\n                            'description': 'Relationships with other characters',\r\n                            'items': { 'type': 'string' },\r\n                        },\r\n                        'confidence': {\r\n                            'type': 'integer',\r\n                            'description': 'Confidence score 0-100 (90+=explicit, 70-89=clear, 50-69=mentioned, <50=vague)',\r\n                            'minimum': 0,\r\n                            'maximum': 100,\r\n                        },\r\n                    },\r\n                    'required': ['name', 'aliases', 'physicalAge', 'mentalAge', 'physical', 'personality',\r\n                        'sexuality', 'raceEthnicity', 'roleSkills', 'lastInteraction', 'relationships', 'confidence'],\r\n                    'additionalProperties': false,\r\n                },\r\n            },\r\n        },\r\n        'required': ['characters'],\r\n        'additionalProperties': false,\r\n    },\r\n};\r\n\r\n/**\r\n * Default system prompt for character analysis\r\n */\r\nconst DEFAULT_SYSTEM_PROMPT = `Extract character information from messages and return ONLY a JSON object.\r\n\r\nCRITICAL: Your entire response must be a single JSON object starting with { and ending with }\r\n\r\nDO NOT include:\r\n- Any text before the JSON\r\n- Any text after the JSON  \r\n- Code block markers\r\n- Explanations or commentary\r\n\r\nREQUIRED JSON structure (copy this exact format):\r\n{\r\n  \"characters\": [\r\n    {\r\n      \"name\": \"Character name\",\r\n      \"aliases\": [\"Other names\"],\r\n      \"physicalAge\": \"Age if mentioned\",\r\n      \"mentalAge\": \"Mental age if different\",\r\n      \"physical\": \"Physical description\",\r\n      \"personality\": \"Personality traits\",\r\n      \"sexuality\": \"Sexual orientation if mentioned\",\r\n      \"raceEthnicity\": \"Race/ethnicity if mentioned\",\r\n      \"roleSkills\": \"Job/role/skills\",\r\n      \"lastInteraction\": \"Recent interaction with user\",\r\n      \"relationships\": [\"Relationships with other characters\"],\r\n      \"confidence\": 75\r\n    }\r\n  ]\r\n}\r\n\r\nRules:\r\n- Only extract clearly named speaking characters\r\n- Skip generic references (\"the waiter\", \"a woman\")\r\n- Use most recent information for conflicts\r\n- Empty array if no clear characters: {\"characters\":[]}\r\n- Confidence: 90+ (explicit), 70-89 (clear), 50-69 (mentioned), <50 (vague)\r\n\r\nYour response must start with { immediately.`;\r\n\r\n/**\r\n * Get the system prompt for analysis\r\n * @returns {string} System prompt text\r\n */\r\nfunction getSystemPrompt() {\r\n    return get_settings('systemPrompt') || DEFAULT_SYSTEM_PROMPT;\r\n}\r\n\r\n/**\r\n * Load available Ollama models\r\n * @returns {Promise<Array>} Array of available models\r\n */\r\nexport async function loadOllamaModels() {\r\n    return withErrorBoundary('loadOllamaModels', async () => {\r\n        const ollamaEndpoint = get_settings('ollamaEndpoint', 'http://localhost:11434');\r\n        debugLog(`[OllamaModels] Loading models from ${ollamaEndpoint}`);\r\n\r\n        try {\r\n            const response = await fetch(`${ollamaEndpoint}/api/tags`);\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`Failed to connect to Ollama: ${response.statusText}`);\r\n            }\r\n\r\n            const data = await response.json();\r\n            ollamaModels = data.models || [];\r\n            debugLog(`[OllamaModels] Found ${ollamaModels.length} models: ${ollamaModels.map(m => m.name).join(', ')}`);\r\n\r\n            return ollamaModels;\r\n        } catch (error) {\r\n            console.error('Error loading Ollama models:', error);\r\n            notifications.error('Failed to load Ollama models. Check endpoint and try again.');\r\n            throw error;\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Get Ollama model context size\r\n * @param {string} modelName - Name of the Ollama model\r\n * @returns {Promise<number>} Context size in tokens, or default 4096\r\n */\r\nexport async function getOllamaModelContext(modelName) {\r\n    return withErrorBoundary('getOllamaModelContext', async () => {\r\n        const ollamaEndpoint = get_settings('ollamaEndpoint', 'http://localhost:11434');\r\n\r\n        if (!modelName) {\r\n            debug.log();\r\n            return 4096;\r\n        }\r\n\r\n        try {\r\n            const response = await fetch(`${ollamaEndpoint}/api/show`, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                },\r\n                body: JSON.stringify({\r\n                    name: modelName,\r\n                }),\r\n            });\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`Failed to fetch model info: ${response.statusText}`);\r\n            }\r\n\r\n            const data = await response.json();\r\n\r\n            // Look for num_ctx in parameters array\r\n            if (data.parameters && Array.isArray(data.parameters)) {\r\n                for (const param of data.parameters) {\r\n                    const match = param.match(/num_ctx\\\\s+(\\\\d+)/);\r\n                    if (match) {\r\n                        const contextSize = parseInt(match[1]);\r\n                        debug.log();\r\n                        return contextSize;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Fallback: check if it's in model details\r\n            if (data.model_info && data.model_info.num_ctx) {\r\n                const contextSize = parseInt(data.model_info.num_ctx);\r\n                debug.log();\r\n                return contextSize;\r\n            }\r\n\r\n            debug.log();\r\n            return 4096;\r\n        } catch (error) {\r\n            console.error('Error fetching Ollama model context:', error);\r\n            debug.log();\r\n            return 4096;\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Build a roster of known characters for context\r\n * @returns {string} Formatted roster text\r\n */\r\nexport function buildCharacterRoster() {\r\n    return withErrorBoundary('buildCharacterRoster', () => {\r\n        const characters = getCharacters();\r\n        const characterNames = Object.keys(characters);\r\n\r\n        if (characterNames.length === 0) {\r\n            return '';\r\n        }\r\n\r\n        const roster = characterNames.map(name => {\r\n            const char = characters[name];\r\n            const aliases = char.aliases && char.aliases.length > 0\r\n                ? ` (also known as: ${char.aliases.join(', ')})`\r\n                : '';\r\n            const relationships = char.relationships && char.relationships.length > 0\r\n                ? `\\\\n    Relationships: ${char.relationships.join('; ')}`\r\n                : '';\r\n            return `  - ${name}${aliases}${relationships}`;\r\n        }).join('\\\\n');\r\n\r\n        return `\\\\n\\\\n[KNOWN CHARACTERS]\\\\nThe following characters have already been identified. If you encounter them again, use the same name and add any new details:\\\\n${roster}\\\\n`;\r\n    });\r\n}\r\n\r\n/**\r\n * Get the maximum safe prompt length based on API context window\r\n * Uses actual token counts from messages when available\r\n * @returns {Promise<number>} Maximum prompt length in tokens\r\n */\r\nexport async function getMaxPromptLength() {\r\n    return withErrorBoundary('getMaxPromptLength', async () => {\r\n        const detectionLog = []; // Track detection attempts\r\n        const logEntry = (msg) => {\r\n            detectionLog.push(msg);\r\n            console.log(`[NT-MaxContext] ${msg}`);\r\n        };\r\n\r\n        try {\r\n            const llmConfig = getLLMConfig();\r\n            let maxContext = 4096; // Default\r\n            let maxGenTokens = 2048; // Default generation limit\r\n            let detectionMethod = 'fallback';\r\n\r\n            logEntry(`Starting context detection for LLM source: ${llmConfig.source}`);\r\n\r\n            if (llmConfig.source === 'ollama' && llmConfig.ollamaModel) {\r\n                logEntry(`Using Ollama model: ${llmConfig.ollamaModel}`);\r\n                // Get Ollama model's context size\r\n                maxContext = await getOllamaModelContext(llmConfig.ollamaModel);\r\n                detectionMethod = 'ollama';\r\n            } else {\r\n                logEntry(`Using SillyTavern context`);\r\n                // Use SillyTavern's context\r\n                let context = null;\r\n                \r\n                try {\r\n                    context = stContext.getContext();\r\n                    logEntry(`Successfully retrieved SillyTavern context`);\r\n                } catch (error) {\r\n                    logEntry(`ERROR: Failed to get context: ${error.message}`);\r\n                    context = null;\r\n                }\r\n\r\n                // Debug: Log all context properties\r\n                if (context) {\r\n                    try {\r\n                        const contextKeys = Object.keys(context);\r\n                        const relevantKeys = contextKeys.filter(k => \r\n                            k.toLowerCase().includes('max') || \r\n                            k.toLowerCase().includes('context') ||\r\n                            k.toLowerCase().includes('token') ||\r\n                            k.toLowerCase().includes('prompt')\r\n                        );\r\n                        logEntry(`Available context properties: ${relevantKeys.join(', ')}`);\r\n                    } catch (e) {\r\n                        logEntry(`Error analyzing context keys: ${e.message}`);\r\n                    }\r\n                }\r\n\r\n                // Try multiple possible paths for max context\r\n                let detectedMaxContext = null;\r\n\r\n                // Method 1: Direct maxContext property (PRIMARY)\r\n                logEntry(`Method 1: Checking context.maxContext...`);\r\n                if (context && typeof context.maxContext === 'number' && context.maxContext > 0) {\r\n                    detectedMaxContext = context.maxContext;\r\n                    logEntry(` Method 1 SUCCESS: context.maxContext = ${detectedMaxContext}`);\r\n                    detectionMethod = 'context.maxContext';\r\n                } else {\r\n                    const reason = !context ? 'context is null' : \r\n                                   typeof context.maxContext !== 'number' ? `type is ${typeof context.maxContext}` :\r\n                                   context.maxContext <= 0 ? `value is ${context.maxContext}` : 'unknown';\r\n                    logEntry(` Method 1 FAILED: ${reason}`);\r\n                }\r\n\r\n                // Method 2: extensionSettings.common.maxContext path\r\n                if (!detectedMaxContext) {\r\n                    logEntry(`Method 2: Checking context.extensionSettings.common.maxContext...`);\r\n                    if (context?.extensionSettings?.common) {\r\n                        if (typeof context.extensionSettings.common.maxContext === 'number' && context.extensionSettings.common.maxContext > 0) {\r\n                            detectedMaxContext = context.extensionSettings.common.maxContext;\r\n                            logEntry(` Method 2 SUCCESS: extensionSettings.common.maxContext = ${detectedMaxContext}`);\r\n                            detectionMethod = 'extensionSettings.common.maxContext';\r\n                        } else {\r\n                            logEntry(` Method 2 FAILED: extensionSettings.common exists but maxContext is invalid`);\r\n                        }\r\n                    } else {\r\n                        logEntry(` Method 2 FAILED: extensionSettings.common path does not exist`);\r\n                    }\r\n                }\r\n\r\n                // Method 3: chat.maxContextSize path\r\n                if (!detectedMaxContext) {\r\n                    logEntry(`Method 3: Checking context.chat.maxContextSize...`);\r\n                    if (context?.chat && typeof context.chat === 'object' && !Array.isArray(context.chat)) {\r\n                        if (typeof context.chat.maxContextSize === 'number' && context.chat.maxContextSize > 0) {\r\n                            detectedMaxContext = context.chat.maxContextSize;\r\n                            logEntry(` Method 3 SUCCESS: chat.maxContextSize = ${detectedMaxContext}`);\r\n                            detectionMethod = 'chat.maxContextSize';\r\n                        } else {\r\n                            logEntry(` Method 3 FAILED: chat exists but maxContextSize is invalid`);\r\n                        }\r\n                    } else {\r\n                        logEntry(` Method 3 FAILED: chat path does not exist or is an array`);\r\n                    }\r\n                }\r\n\r\n                // Method 4: token_limit\r\n                if (!detectedMaxContext) {\r\n                    logEntry(`Method 4: Checking context.token_limit...`);\r\n                    if (context && typeof context.token_limit === 'number' && context.token_limit > 0) {\r\n                        detectedMaxContext = context.token_limit;\r\n                        logEntry(` Method 4 SUCCESS: token_limit = ${detectedMaxContext}`);\r\n                        detectionMethod = 'token_limit';\r\n                    } else {\r\n                        logEntry(` Method 4 FAILED: token_limit is not valid`);\r\n                    }\r\n                }\r\n\r\n                // Method 5: amount_gen (maximum generation tokens)\r\n                if (!detectedMaxContext) {\r\n                    logEntry(`Method 5: Checking context.amount_gen (fallback)...`);\r\n                    if (context && typeof context.amount_gen === 'number' && context.amount_gen > 0) {\r\n                        // amount_gen is typically small (generation limit), not context size\r\n                        // Use as indicator if no other value found\r\n                        detectedMaxContext = context.amount_gen * 4; // Rough estimate\r\n                        logEntry(` Method 5 FALLBACK: amount_gen = ${context.amount_gen}, estimated context = ${detectedMaxContext}`);\r\n                        detectionMethod = 'amount_gen_estimate';\r\n                    } else {\r\n                        logEntry(` Method 5 FAILED: amount_gen is not valid`);\r\n                    }\r\n                }\r\n\r\n                // Method 6: Check settings object directly\r\n                if (!detectedMaxContext) {\r\n                    logEntry(`Method 6: Checking context.settings.max_context...`);\r\n                    if (context && typeof context.settings === 'object') {\r\n                        if (typeof context.settings.max_context === 'number' && context.settings.max_context > 0) {\r\n                            detectedMaxContext = context.settings.max_context;\r\n                            logEntry(` Method 6 SUCCESS: settings.max_context = ${detectedMaxContext}`);\r\n                            detectionMethod = 'settings.max_context';\r\n                        } else {\r\n                            logEntry(` Method 6 FAILED: settings exists but max_context is invalid`);\r\n                        }\r\n                    } else {\r\n                        logEntry(` Method 6 FAILED: settings path does not exist`);\r\n                    }\r\n                }\r\n\r\n                // Final check: is detected value reasonable?\r\n                if (detectedMaxContext && (typeof detectedMaxContext !== 'number' || detectedMaxContext < 100)) {\r\n                    logEntry(`WARNING: Detected maxContext is not valid: ${detectedMaxContext}, type: ${typeof detectedMaxContext}`);\r\n                    detectedMaxContext = null;\r\n                }\r\n\r\n                // Check if context is fully loaded\r\n                if (!context || !detectedMaxContext) {\r\n                    logEntry(`WARNING: Could not detect maxContext from any path, using fallback (4096)`);\r\n                    logEntry(`Context exists: ${!!context}, detectedMaxContext: ${detectedMaxContext}`);\r\n                    if (context) {\r\n                        try {\r\n                            const allKeys = Object.keys(context).sort();\r\n                            logEntry(`Full context object keys (first 20): ${allKeys.slice(0, 20).join(', ')}${allKeys.length > 20 ? `... (${allKeys.length - 20} more)` : ''}`);\r\n                        } catch (e) {\r\n                            logEntry(`Could not enumerate context keys: ${e.message}`);\r\n                        }\r\n                    }\r\n                    maxContext = 4096;\r\n                    maxGenTokens = 1024;\r\n                    detectionMethod = 'fallback';\r\n                } else {\r\n                    maxContext = Math.floor(detectedMaxContext);\r\n                    logEntry(`Detected maxContext: ${maxContext} (type: ${typeof maxContext})`);\r\n\r\n                    // For our extension's background analysis, we set our own max_tokens in generateRaw()\r\n                    // We don't use amount_gen (that's for user chat messages)\r\n                    // Reserve a reasonable amount for our structured JSON responses\r\n                    maxGenTokens = Math.min(4096, Math.floor(maxContext * 0.15)); // 15% or 4096, whichever is lower\r\n\r\n                    logEntry(`Extension will request max ${maxGenTokens} tokens for analysis responses (15% of context, capped at 4096)`);\r\n                }\r\n            }\r\n\r\n            // Reserve space for: system prompt (500 tokens) + max generation (maxGenTokens) + safety margin (500)\r\n            const reservedTokens = 500 + maxGenTokens + 500;\r\n            const tokensForPrompt = Math.max(1000, maxContext - reservedTokens);\r\n\r\n            logEntry(`Token allocation: maxContext=${maxContext}, reserved=${reservedTokens}, available=${tokensForPrompt}`);\r\n            logEntry(`Final detection method: ${detectionMethod}`);\r\n\r\n            const finalValue = Math.max(1000, Math.min(tokensForPrompt, 50000));\r\n            logEntry(`Returning maxPromptLength: ${finalValue}`);\r\n\r\n            // Return object with detection details\r\n            return {\r\n                maxPrompt: finalValue,\r\n                detectionMethod: detectionMethod,\r\n                maxContext: maxContext,\r\n                debugLog: detectionLog.join('\\n')\r\n            };\r\n        } catch (error) {\r\n            const errorMsg = `ERROR in getMaxPromptLength: ${error.message}`;\r\n            logEntry(errorMsg);\r\n            console.error(`[NT-MaxContext] Stack:`, error.stack);\r\n            // Return conservative fallback on any error with details\r\n            return {\r\n                maxPrompt: 3276, // Based on default 4096 context with reserves\r\n                detectionMethod: 'error',\r\n                maxContext: 4096,\r\n                debugLog: detectionLog.join('\\n') + '\\nFATAL ERROR: ' + error.message\r\n            };\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Calculate total token count for a batch of messages\r\n * Uses pre-calculated token counts from SillyTavern when available\r\n * @param {Array} messages - Array of chat message objects\r\n * @returns {Promise<number>} Total token count\r\n */\r\nexport async function calculateMessageTokens(messages) {\r\n    return withErrorBoundary('calculateMessageTokens', async () => {\r\n        const context = stContext.getContext();\r\n        let totalTokens = 0;\r\n\r\n        // Try to use pre-calculated token counts from message objects\r\n        for (const msg of messages) {\r\n            if (msg && typeof msg === 'object' && msg.extra && typeof msg.extra.token_count === 'number') {\r\n                // SillyTavern stores token count in extra.token_count\r\n                totalTokens += msg.extra.token_count;\r\n            } else {\r\n                // Fallback: use getTokenCountAsync for the message text\r\n                const text = msg?.mes || msg?.message || String(msg);\r\n                if (text && context.getTokenCountAsync) {\r\n                    try {\r\n                        const count = await context.getTokenCountAsync(text);\r\n                        totalTokens += count;\r\n                    // eslint-disable-next-line no-unused-vars\r\n                    } catch (_error) {\r\n                        debug.log();\r\n                        // Final fallback: rough estimate (4 chars per token)\r\n                        totalTokens += Math.ceil(text.length / 4);\r\n                    }\r\n                } else {\r\n                    // Character-based estimate\r\n                    totalTokens += Math.ceil(text.length / 4);\r\n                }\r\n            }\r\n        }\r\n\r\n        return totalTokens;\r\n    });\r\n}\r\n\r\n/**\r\n * Call SillyTavern's LLM with optimized parameters for JSON extraction\r\n * Uses low temperature and focused sampling for deterministic, structured output\r\n * These settings override the user's chat settings to ensure reliable parsing\r\n * @param {string} prompt - The complete prompt to send\r\n * @returns {Promise<Object>} Parsed JSON response\r\n */\r\nexport async function callSillyTavern(prompt) {\r\n    return withErrorBoundary('callSillyTavern', async () => {\r\n        debug.log();\r\n\r\n        // Use SillyTavern.getContext() as recommended in official docs\r\n        const context = stContext.getContext();\r\n\r\n        // Check if we have an active API connection\r\n        if (!context.onlineStatus) {\r\n            throw new NameTrackerError('No API connection available. Please connect to an API first.');\r\n        }\r\n\r\n        console.log('[NT-ST-Call] Starting SillyTavern LLM call');\r\n        console.log('[NT-ST-Call] Prompt length:', prompt.length, 'characters');\r\n        console.log('[NT-ST-Call] Prompt preview:', prompt.substring(0, 200) + '...');\r\n\r\n        // Get token count for the prompt\r\n\r\n        let promptTokens;\r\n        try {\r\n            promptTokens = await context.getTokenCountAsync(prompt);\r\n            console.log('[NT-ST-Call] Token count:', promptTokens);\r\n            debug.log();\r\n            // eslint-disable-next-line no-unused-vars\r\n        } catch (_error) {\r\n            console.log('[NT-ST-Call] Token count failed, estimating:', _error.message);\r\n            debug.log();\r\n            promptTokens = Math.ceil(prompt.length / 4);\r\n            console.log('[NT-ST-Call] Estimated tokens:', promptTokens);\r\n            debug.log();\r\n        }\r\n\r\n        // Calculate max_tokens dynamically: 1/4 of context size, minimum 4000\r\n        // This scales with the model's context window for better headroom\r\n        const maxContext = context.maxContext || 4096;\r\n        const calculatedMaxTokens = Math.floor(maxContext * 0.25);\r\n        const maxTokens = Math.max(4000, calculatedMaxTokens);\r\n        console.log('[NT-ST-Call] Max context:', maxContext, 'Calculated maxTokens:', maxTokens);\r\n        debug.log();\r\n\r\n        // Use generateRaw as documented in:\r\n        // https://docs.sillytavern.app/for-contributors/writing-extensions/#raw-generation\r\n        // With structured outputs per: https://docs.sillytavern.app/for-contributors/writing-extensions/#structured-outputs\r\n        console.log('[NT-ST-Call] Calling generateRaw with params:', {\r\n            temperature: GENERATION_TEMPERATURE,\r\n            top_p: GENERATION_TOP_P,\r\n            top_k: GENERATION_TOP_K,\r\n            rep_pen: GENERATION_REP_PEN,\r\n            max_tokens: maxTokens,\r\n        });\r\n\r\n        const result = await context.generateRaw({\r\n            prompt: prompt,  // Can be string (Text Completion) or array (Chat Completion)\r\n            systemPrompt: '',  // Empty, we include instructions in prompt\r\n            prefill: '',  // No prefill needed for analysis\r\n            // Override generation settings for structured output\r\n            // These hardcoded conservative settings ensure consistent, deterministic JSON\r\n            // regardless of user's chat settings - critical for reliable character extraction\r\n            temperature: GENERATION_TEMPERATURE,     // Very low for deterministic output\r\n            top_p: GENERATION_TOP_P,                 // Focused sampling\r\n            top_k: GENERATION_TOP_K,                 // Standard focused token selection\r\n            rep_pen: GENERATION_REP_PEN,             // Slight repetition penalty\r\n            max_tokens: maxTokens,  // Dynamic: 25% of context, min 4000 (prevents truncation)\r\n            stop: [],           // No custom stop sequences needed\r\n            // JSON Schema for structured output (Chat Completion APIs only)\r\n            // This enforces valid JSON structure - if API doesn't support it, will be ignored\r\n            jsonSchema: CHARACTER_EXTRACTION_SCHEMA,\r\n        });\r\n\r\n        console.log('[NT-ST-Call] Raw result type:', typeof result);\r\n        console.log('[NT-ST-Call] Raw result length:', result ? result.length : 'null');\r\n        if (result) {\r\n            console.log('[NT-ST-Call] Raw result preview:', result.substring(0, 300));\r\n        }\r\n        debug.log();\r\n\r\n        // The result should be a string\r\n        if (!result) {\r\n            throw new NameTrackerError('Empty response from SillyTavern LLM');\r\n        }\r\n\r\n        const parsed = parseJSONResponse(result);\r\n        console.log('[NT-ST-Call] Parsed result:', JSON.stringify(parsed).substring(0, 300));\r\n        return parsed;\r\n    });\r\n}\r\n\r\n/**\r\n * Call Ollama API with optimized parameters for JSON extraction\r\n * Uses low temperature and focused sampling for deterministic, structured output\r\n * @param {string} prompt - The complete prompt to send\r\n * @returns {Promise<Object>} Parsed JSON response\r\n */\r\nexport async function callOllama(prompt) {\r\n    return withErrorBoundary('callOllama', async () => {\r\n        const llmConfig = getLLMConfig();\r\n\r\n        if (!llmConfig.ollamaModel) {\r\n            throw new NameTrackerError('No Ollama model selected');\r\n        }\r\n\r\n        debug.log();\r\n\r\n        // Calculate max_tokens dynamically: 1/4 of context size, minimum 4000\r\n        const maxContext = await getOllamaModelContext(llmConfig.ollamaModel);\r\n        const calculatedMaxTokens = Math.floor(maxContext * 0.25);\r\n        const maxTokens = Math.max(4000, calculatedMaxTokens);\r\n        debug.log();\r\n\r\n        const response = await fetch(`${llmConfig.ollamaEndpoint}/api/generate`, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify({\r\n                model: llmConfig.ollamaModel,\r\n                prompt: prompt,\r\n                stream: false,\r\n                format: 'json',\r\n                // Ollama-specific generation parameters for structured output\r\n                // Using same conservative settings as SillyTavern for consistency\r\n                options: {\r\n                    temperature: GENERATION_TEMPERATURE,      // Very low for deterministic output\r\n                    top_p: GENERATION_TOP_P,                  // Focused sampling\r\n                    top_k: GENERATION_TOP_K,                  // Standard focused sampling\r\n                    repeat_penalty: GENERATION_REP_PEN,       // Slight repetition penalty\r\n                    num_predict: maxTokens,  // Dynamic: 25% of context, min 4000 (prevents truncation)\r\n                },\r\n            }),\r\n        });\r\n\r\n        if (!response.ok) {\r\n            throw new NameTrackerError(`Ollama API error: ${response.statusText}`);\r\n        }\r\n\r\n        const data = await response.json();\r\n        debug.log();\r\n        debug.log();\r\n\r\n        return parseJSONResponse(data.response);\r\n    });\r\n}\r\n\r\n/**\r\n * Parse JSON response from LLM, handling various formats\r\n * @param {string} text - Raw text response from LLM\r\n * @returns {Object} Parsed JSON object\r\n */\r\nexport function parseJSONResponse(text) {\r\n    return withErrorBoundary('parseJSONResponse', () => {\r\n        console.log('[NT-Parse] Starting JSON parse, input type:', typeof text, 'length:', text ? text.length : 'null');\r\n        \r\n        if (!text || typeof text !== 'string') {\r\n            console.error('[NT-Parse] Invalid response text - not a string:', text);\r\n            throw new NameTrackerError('LLM returned empty or invalid response');\r\n        }\r\n\r\n        // Remove any leading/trailing whitespace\r\n        text = text.trim();\r\n        console.log('[NT-Parse] After trim, length:', text.length);\r\n        console.log('[NT-Parse] Content preview:', text.substring(0, 100));\r\n\r\n        // Try to extract JSON from markdown code blocks (```json or ```)\r\n        const jsonMatch = text.match(/```(?:json)?\\\\s*([\\\\s\\\\S]*?)```/);\r\n        if (jsonMatch) {\r\n            console.log('[NT-Parse] Found markdown code block, extracting JSON');\r\n            text = jsonMatch[1].trim();\r\n        }\r\n\r\n        // Try to find JSON object in the text (look for first { to last })\r\n        const firstBrace = text.indexOf('{');\r\n        const lastBrace = text.lastIndexOf('}');\r\n\r\n        console.log('[NT-Parse] First brace at:', firstBrace, 'Last brace at:', lastBrace);\r\n\r\n        if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {\r\n            text = text.substring(firstBrace, lastBrace + 1);\r\n            console.log('[NT-Parse] Extracted JSON range, new length:', text.length);\r\n        }\r\n\r\n        // Remove common prefixes that LLMs add\r\n        text = text.replace(/^(?:Here's the analysis:|Here is the JSON:|Result:|Output:)\\\\s*/i, '');\r\n\r\n        // Clean up common formatting issues\r\n        text = text.trim();\r\n\r\n        console.log('[NT-Parse] Before JSON.parse, text length:', text.length);\r\n        console.log('[NT-Parse] Text for parsing:', text.substring(0, 200));\r\n\r\n        try {\r\n            const parsed = JSON.parse(text);\r\n\r\n            console.log('[NT-Parse] Successfully parsed JSON');\r\n            console.log('[NT-Parse] Parsed object keys:', Object.keys(parsed));\r\n            \r\n            // Validate structure\r\n            if (!parsed.characters || !Array.isArray(parsed.characters)) {\r\n                console.warn('[NT-Parse] Response missing characters array, returning empty');\r\n                console.warn('[NT-Parse] Parsed object:', parsed);\r\n                return { characters: [] };\r\n            }\r\n\r\n            console.log('[NT-Parse] Valid response with', parsed.characters.length, 'characters');\r\n            return parsed;\r\n        } catch (error) {\r\n            console.error('[NT-Parse] JSON.parse failed:', error.message);\r\n            console.error('[NT-Parse] Failed text:', text.substring(0, 500));\r\n\r\n            // Check if response was truncated (common issue with long responses)\r\n            if (text.includes('\"characters\"') && !text.trim().endsWith('}')) {\r\n                debug.log();\r\n                debug.log();\r\n\r\n                // Try to salvage partial data by attempting to close the JSON\r\n                let salvaged = text;\r\n\r\n                // Count open vs closed braces to determine how many we need\r\n                const openBraces = (text.match(/\\{/g) || []).length;\r\n                const closeBraces = (text.match(/\\}/g) || []).length;\r\n                const openBrackets = (text.match(/\\[/g) || []).length;\r\n                const closeBrackets = (text.match(/\\]/g) || []).length;\r\n\r\n                console.log('[NT-Parse] Attempting recovery - open braces:', openBraces, 'closed:', closeBraces);\r\n\r\n                // Try to close incomplete strings and objects\r\n                if (salvaged.match(/\"[^\"]*$/)) {\r\n                    // Has unclosed quote\r\n                    salvaged += '\"';\r\n                }\r\n\r\n                // Close missing brackets/braces\r\n                for (let i = 0; i < (openBrackets - closeBrackets); i++) {\r\n                    salvaged += ']';\r\n                }\r\n                for (let i = 0; i < (openBraces - closeBraces); i++) {\r\n                    salvaged += '}';\r\n                }\r\n\r\n                console.log('[NT-Parse] Attempting to parse salvaged content');\r\n\r\n                try {\r\n                    const recovered = JSON.parse(salvaged);\r\n                    console.log('[NT-Parse] Successfully recovered JSON with', recovered.characters?.length || 0, 'characters');\r\n                    debug.log();\r\n                    return recovered;\r\n                } catch (e) {\r\n                    console.error('[NT-Parse] Recovery failed:', e.message);\r\n                    debug.log();\r\n                }\r\n            }\r\n\r\n            throw new NameTrackerError('Failed to parse LLM response as JSON. The response may be too long or truncated. Try analyzing fewer messages at once.');\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Call LLM for character analysis with automatic batch splitting if prompt is too long\r\n * @param {Array} messageObjs - Array of message objects (with .mes property) or strings\r\n * @param {string} knownCharacters - Roster of previously identified characters\r\n * @param {number} depth - Recursion depth (for logging)\r\n * @param {number} retryCount - Number of retries attempted\r\n * @returns {Promise<Object>} Analysis result with merged characters\r\n */\r\nexport async function callLLMAnalysis(messageObjs, knownCharacters = '', depth = 0, retryCount = 0) {\r\n    return withErrorBoundary('callLLMAnalysis', async () => {\r\n        const llmConfig = getLLMConfig();\r\n        const maxPromptResult = await getMaxPromptLength(); // Dynamic based on API context window\r\n        const maxPromptTokens = maxPromptResult.maxPrompt;\r\n        const MAX_RETRIES = 3;\r\n\r\n        debug.log();\r\n\r\n        // Extract message text\r\n        const messages = messageObjs.map(msg => {\r\n            if (typeof msg === 'string') return msg;\r\n            if (msg.mes) return msg.mes;\r\n            if (msg.message) return msg.message;\r\n            return JSON.stringify(msg);\r\n        });\r\n\r\n        // Create cache key\r\n        const cacheKey = simpleHash(messages.join('\\\\n') + llmConfig.source + llmConfig.ollamaModel);\r\n\r\n        // Check cache\r\n        if (analysisCache.has(cacheKey)) {\r\n            debug.log();\r\n            return analysisCache.get(cacheKey);\r\n        }\r\n\r\n        // Build the prompt\r\n        const messagesText = messages.map((msg, idx) => `Message ${idx + 1}:\\\\n${msg}`).join('\\\\n\\\\n');\r\n        \r\n        // Ensure system prompt and character roster are strings (not Promises)\r\n        let systemPrompt = getSystemPrompt();\r\n        if (systemPrompt && typeof systemPrompt === 'object' && systemPrompt.then) {\r\n            console.warn('[NT-Prompt] getSystemPrompt returned Promise, awaiting...');\r\n            systemPrompt = await systemPrompt;\r\n        }\r\n        systemPrompt = String(systemPrompt || DEFAULT_SYSTEM_PROMPT);\r\n        \r\n        let rosterStr = String(knownCharacters || '');\r\n        if (rosterStr && typeof rosterStr === 'object' && rosterStr.then) {\r\n            console.warn('[NT-Prompt] knownCharacters is Promise, awaiting...');\r\n            rosterStr = await rosterStr;\r\n            rosterStr = String(rosterStr);\r\n        }\r\n        \r\n        const systemInstructions = `[SYSTEM INSTRUCTION - DO NOT ROLEPLAY]\\\\n${systemPrompt}${rosterStr}\\\\n\\\\n[DATA TO ANALYZE]`;\r\n        const fullPrompt = `${systemInstructions}\\\\n${messagesText}\\\\n\\\\n[RESPOND WITH JSON ONLY - NO STORY CONTINUATION]`;\r\n\r\n        // Calculate actual token count for the prompt\r\n        let promptTokens;\r\n        try {\r\n            promptTokens = await calculateMessageTokens([{ mes: fullPrompt }]);\r\n            debug.log();\r\n        } catch (tokenError) {\r\n            debug.log();\r\n            // Fallback to character-based estimate\r\n            promptTokens = Math.ceil(fullPrompt.length / 4);\r\n        }\r\n\r\n        // If prompt is too long, split into sub-batches\r\n        if (promptTokens > maxPromptTokens && messageObjs.length > 1) {\r\n            const indent = '  '.repeat(depth);\r\n            debug.log();\r\n\r\n            // Split roughly in half\r\n            const midpoint = Math.floor(messageObjs.length / 2);\r\n            const firstHalf = messageObjs.slice(0, midpoint);\r\n            const secondHalf = messageObjs.slice(midpoint);\r\n\r\n            debug.log();\r\n\r\n            // Analyze both halves in parallel\r\n            const [result1, result2] = await Promise.all([\r\n                callLLMAnalysis(firstHalf, knownCharacters, depth + 1),\r\n                callLLMAnalysis(secondHalf, knownCharacters, depth + 1),\r\n            ]);\r\n\r\n            // Merge the results\r\n            const mergedResult = {\r\n                characters: [\r\n                    ...(result1.characters || []),\r\n                    ...(result2.characters || []),\r\n                ],\r\n            };\r\n\r\n            debug.log();\r\n            return mergedResult;\r\n        }\r\n\r\n        // Prompt is acceptable length, proceed with analysis\r\n        let result;\r\n\r\n        try {\r\n            if (llmConfig.source === 'ollama') {\r\n                result = await callOllama(fullPrompt);\r\n            } else {\r\n                result = await callSillyTavern(fullPrompt);\r\n            }\r\n        } catch (error) {\r\n            // Retry on JSON parsing errors or empty responses\r\n            if (retryCount < MAX_RETRIES &&\r\n                (error.message.includes('JSON') ||\r\n                 error.message.includes('empty') ||\r\n                 error.message.includes('truncated'))) {\r\n\r\n                debug.log();\r\n\r\n                // Add exponential backoff delay\r\n                const delay = Math.pow(2, retryCount) * 1000; // 1s, 2s, 4s\r\n                await new Promise(resolve => setTimeout(resolve, delay));\r\n\r\n                // Retry the same call\r\n                return await callLLMAnalysis(messageObjs, knownCharacters, depth, retryCount + 1);\r\n            }\r\n\r\n            // Max retries exceeded or non-retryable error\r\n            throw error;\r\n        }\r\n\r\n        // Cache the result\r\n        if (analysisCache.size > 50) {\r\n            // Clear oldest entries if cache is getting too large\r\n            const firstKey = analysisCache.keys().next().value;\r\n            analysisCache.delete(firstKey);\r\n        }\r\n        analysisCache.set(cacheKey, result);\r\n\r\n        debug.log();\r\n        return result;\r\n    });\r\n}\r\n\r\n/**\r\n * Clear the analysis cache\r\n */\r\nexport function clearAnalysisCache() {\r\n    analysisCache.clear();\r\n    debug.log();\r\n}\r\n\r\n/**\r\n * Get analysis cache statistics\r\n * @returns {Object} Cache statistics\r\n */\r\nexport function getCacheStats() {\r\n    return {\r\n        size: analysisCache.size,\r\n        entries: [...analysisCache.keys()].map(key => ({\r\n            key: key.substring(0, 8) + '...',\r\n            timestamp: Date.now(),\r\n        })),\r\n    };\r\n}\r\n\r\n/**\r\n * Get available Ollama models\r\n * @returns {Array} Array of available models\r\n */\r\nexport function getOllamaModels() {\r\n    return [...ollamaModels];\r\n}\r\n","/**\r\n * Debug and logging utilities for Name Tracker extension\r\n * Provides module-specific logging, performance monitoring, and state inspection\r\n */\r\n\r\nconst MODULE_NAME = 'STnametracker';\r\n\r\nclass DebugLogger {\r\n    constructor() {\r\n        this.modules = new Map();\r\n        this.performanceMarks = new Map();\r\n        this.operationTraces = new Map();\r\n    }\r\n\r\n    /**\r\n     * Create a module-specific logger\r\n     * @param {string} moduleName - Name of the module\r\n     * @returns {Object} Logger instance with module-specific methods\r\n     */\r\n    createModuleLogger(moduleName) {\r\n        if (this.modules.has(moduleName)) {\r\n            return this.modules.get(moduleName);\r\n        }\r\n\r\n        const logger = {\r\n            log: (...args) => this.log(moduleName, 'log', ...args),\r\n            warn: (...args) => this.log(moduleName, 'warn', ...args),\r\n            error: (...args) => this.log(moduleName, 'error', ...args),\r\n            debug: (...args) => this.log(moduleName, 'debug', ...args),\r\n            trace: (operationId, message) => this.addTrace(moduleName, operationId, message),\r\n            startTimer: (timerName) => this.startTimer(moduleName, timerName),\r\n            endTimer: (timerName) => this.endTimer(moduleName, timerName),\r\n        };\r\n\r\n        this.modules.set(moduleName, logger);\r\n        return logger;\r\n    }\r\n\r\n    /**\r\n     * Internal logging method\r\n     * @param {string} moduleName - Module name\r\n     * @param {string} level - Log level\r\n     * @param {...any} args - Arguments to log\r\n     */\r\n    log(moduleName, level, ...args) {\r\n        if (!this.isDebugEnabled()) {\r\n            return;\r\n        }\r\n\r\n        const timestamp = new Date().toLocaleTimeString();\r\n        const prefix = `[${MODULE_NAME}:${moduleName}] ${timestamp}`;\r\n\r\n        switch (level) {\r\n            case 'error':\r\n                console.error(prefix, ...args);\r\n                break;\r\n            case 'warn':\r\n                console.warn(prefix, ...args);\r\n                break;\r\n            case 'debug':\r\n                console.debug(prefix, ...args);\r\n                break;\r\n            default:\r\n                console.log(prefix, ...args);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add operation trace for debugging workflows\r\n     * @param {string} moduleName - Module name\r\n     * @param {string} operationId - Unique operation identifier\r\n     * @param {string} message - Trace message\r\n     */\r\n    addTrace(moduleName, operationId, message) {\r\n        if (!this.isDebugEnabled()) {\r\n            return;\r\n        }\r\n\r\n        if (!this.operationTraces.has(operationId)) {\r\n            this.operationTraces.set(operationId, []);\r\n        }\r\n\r\n        this.operationTraces.get(operationId).push({\r\n            module: moduleName,\r\n            timestamp: Date.now(),\r\n            message: message,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get trace history for an operation\r\n     * @param {string} operationId - Operation identifier\r\n     * @returns {Array} Trace entries\r\n     */\r\n    getTrace(operationId) {\r\n        return this.operationTraces.get(operationId) || [];\r\n    }\r\n\r\n    /**\r\n     * Start performance timer\r\n     * @param {string} moduleName - Module name\r\n     * @param {string} timerName - Timer identifier\r\n     */\r\n    startTimer(moduleName, timerName) {\r\n        const key = `${moduleName}:${timerName}`;\r\n        this.performanceMarks.set(key, performance.now());\r\n    }\r\n\r\n    /**\r\n     * End performance timer and log duration\r\n     * @param {string} moduleName - Module name\r\n     * @param {string} timerName - Timer identifier\r\n     * @returns {number} Duration in milliseconds\r\n     */\r\n    endTimer(moduleName, timerName) {\r\n        const key = `${moduleName}:${timerName}`;\r\n        const startTime = this.performanceMarks.get(key);\r\n\r\n        if (startTime === undefined) {\r\n            this.log(moduleName, 'warn', `Timer '${timerName}' was not started`);\r\n            return 0;\r\n        }\r\n\r\n        const duration = performance.now() - startTime;\r\n        this.performanceMarks.delete(key);\r\n\r\n        this.log(moduleName, 'debug', `Timer '${timerName}': ${duration.toFixed(2)}ms`);\r\n        return duration;\r\n    }\r\n\r\n    /**\r\n     * Check if debug mode is enabled\r\n     * @returns {boolean} Debug mode status\r\n     */\r\n    isDebugEnabled() {\r\n        // This will be overridden by main.js to connect to settings\r\n        return true; // Default during initialization\r\n    }\r\n\r\n    /**\r\n     * Clear all traces and performance data\r\n     */\r\n    clear() {\r\n        this.operationTraces.clear();\r\n        this.performanceMarks.clear();\r\n    }\r\n\r\n    /**\r\n     * Get performance summary\r\n     * @returns {Object} Performance statistics\r\n     */\r\n    getPerformanceSummary() {\r\n        return {\r\n            activeTimers: this.performanceMarks.size,\r\n            activeTraces: this.operationTraces.size,\r\n            modules: Array.from(this.modules.keys()),\r\n        };\r\n    }\r\n}\r\n\r\n// Create singleton instance\r\nconst debugLogger = new DebugLogger();\r\n\r\n// Export the instance and key methods for easy access\r\nexport { debugLogger };\r\n\r\n// Export functions instead of bound methods to avoid binding issues\r\nexport function createModuleLogger(moduleName) {\r\n    return debugLogger.createModuleLogger(moduleName);\r\n}\r\n\r\nexport function addTrace(moduleName, operationId, message) {\r\n    return debugLogger.addTrace(moduleName, operationId, message);\r\n}\r\n\r\nexport function startTimer(operationId) {\r\n    return debugLogger.startTimer(operationId);\r\n}\r\n\r\nexport function endTimer(operationId) {\r\n    return debugLogger.endTimer(operationId);\r\n}\r\n\r\nexport default debugLogger;\r\n","\"use strict\";\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;","/**\r\n * Utility functions for Name Tracker extension\r\n * Common helpers and shared functionality\r\n */\r\n\r\nimport debugLogger from '../core/debug.js';\r\n\r\nconst logger = debugLogger.createModuleLogger('Utils');\r\n\r\n/**\r\n * Simple hash function for generating unique identifiers\r\n * @param {string} str - String to hash\r\n * @returns {string} Hash value in base-36 format\r\n */\r\nexport function simpleHash(str) {\r\n    let hash = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        const char = str.charCodeAt(i);\r\n        hash = ((hash << 5) - hash) + char;\r\n        hash = hash & hash;\r\n    }\r\n    return hash.toString(36);\r\n}\r\n\r\n/**\r\n * Escape HTML special characters to prevent XSS\r\n * @param {string} text - Text to escape\r\n * @returns {string} HTML-safe text\r\n */\r\nexport function escapeHtml(text) {\r\n    if (typeof text !== 'string') {\r\n        return '';\r\n    }\r\n\r\n    const div = document.createElement('div');\r\n    div.textContent = text;\r\n    return div.innerHTML;\r\n}\r\n\r\n/**\r\n * Generate unique identifier\r\n * @returns {string} Unique ID\r\n */\r\nexport function generateUID() {\r\n    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);\r\n}\r\n\r\n/**\r\n * Deep clone an object\r\n * @param {any} obj - Object to clone\r\n * @returns {any} Cloned object\r\n */\r\nexport function deepClone(obj) {\r\n    if (obj === null || typeof obj !== 'object') {\r\n        return obj;\r\n    }\r\n\r\n    if (obj instanceof Date) {\r\n        return new Date(obj.getTime());\r\n    }\r\n\r\n    if (obj instanceof Array) {\r\n        return obj.map(item => deepClone(item));\r\n    }\r\n\r\n    if (typeof obj === 'object') {\r\n        const cloned = {};\r\n        Object.keys(obj).forEach(key => {\r\n            cloned[key] = deepClone(obj[key]);\r\n        });\r\n        return cloned;\r\n    }\r\n\r\n    return obj;\r\n}\r\n\r\n/**\r\n * Debounce function calls\r\n * @param {Function} func - Function to debounce\r\n * @param {number} wait - Wait time in milliseconds\r\n * @returns {Function} Debounced function\r\n */\r\nexport function debounce(func, wait) {\r\n    let timeout;\r\n    return function executedFunction(...args) {\r\n        const later = () => {\r\n            clearTimeout(timeout);\r\n            func(...args);\r\n        };\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(later, wait);\r\n    };\r\n}\r\n\r\n/**\r\n * Throttle function calls\r\n * @param {Function} func - Function to throttle\r\n * @param {number} limit - Time limit in milliseconds\r\n * @returns {Function} Throttled function\r\n */\r\nexport function throttle(func, limit) {\r\n    let inThrottle;\r\n    return function executedFunction(...args) {\r\n        if (!inThrottle) {\r\n            func.apply(this, args);\r\n            inThrottle = true;\r\n            setTimeout(() => inThrottle = false, limit);\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Check if a value is empty (null, undefined, empty string, empty array, empty object)\r\n * @param {any} value - Value to check\r\n * @returns {boolean} True if empty\r\n */\r\nexport function isEmpty(value) {\r\n    if (value == null) return true;\r\n    if (typeof value === 'string') return value.trim() === '';\r\n    if (Array.isArray(value)) return value.length === 0;\r\n    if (typeof value === 'object') return Object.keys(value).length === 0;\r\n    return false;\r\n}\r\n\r\n/**\r\n * Normalize character names (remove extra spaces, normalize case)\r\n * @param {string} name - Name to normalize\r\n * @returns {string} Normalized name\r\n */\r\nexport function normalizeName(name) {\r\n    if (typeof name !== 'string') {\r\n        return '';\r\n    }\r\n\r\n    return name\r\n        .trim()\r\n        .replace(/\\s+/g, ' ') // Replace multiple spaces with single space\r\n        .split(' ')\r\n        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\r\n        .join(' ');\r\n}\r\n\r\n/**\r\n * Calculate similarity between two strings\r\n * @param {string} str1 - First string\r\n * @param {string} str2 - Second string\r\n * @returns {number} Similarity score (0-1)\r\n */\r\nexport function calculateSimilarity(str1, str2) {\r\n    if (!str1 || !str2) return 0;\r\n\r\n    const a = str1.toLowerCase();\r\n    const b = str2.toLowerCase();\r\n\r\n    if (a === b) return 1;\r\n\r\n    // Simple Levenshtein distance\r\n    const matrix = [];\r\n\r\n    for (let i = 0; i <= b.length; i++) {\r\n        matrix[i] = [i];\r\n    }\r\n\r\n    for (let j = 0; j <= a.length; j++) {\r\n        matrix[0][j] = j;\r\n    }\r\n\r\n    for (let i = 1; i <= b.length; i++) {\r\n        for (let j = 1; j <= a.length; j++) {\r\n            if (b.charAt(i - 1) === a.charAt(j - 1)) {\r\n                matrix[i][j] = matrix[i - 1][j - 1];\r\n            } else {\r\n                matrix[i][j] = Math.min(\r\n                    matrix[i - 1][j - 1] + 1, // substitution\r\n                    matrix[i][j - 1] + 1,     // insertion\r\n                    matrix[i - 1][j] + 1,      // deletion\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    const maxLength = Math.max(a.length, b.length);\r\n    return 1 - (matrix[b.length][a.length] / maxLength);\r\n}\r\n\r\n/**\r\n * Format timestamp for display\r\n * @param {number} timestamp - Unix timestamp\r\n * @returns {string} Formatted time string\r\n */\r\nexport function formatTimestamp(timestamp) {\r\n    const date = new Date(timestamp);\r\n    const now = new Date();\r\n    const diff = now - date;\r\n\r\n    const seconds = Math.floor(diff / 1000);\r\n    const minutes = Math.floor(seconds / 60);\r\n    const hours = Math.floor(minutes / 60);\r\n    const days = Math.floor(hours / 24);\r\n\r\n    if (days > 0) return `${days}d ago`;\r\n    if (hours > 0) return `${hours}h ago`;\r\n    if (minutes > 0) return `${minutes}m ago`;\r\n    return 'Just now';\r\n}\r\n\r\n/**\r\n * Truncate text with ellipsis\r\n * @param {string} text - Text to truncate\r\n * @param {number} maxLength - Maximum length\r\n * @returns {string} Truncated text\r\n */\r\nexport function truncate(text, maxLength) {\r\n    if (typeof text !== 'string') return '';\r\n    if (text.length <= maxLength) return text;\r\n    return text.substring(0, maxLength - 3) + '...';\r\n}\r\n\r\nlogger.debug('Utils module loaded');\r\n\r\nexport default {\r\n    simpleHash,\r\n    escapeHtml,\r\n    generateUID,\r\n    deepClone,\r\n    debounce,\r\n    throttle,\r\n    isEmpty,\r\n    normalizeName,\r\n    calculateSimilarity,\r\n    formatTimestamp,\r\n    truncate,\r\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nc = undefined;","\n      import API from \"!./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!./node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!./node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!./node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!./node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!./node_modules/css-loader/dist/cjs.js!./style.css\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\noptions.insert = insertFn.bind(null, \"head\");\noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!./node_modules/css-loader/dist/cjs.js!./style.css\";\n       export default content && content.locals ? content.locals : undefined;\n","/**\r\n * Message Processing Module\r\n *\r\n * Handles two-phase character detection (lightweight name scan  focused LLM processing),\r\n * batch processing with character-specific context windows, and SillyTavern event integration.\r\n */\r\n\r\nimport { createModuleLogger } from '../core/debug.js';\r\nimport { withErrorBoundary, NameTrackerError } from '../core/errors.js';\r\nimport { get_settings, set_settings, getLLMConfig, getCharacters } from '../core/settings.js';\r\nimport { stContext } from '../core/context.js';\r\nimport { NotificationManager } from '../utils/notifications.js';\r\nimport { callLLMAnalysis, buildCharacterRoster, getMaxPromptLength, calculateMessageTokens } from './llm.js';\r\nimport { createCharacter, updateCharacter, findExistingCharacter, findPotentialMatch, isIgnoredCharacter, detectMergeOpportunities } from './characters.js';\r\nimport { updateLorebookEntry } from './lorebook.js';\r\n\r\nconst debug = createModuleLogger('processing');\r\nconst notifications = new NotificationManager('Message Processing');\r\n\r\n// ============================================================================\r\n// DEBUG CONFIGURATION\r\n// ============================================================================\r\nconst DEBUG_LOGGING = true; // Set to false in production after testing\r\n\r\nfunction debugLog(message, data = null) {\r\n    if (DEBUG_LOGGING) {\r\n        console.log(`[NT-Processing] ${message}`, data || '');\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// CONFIGURATION CONSTANTS - Core processing parameters\r\n// ============================================================================\r\n// These values drive the processing pipeline. Future user-exposed settings\r\n// should reference these constant names for easy discovery and updates.\r\n\r\n// Context Management\r\nconst CONTEXT_TARGET_PERCENT = 80;      // Target percentage of context window to use\r\nconst OVERLAP_SIZE = 3;                 // Messages to overlap between batches for continuity\r\nconst MIN_CONTEXT_TARGET = 50;          // Minimum allowed context target (floor for auto-reduction)\r\n\r\n// Name Detection\r\nconst CAPITALIZED_WORD_REGEX = /\\b[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*\\b/g;  // Matches capitalized names\r\nconst QUOTED_NAME_REGEX = /\"([^\"]+)\"/g;  // Matches quoted names\r\nconst POSSESSIVE_REGEX = /(\\b[A-Z][a-z]+)'s\\b/g;  // Matches possessive forms\r\n\r\n// Processing Control\r\nconst BATCH_TIMEOUT_MS = 30000;         // Maximum time for a single batch to process\r\nconst MAX_RETRY_ATTEMPTS = 3;           // Maximum retries before halting processing\r\nconst CONTEXT_REDUCTION_STEP = 5;       // Percentage to reduce context target on each failure\r\n\r\n// Batch Size Constraints (token-based, but with message-count limits for safety)\r\nconst MIN_MESSAGES_PER_BATCH = 5;       // Never create batches smaller than this (unless last batch)\r\nconst MAX_MESSAGES_PER_BATCH = 50;      // Cap batches at this size even if tokens allow more\r\nconst TARGET_MESSAGES_PER_BATCH = 30;   // Aim for this size when possible (balance: not too small, not too large)\r\n\r\n// Error Recovery\r\nconst ENABLE_AUTO_RECOVERY = true;      // Enable automatic context reduction on failure\r\nconst PRESERVE_PROCESSING_STATE = true; // Always save character state even on errors\r\n\r\n// Processing state\r\nlet processingQueue = [];\r\nlet isProcessing = false;\r\nlet abortScan = false;\r\nconst currentProcessingState = {\r\n    totalBatches: 0,\r\n    currentBatch: 0,\r\n    failedCharacters: [],\r\n    lastError: null,\r\n    contextTarget: CONTEXT_TARGET_PERCENT,\r\n};\r\n\r\n/**\r\n * Process analysis results from LLM\r\n * @param {Array} analyzedCharacters - Array of character data from LLM\r\n * @returns {Promise<void>}\r\n */\r\nexport async function processAnalysisResults(analyzedCharacters) {\r\n    return withErrorBoundary('processAnalysisResults', async () => {\r\n        if (!analyzedCharacters || !Array.isArray(analyzedCharacters)) {\r\n            debug.log();\r\n            return;\r\n        }\r\n\r\n        debug.log();\r\n\r\n        for (const analyzedChar of analyzedCharacters) {\r\n            try {\r\n                await processCharacterData(analyzedChar);\r\n            } catch (error) {\r\n                console.error(`Error processing character ${analyzedChar.name}:`, error);\r\n                // Continue with other characters\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Process individual character data from LLM analysis\r\n * @param {Object} analyzedChar - Character data from LLM\r\n * @returns {Promise<void>}\r\n */\r\nasync function processCharacterData(analyzedChar) {\r\n    return withErrorBoundary('processCharacterData', async () => {\r\n        if (!analyzedChar.name || analyzedChar.name.trim() === '') {\r\n            debug.log();\r\n            return;\r\n        }\r\n\r\n        const characterName = analyzedChar.name.trim();\r\n\r\n        // Check if character is ignored\r\n        if (isIgnoredCharacter(characterName)) {\r\n            debug.log();\r\n            return;\r\n        }\r\n\r\n        // Check for main character detection\r\n        const isMainChar = characterName.toLowerCase().includes('{{char}}') ||\r\n                          analyzedChar.isMainCharacter === true ||\r\n                          analyzedChar.role === 'main';\r\n\r\n        // Check if character already exists\r\n        const existingChar = findExistingCharacter(characterName);\r\n\r\n        if (existingChar) {\r\n            // Update existing character\r\n            await updateCharacter(existingChar, analyzedChar, false, isMainChar);\r\n            await updateLorebookEntry(existingChar, existingChar.preferredName);\r\n            debug.log();\r\n        } else {\r\n            // Check for potential matches (similar names)\r\n            const potentialMatch = await findPotentialMatch(analyzedChar);\r\n\r\n            if (potentialMatch) {\r\n                // Update potential match and add as alias\r\n                await updateCharacter(potentialMatch, analyzedChar, true, isMainChar);\r\n                await updateLorebookEntry(potentialMatch, potentialMatch.preferredName);\r\n                debug.log();\r\n            } else {\r\n                // Create new character\r\n                const newCharacter = await createCharacter(analyzedChar, isMainChar);\r\n                await updateLorebookEntry(newCharacter, newCharacter.preferredName);\r\n                debug.log();\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n// ============================================================================\r\n// TWO-PHASE DETECTION SYSTEM\r\n// ============================================================================\r\n\r\n/**\r\n * PHASE 1: Lightweight name extraction from message batch\r\n * Uses regex patterns to find all potential character names without LLM\r\n * @param {Array} messages - Messages to scan for names\r\n * @returns {Array} Array of unique name candidates found\r\n */\r\nexport function scanForNewNames(messages) {\r\n    return withErrorBoundary('scanForNewNames', () => {\r\n        debugLog(`[PHASE 1] Starting name scan on ${messages.length} messages`);\r\n\r\n        if (!Array.isArray(messages) || messages.length === 0) {\r\n            debugLog('[PHASE 1] No messages to scan');\r\n            return [];\r\n        }\r\n\r\n        const foundNames = new Set();\r\n        const existingCharacters = getCharacters();\r\n        const existingNames = new Set();\r\n\r\n        debugLog(`[PHASE 1] Existing characters in memory: ${Object.keys(existingCharacters).length}`);\r\n\r\n        // Build set of existing character names and aliases\r\n        for (const char of Object.values(existingCharacters)) {\r\n            existingNames.add(char.preferredName.toLowerCase());\r\n            if (char.aliases && Array.isArray(char.aliases)) {\r\n                char.aliases.forEach(alias => existingNames.add(alias.toLowerCase()));\r\n            }\r\n        }\r\n\r\n        const capitalizedFound = [];\r\n        const quotedFound = [];\r\n        const possessiveFound = [];\r\n\r\n        // Scan messages for potential names\r\n        for (const msg of messages) {\r\n            if (!msg.mes || typeof msg.mes !== 'string') continue;\r\n\r\n            const text = msg.mes;\r\n\r\n            // Extract capitalized words (names)\r\n            const capitalizedMatches = text.match(CAPITALIZED_WORD_REGEX) || [];\r\n            capitalizedMatches.forEach(match => {\r\n                const normalized = match.toLowerCase();\r\n                if (!existingNames.has(normalized) && match.length > 1) {\r\n                    foundNames.add(match);\r\n                    capitalizedFound.push(match);\r\n                }\r\n            });\r\n\r\n            // Extract quoted names\r\n            const quotedMatches = text.match(QUOTED_NAME_REGEX) || [];\r\n            quotedMatches.forEach(match => {\r\n                const name = match.slice(1, -1); // Remove quotes\r\n                const normalized = name.toLowerCase();\r\n                if (!existingNames.has(normalized) && name.length > 1) {\r\n                    foundNames.add(name);\r\n                    quotedFound.push(name);\r\n                }\r\n            });\r\n\r\n            // Extract possessive forms\r\n            const possessiveMatches = text.match(POSSESSIVE_REGEX) || [];\r\n            possessiveMatches.forEach(match => {\r\n                const name = match.replace(/'s$/, '');\r\n                const normalized = name.toLowerCase();\r\n                if (!existingNames.has(normalized)) {\r\n                    foundNames.add(name);\r\n                    possessiveFound.push(name);\r\n                }\r\n            });\r\n        }\r\n\r\n        debugLog(`[PHASE 1] Capitalized names found: ${capitalizedFound.join(', ')}`);\r\n        debugLog(`[PHASE 1] Quoted names found: ${quotedFound.join(', ')}`);\r\n        debugLog(`[PHASE 1] Possessive forms found: ${possessiveFound.join(', ')}`);\r\n        debugLog(`[PHASE 1] Total unique names to process: ${foundNames.size}`);\r\n\r\n        return Array.from(foundNames);\r\n    }, []);\r\n}\r\n\r\n/**\r\n * PHASE 2: Focused LLM analysis for new characters and existing character updates\r\n * Processes new names individually and updates existing characters that were mentioned\r\n * @param {Array} newNames - New character names to analyze\r\n * @param {Array} messages - Message context for character details\r\n * @param {Array} existingMentions - Names of existing characters mentioned in messages\r\n * @returns {Promise<Object>} Results of processing with success/error details\r\n */\r\nexport async function processPhaseTwoAnalysis(newNames, messages, existingMentions = []) {\r\n    return withErrorBoundary('processPhaseTwoAnalysis', async () => {\r\n        debugLog('[PHASE 2] Starting focused LLM analysis');\r\n        debugLog(`[PHASE 2] New characters: ${newNames.length}, Existing mentions: ${existingMentions.length}`);\r\n        debugLog(`[PHASE 2] Current context target: ${currentProcessingState.contextTarget}%`);\r\n\r\n        const results = {\r\n            newCharactersCreated: [],\r\n            existingCharactersUpdated: [],\r\n            failedCharacters: [],\r\n            mergesDetected: [],\r\n        };\r\n\r\n        if (!Array.isArray(messages) || messages.length === 0) {\r\n            debugLog('[PHASE 2] No messages provided, returning empty results');\r\n            return results;\r\n        }\r\n\r\n        try {\r\n            // Process new characters\r\n            if (newNames && newNames.length > 0) {\r\n                debugLog(`[PHASE 2] Processing ${newNames.length} new characters`);\r\n\r\n                for (const newName of newNames) {\r\n                    if (abortScan) {\r\n                        debugLog(`[PHASE 2] Processing aborted by user at character: ${newName}`);\r\n                        break;\r\n                    }\r\n\r\n                    try {\r\n                        await processNewCharacter(newName, messages, results);\r\n                    } catch (error) {\r\n                        debugLog(`[PHASE 2] Failed to process new character ${newName}: ${error.message}`);\r\n                        results.failedCharacters.push({ name: newName, error: error.message });\r\n                        currentProcessingState.failedCharacters.push(newName);\r\n                        currentProcessingState.lastError = error;\r\n\r\n                        // If ENABLE_AUTO_RECOVERY, attempt to reduce context and retry\r\n                        if (ENABLE_AUTO_RECOVERY && currentProcessingState.contextTarget > MIN_CONTEXT_TARGET) {\r\n                            currentProcessingState.contextTarget -= CONTEXT_REDUCTION_STEP;\r\n                            debugLog(`[PHASE 2] Auto-reducing context target to ${currentProcessingState.contextTarget}%`);\r\n                        } else if (results.failedCharacters.length >= MAX_RETRY_ATTEMPTS) {\r\n                            // Halt processing after max retries\r\n                            throw new NameTrackerError(\r\n                                `Processing halted: Maximum retries exceeded. Last error: ${error.message}`,\r\n                                'PROCESSING_MAX_RETRIES',\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Update existing characters mentioned in messages\r\n            if (existingMentions && existingMentions.length > 0) {\r\n                debug.log(`Phase 2: Updating ${existingMentions.length} existing characters`);\r\n\r\n                for (const charName of existingMentions) {\r\n                    if (abortScan) break;\r\n\r\n                    try {\r\n                        const existingChar = findExistingCharacter(charName);\r\n                        if (existingChar) {\r\n                            await processExistingCharacter(existingChar, messages, results);\r\n                        }\r\n                    } catch (error) {\r\n                        debug.log(`Failed to update character ${charName}: ${error.message}`);\r\n                        results.failedCharacters.push({ name: charName, error: error.message });\r\n                    }\r\n                }\r\n            }\r\n\r\n        } catch (error) {\r\n            debug.log(`Phase 2 analysis error: ${error.message}`);\r\n            throw error;\r\n        }\r\n\r\n        return results;\r\n    }, { newCharactersCreated: [], existingCharactersUpdated: [], failedCharacters: [], mergesDetected: [] });\r\n}\r\n\r\n/**\r\n * Process a new character: LLM analysis  create entry  check for merges\r\n * @private\r\n */\r\nasync function processNewCharacter(name, messages, results) {\r\n    debugLog(`[P2-NewChar] Processing: ${name}`);\r\n\r\n    // Build context with 3-message overlap for this character\r\n    const characterContext = buildCharacterContext(name, messages, OVERLAP_SIZE);\r\n    debugLog(`[P2-NewChar] Context window size: ${characterContext ? characterContext.length : 0} chars`);\r\n\r\n    if (!characterContext || characterContext.length === 0) {\r\n        debugLog(`[P2-NewChar] FAILED: No context for ${name}`);\r\n        throw new NameTrackerError(`No context found for character: ${name}`, 'NO_CONTEXT');\r\n    }\r\n\r\n    // Analyze the character with LLM\r\n    debugLog(`[P2-NewChar] Calling LLM for ${name}`);\r\n    const characterData = await callLLMAnalysis([{ mes: characterContext }], [name], currentProcessingState.contextTarget);\r\n\r\n    if (!characterData || characterData.length === 0) {\r\n        debugLog(`[P2-NewChar] FAILED: LLM returned no data for ${name}`);\r\n        throw new NameTrackerError(`LLM returned no data for character: ${name}`, 'LLM_EMPTY_RESPONSE');\r\n    }\r\n\r\n    debugLog(`[P2-NewChar] LLM returned data: ${JSON.stringify(characterData[0]).substring(0, 200)}...`);\r\n\r\n    // Check for merge opportunities before creating\r\n    const potentialMerges = detectMergeOpportunities(name);\r\n    if (potentialMerges && potentialMerges.length > 0) {\r\n        debugLog(`[P2-NewChar] Merge opportunities: ${potentialMerges.map(m => m.targetName).join(', ')}`);\r\n        results.mergesDetected.push({ source: name, targets: potentialMerges });\r\n    }\r\n\r\n    // Create the character\r\n    const newCharacter = await createCharacter(characterData[0], false);\r\n    await updateLorebookEntry(newCharacter, newCharacter.preferredName);\r\n\r\n    results.newCharactersCreated.push(newCharacter.preferredName);\r\n    debugLog(`[P2-NewChar] Successfully created: ${newCharacter.preferredName}`);\r\n}\r\n\r\n/**\r\n * Process existing character: build context from last processed message  update entry\r\n * @private\r\n */\r\nasync function processExistingCharacter(existingChar, messages, results) {\r\n    debug.log(`Updating existing character: ${existingChar.preferredName}`);\r\n\r\n    // Get character's last processed message ID (from state tracking)\r\n    const lastProcessedId = existingChar.lastMessageProcessed || -1;\r\n\r\n    // Build context starting from overlap before last processed message\r\n    const characterContext = buildCharacterContextFromPoint(\r\n        existingChar.preferredName,\r\n        messages,\r\n        lastProcessedId,\r\n        OVERLAP_SIZE,\r\n    );\r\n\r\n    if (!characterContext || characterContext.length === 0) {\r\n        debug.log(`No new context for character ${existingChar.preferredName} since last processing`);\r\n        return;\r\n    }\r\n\r\n    // Analyze with LLM\r\n    const updates = await callLLMAnalysis([{ mes: characterContext }], [existingChar.preferredName], currentProcessingState.contextTarget);\r\n\r\n    if (updates && updates.length > 0) {\r\n        await updateCharacter(existingChar, updates[0], false, existingChar.isMainChar);\r\n        await updateLorebookEntry(existingChar, existingChar.preferredName);\r\n\r\n        results.existingCharactersUpdated.push(existingChar.preferredName);\r\n        debug.log(`Updated character: ${existingChar.preferredName}`);\r\n    }\r\n}\r\n\r\n/**\r\n * Build character-specific context from all messages mentioning the character\r\n * @private\r\n */\r\nfunction buildCharacterContext(characterName, messages, overlapSize) {\r\n    const contextMessages = [];\r\n\r\n    for (const msg of messages) {\r\n        if (!msg.mes) continue;\r\n\r\n        // Check if this message mentions the character\r\n        if (msg.mes.includes(characterName) || msg.mes.includes(characterName.split(' ')[0])) {\r\n            contextMessages.push(msg);\r\n        }\r\n    }\r\n\r\n    if (contextMessages.length === 0) return '';\r\n\r\n    // Add overlap messages before and after mentions for context\r\n    const contextWindow = [];\r\n    const indices = contextMessages.map(m => messages.indexOf(m));\r\n    const minIdx = Math.max(0, Math.min(...indices) - overlapSize);\r\n    const maxIdx = Math.min(messages.length - 1, Math.max(...indices) + overlapSize);\r\n\r\n    for (let i = minIdx; i <= maxIdx; i++) {\r\n        if (messages[i]) {\r\n            contextWindow.push(messages[i].mes);\r\n        }\r\n    }\r\n\r\n    return contextWindow.join('\\n\\n');\r\n}\r\n\r\n/**\r\n * Build context starting from a specific message point (for continuing character updates)\r\n * @private\r\n */\r\nfunction buildCharacterContextFromPoint(characterName, messages, lastProcessedId, overlapSize) {\r\n    const allText = [];\r\n    let startIdx = 0;\r\n\r\n    // Find where we left off\r\n    if (lastProcessedId >= 0) {\r\n        const lastIdx = messages.findIndex(m => m.id === lastProcessedId);\r\n        startIdx = Math.max(0, lastIdx - overlapSize);\r\n    }\r\n\r\n    for (let i = startIdx; i < messages.length; i++) {\r\n        if (messages[i] && messages[i].mes) {\r\n            allText.push(messages[i].mes);\r\n        }\r\n    }\r\n\r\n    return allText.length > 0 ? allText.join('\\n\\n') : '';\r\n}\r\n\r\n/**\r\n * Harvest and analyze messages\r\n * @param {number} messageCount - Number of recent messages to analyze\r\n * @param {boolean} showProgress - Whether to show progress notifications\r\n * @returns {Promise<void>}\r\n */\r\nexport async function harvestMessages(messageCount, showProgress = true) {\r\n    return withErrorBoundary('harvestMessages', async () => {\r\n        if (!get_settings('enabled', true)) {\r\n            debug.log();\r\n            return;\r\n        }\r\n\r\n        // Check API connection for SillyTavern mode\r\n        const llmConfig = getLLMConfig();\r\n        if (llmConfig.source === 'sillytavern') {\r\n            const context = stContext.getContext();\r\n            if (!context.onlineStatus) {\r\n                notifications.warning('Please connect to an API (OpenAI, Claude, etc.) before analyzing messages');\r\n                return;\r\n            }\r\n        }\r\n\r\n        const context = stContext.getContext();\r\n        if (!context.chat || context.chat.length === 0) {\r\n            debug.log();\r\n            notifications.info('No messages in chat to analyze');\r\n            return;\r\n        }\r\n\r\n        // Get the messages to analyze - count forward and check token limits\r\n        const endIdx = context.chat.length;\r\n        const startIdx = Math.max(0, endIdx - messageCount);\r\n        const messagesToAnalyze = context.chat.slice(startIdx, endIdx);\r\n\r\n        debugLog(`[Batching] Message selection: startIdx=${startIdx}, endIdx=${endIdx}, requesting ${messageCount} messages, got ${messagesToAnalyze.length} messages`);\r\n\r\n        // Check if messages fit in context window\r\n        const maxPromptResult = await getMaxPromptLength();\r\n        const maxPromptTokens = maxPromptResult.maxPrompt;\r\n        const availableTokens = maxPromptTokens - 1000; // Reserve for system prompt and response\r\n\r\n        debugLog(`[Batching] Token budget: maxPromptTokens=${maxPromptTokens}, reserved=1000, availableTokens=${availableTokens}`);\r\n        debugLog(`[Batching] Context target: ${currentProcessingState.contextTarget}%`);\r\n\r\n        // Calculate actual token count for the requested messages\r\n        const messageTokens = await calculateMessageTokens(messagesToAnalyze);\r\n\r\n        debugLog(`[Batching] Total tokens for ${messagesToAnalyze.length} messages: ${messageTokens} tokens`);\r\n\r\n        // If too large, split into batches\r\n        if (messageTokens > availableTokens) {\r\n            debugLog(`[Batching] Messages exceed token limit (${messageTokens} > ${availableTokens}), creating batches`);\r\n\r\n            // Calculate optimal batch size based on tokens AND message count constraints\r\n            const batches = [];\r\n            let currentBatch = [];\r\n            let currentTokens = 0;\r\n            const batchDetails = []; // Track batch composition for logging\r\n\r\n            // Build batches by adding messages until token limit OR message count limit\r\n            for (const msg of messagesToAnalyze) {\r\n                const msgTokens = await calculateMessageTokens([msg]);\r\n\r\n                // Check if batch would exceed token limit OR message count limit\r\n                const wouldExceedTokens = currentTokens + msgTokens > availableTokens;\r\n                const wouldExceedMessageCount = currentBatch.length >= MAX_MESSAGES_PER_BATCH;\r\n\r\n                if ((wouldExceedTokens || wouldExceedMessageCount) && currentBatch.length > 0) {\r\n                    // Current batch is full, start new one\r\n                    const reason = wouldExceedTokens ? 'token limit' : 'message count limit';\r\n                    debugLog(`[Batching] Batch ${batches.length + 1} complete: ${currentBatch.length} messages, ${currentTokens} tokens (split by ${reason})`);\r\n                    batches.push(currentBatch);\r\n                    batchDetails.push({ size: currentBatch.length, tokens: currentTokens, reason: reason });\r\n                    currentBatch = [msg];\r\n                    currentTokens = msgTokens;\r\n                } else {\r\n                    // Add to current batch\r\n                    currentBatch.push(msg);\r\n                    currentTokens += msgTokens;\r\n                }\r\n            }\r\n\r\n            // Add final batch\r\n            if (currentBatch.length > 0) {\r\n                batches.push(currentBatch);\r\n                batchDetails.push({ size: currentBatch.length, tokens: currentTokens, reason: 'final batch' });\r\n                debugLog(`[Batching] Final batch ${batches.length}: ${currentBatch.length} messages, ${currentTokens} tokens`);\r\n            }\r\n\r\n            // Log comprehensive batch summary\r\n            const batchSummary = batchDetails.map((b, i) => `Batch ${i + 1}: ${b.size}msg/${b.tokens}tok (${b.reason})`).join(' | ');\r\n            debugLog(`[Batching] Created ${batches.length} total batches: ${batchSummary}`);\r\n            debugLog(`[Batching] Constraints applied: MIN=${MIN_MESSAGES_PER_BATCH}, TARGET=${TARGET_MESSAGES_PER_BATCH}, MAX=${MAX_MESSAGES_PER_BATCH}, TokenLimit=${availableTokens}`);\r\n\r\n            // Reset abort flag\r\n            abortScan = false;\r\n\r\n            // Calculate average batch size for user notification\r\n            const avgBatchSize = Math.round(messagesToAnalyze.length / batches.length);\r\n            const notification = `Analyzing ${messagesToAnalyze.length} messages in ${batches.length} batches (~${avgBatchSize} messages each). This may take a while. Continue?`;\r\n\r\n            if (showProgress) {\r\n                // Ask user before proceeding with large analysis\r\n                const shouldProceed = confirm(notification);\r\n                if (!shouldProceed) {\r\n                    debugLog('[Batching] User cancelled batch processing');\r\n                    abortScan = true;\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // Show progress bar\r\n            showProgressBar(0, batches.length, 'Starting analysis...');\r\n\r\n            let successfulBatches = 0;\r\n            let failedBatches = 0;\r\n            const uniqueCharacters = new Set();\r\n\r\n            debugLog(`[Batching] Starting batch processing loop: ${batches.length} batches`);\r\n\r\n            // Process each batch\r\n            for (let i = 0; i < batches.length; i++) {\r\n                // Check if user aborted\r\n                if (abortScan) {\r\n                    debugLog(`[BatchProcessing] User aborted at batch ${i + 1}/${batches.length}`);\r\n                    hideProgressBar();\r\n                    notifications.warning('Analysis aborted');\r\n                    return;\r\n                }\r\n\r\n                const batch = batches[i];\r\n\r\n                // Calculate actual message range for this batch\r\n                const batchStartMsg = batches.slice(0, i).reduce((sum, b) => sum + b.length, 0);\r\n                const batchStart = startIdx + batchStartMsg;\r\n                const batchEnd = batchStart + batch.length;\r\n\r\n                debugLog(`[BatchProcessing] Processing batch ${i + 1}/${batches.length}: messages ${batchStart}-${batchEnd - 1} (${batch.length} messages)`);\r\n\r\n                try {\r\n                    showProgressBar(i + 1, batches.length, `Analyzing messages ${batchStart + 1}-${batchEnd}...`);\r\n\r\n                    // Build roster of characters found so far\r\n                    const characterRoster = buildCharacterRoster();\r\n\r\n                    // Call LLM for analysis\r\n                    const analysis = await callLLMAnalysis(batch, characterRoster);\r\n\r\n                    // Process the analysis\r\n                    if (analysis.characters && Array.isArray(analysis.characters)) {\r\n                        await processAnalysisResults(analysis.characters);\r\n                        analysis.characters.forEach(char => uniqueCharacters.add(char.name));\r\n                    }\r\n\r\n                    successfulBatches++;\r\n\r\n                    // Small delay between batches to avoid rate limiting\r\n                    if (i < batches.length - 1) {\r\n                        await new Promise(resolve => setTimeout(resolve, 500));\r\n                    }\r\n\r\n                } catch (error) {\r\n                    debugLog(`[BatchProcessing] ERROR in batch ${i + 1}: ${error.message}`);\r\n                    debugLog(`[BatchProcessing] Context: messages ${batchStart}-${batchEnd - 1}, batch size ${batch.length}, token count calc error`);\r\n                    console.error(`Error processing batch ${i + 1}:`, error);\r\n                    failedBatches++;\r\n\r\n                    // Ask user if they want to continue\r\n                    const continueOnError = confirm(`Batch ${i + 1} failed.\r\n\r\nError: ${error.message}\r\n\r\nContinue with remaining batches?`);\r\n                    if (!continueOnError) {\r\n                        debugLog(`[BatchProcessing] User chose not to continue after error on batch ${i + 1}/${batches.length}`);\r\n                        break;\r\n                    } else {\r\n                        debugLog(`[BatchProcessing] User chose to continue despite error on batch ${i + 1}/${batches.length}`);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Hide progress bar\r\n            hideProgressBar();\r\n\r\n            // Show summary\r\n            const summary = `Analysis complete!\r\n\r\nBatches processed: ${successfulBatches}/${batches.length}\r\nUnique characters found: ${uniqueCharacters.size}\r\nFailed batches: ${failedBatches}`;\r\n\r\n            debugLog(`[BatchProcessing] Batch analysis complete: ${successfulBatches}/${batches.length} successful, ${failedBatches} failed, ${uniqueCharacters.size} characters found`);\r\n\r\n            if (failedBatches > 0) {\r\n                notifications.warning(summary, 'Batch Analysis', { timeOut: 8000 });\r\n            } else {\r\n                notifications.success(summary, 'Batch Analysis', { timeOut: 8000 });\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Messages fit in one batch - process normally\r\n        if (showProgress) {\r\n            notifications.info(`Analyzing ${messagesToAnalyze.length} messages for character information...`);\r\n        }\r\n\r\n        try {\r\n            // Build roster of characters found so far\r\n            const characterRoster = buildCharacterRoster();\r\n\r\n            // Call LLM for analysis with character context\r\n            const analysis = await callLLMAnalysis(messagesToAnalyze, characterRoster);\r\n\r\n            debug.log();\r\n\r\n            // Process the analysis\r\n            if (analysis.characters && Array.isArray(analysis.characters)) {\r\n                await processAnalysisResults(analysis.characters);\r\n\r\n                if (showProgress) {\r\n                    notifications.success(`Found ${analysis.characters.length} character(s) in messages`);\r\n                }\r\n            } else {\r\n                debug.log();\r\n            }\r\n\r\n        } catch (error) {\r\n            console.error('Error during harvest:', error);\r\n            notifications.error(`Analysis failed: ${error.message}`);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Handle new message event\r\n * @param {number} messageId - ID of the new message\r\n * @returns {Promise<void>}\r\n */\r\nexport async function onMessageReceived(messageId) {\r\n    return withErrorBoundary('onMessageReceived', async () => {\r\n        if (!get_settings('enabled', true) || !get_settings('autoAnalyze', true)) {\r\n            return;\r\n        }\r\n\r\n        const context = stContext.getContext();\r\n        const chat = context.chat;\r\n\r\n        if (!chat || chat.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Get the current message index\r\n        const currentMessageIndex = chat.length - 1;\r\n\r\n        // Check if this message was already scanned\r\n        const lastScannedId = get_settings('lastScannedMessageId', -1);\r\n        if (currentMessageIndex <= lastScannedId) {\r\n            debug.log();\r\n            return;\r\n        }\r\n\r\n        // Detect if messages were deleted (current index jumped backwards)\r\n        if (lastScannedId >= 0 && currentMessageIndex < lastScannedId) {\r\n            debug.log();\r\n\r\n            // Prompt user for rescan decision\r\n            const shouldRescan = await showRescanModal(currentMessageIndex, lastScannedId);\r\n\r\n            if (shouldRescan.rescan) {\r\n                set_settings('lastScannedMessageId', shouldRescan.fromMessage - 1);\r\n\r\n                // Queue a full scan from the specified message\r\n                addToQueue(async () => {\r\n                    await harvestMessages(currentMessageIndex - shouldRescan.fromMessage + 1, true);\r\n                });\r\n\r\n                return;\r\n            } else {\r\n                // Reset to current position without scanning\r\n                set_settings('lastScannedMessageId', currentMessageIndex);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Check if we've reached the next scan milestone\r\n        const messageFreq = get_settings('messageFrequency', 10);\r\n        const messagesSinceLastScan = currentMessageIndex - lastScannedId;\r\n\r\n        if (messagesSinceLastScan >= messageFreq) {\r\n            debug.log();\r\n\r\n            // Queue harvest\r\n            addToQueue(async () => {\r\n                await harvestMessages(messageFreq, true);\r\n                // Update last scanned message ID after successful harvest\r\n                set_settings('lastScannedMessageId', currentMessageIndex);\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Show rescan modal when message deletion is detected\r\n * @param {number} currentMessageIndex - Current message index\r\n * @param {number} lastScannedId - Last scanned message ID\r\n * @returns {Promise<Object>} Rescan decision\r\n */\r\nasync function showRescanModal(currentMessageIndex, lastScannedId) {\r\n    return new Promise((resolve) => {\r\n        const modal = $(`\r\n            <div class=\"name-tracker-rescan-modal\" style=\"position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--SmartThemeBodyColor); border: 2px solid var(--SmartThemeBorderColor); padding: 20px; border-radius: 10px; z-index: 9999; max-width: 500px;\">\r\n                <h3>Message History Changed</h3>\r\n                <p>Messages have been deleted or edited. Would you like to rescan the chat?</p>\r\n                <p>Current last scanned message: ${lastScannedId}<br>\r\n                Current message index: ${currentMessageIndex}</p>\r\n                <div style=\"margin-top: 15px;\">\r\n                    <label>Rescan from message: <input type=\"number\" id=\"rescan-from\" value=\"0\" min=\"0\" max=\"${currentMessageIndex}\" style=\"width: 80px; margin-left: 10px;\"></label>\r\n                </div>\r\n                <div style=\"margin-top: 15px; text-align: right;\">\r\n                    <button id=\"rescan-yes\" class=\"menu_button\">Rescan</button>\r\n                    <button id=\"rescan-no\" class=\"menu_button\">Skip</button>\r\n                </div>\r\n            </div>\r\n        `);\r\n\r\n        $('body').append(modal);\r\n\r\n        modal.find('#rescan-yes').on('click', () => {\r\n            const fromMessage = parseInt(modal.find('#rescan-from').val()) || 0;\r\n            modal.remove();\r\n            resolve({ rescan: true, fromMessage });\r\n        });\r\n\r\n        modal.find('#rescan-no').on('click', () => {\r\n            modal.remove();\r\n            resolve({ rescan: false });\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * Show progress bar for batch scanning\r\n * @param {number} current - Current batch number (1-indexed)\r\n * @param {number} total - Total number of batches\r\n * @param {string} status - Status message\r\n */\r\nfunction showProgressBar(current, total, status = '') {\r\n    const progressBarId = 'name_tracker_progress';\r\n    const $existing = $(`.${progressBarId}`);\r\n\r\n    if ($existing.length > 0) {\r\n        // Update existing progress bar\r\n        if (status) $existing.find('.title').text(status);\r\n        $existing.find('.progress').text(current);\r\n        $existing.find('.total').text(total);\r\n        $existing.find('progress').val(current).attr('max', total);\r\n        return;\r\n    }\r\n\r\n    // Create new progress bar\r\n    const bar = $(`\r\n        <div class=\"${progressBarId} name_tracker_progress_bar flex-container justifyspacebetween alignitemscenter\" style=\"\r\n            padding: 10px;\r\n            margin: 5px 0;\r\n            background: var(--SmartThemeBlurTintColor);\r\n            border: 1px solid var(--SmartThemeBorderColor);\r\n            border-radius: 5px;\r\n        \">\r\n            <div class=\"title\" style=\"flex: 1; font-weight: bold;\">${status || 'Name Tracker Scan'}</div>\r\n            <div style=\"margin: 0 10px;\">(<span class=\"progress\">${current}</span> / <span class=\"total\">${total}</span>)</div>\r\n            <progress value=\"${current}\" max=\"${total}\" style=\"flex: 2; margin: 0 10px;\"></progress>\r\n            <button class=\"menu_button fa-solid fa-stop\" title=\"Abort scan\" style=\"padding: 5px 10px;\"></button>\r\n        </div>\r\n    `);\r\n\r\n    // Add click event to abort the scan\r\n    bar.find('button').on('click', function() {\r\n        abortScan = true;\r\n        hideProgressBar();\r\n        notifications.warning('Scan aborted by user');\r\n    });\r\n\r\n    // Append to the main chat area (#sheld)\r\n    $('#sheld').append(bar);\r\n}\r\n\r\n/**\r\n * Hide and remove progress bar\r\n */\r\nfunction hideProgressBar() {\r\n    const progressBarId = 'name_tracker_progress';\r\n    const $existing = $(`.${progressBarId}`);\r\n    if ($existing.length > 0) {\r\n        $existing.fadeOut(300, function() {\r\n            $(this).remove();\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Scan entire chat in batches from oldest to newest\r\n * @returns {Promise<void>}\r\n */\r\nexport async function scanEntireChat() {\r\n    return withErrorBoundary('scanEntireChat', async () => {\r\n        const context = stContext.getContext();\r\n\r\n        if (!context.chat || context.chat.length === 0) {\r\n            notifications.warning('No chat messages to scan');\r\n            return;\r\n        }\r\n\r\n        // Check API connection for SillyTavern mode\r\n        const llmConfig = getLLMConfig();\r\n        if (llmConfig.source === 'sillytavern') {\r\n            if (!context.onlineStatus) {\r\n                notifications.warning('Please connect to an API (OpenAI, Claude, etc.) before analyzing messages');\r\n                return;\r\n            }\r\n        }\r\n\r\n        const totalMessages = context.chat.length;\r\n\r\n        // Calculate optimal batch size based on context window\r\n        const maxPromptResult = await getMaxPromptLength();\r\n        const maxPromptTokens = maxPromptResult.maxPrompt;\r\n        const availableTokens = maxPromptTokens - 1000;\r\n\r\n        // Build batches dynamically based on token counts\r\n        const batches = [];\r\n        let currentBatch = [];\r\n        let currentTokens = 0;\r\n\r\n        for (let i = 0; i < totalMessages; i++) {\r\n            const msg = context.chat[i];\r\n            const msgTokens = await calculateMessageTokens([msg]);\r\n\r\n            if (currentTokens + msgTokens > availableTokens && currentBatch.length > 0) {\r\n                // Current batch is full, save it and start new one\r\n                batches.push(currentBatch);\r\n                currentBatch = [msg];\r\n                currentTokens = msgTokens;\r\n            } else {\r\n                // Add to current batch\r\n                currentBatch.push(msg);\r\n                currentTokens += msgTokens;\r\n            }\r\n        }\r\n\r\n        // Add final batch\r\n        if (currentBatch.length > 0) {\r\n            batches.push(currentBatch);\r\n        }\r\n\r\n        const numBatches = batches.length;\r\n\r\n        const confirmed = confirm(`This will analyze all ${totalMessages} messages in ${numBatches} batches. This may take a while. Continue?`);\r\n\r\n        if (!confirmed) {\r\n            return;\r\n        }\r\n\r\n        // Reset abort flag\r\n        abortScan = false;\r\n\r\n        // Show progress bar\r\n        showProgressBar(0, numBatches, 'Starting batch scan...');\r\n\r\n        let successfulBatches = 0;\r\n        let failedBatches = 0;\r\n        const uniqueCharacters = new Set(); // Track unique character names\r\n\r\n        // Process from oldest to newest\r\n        for (let i = 0; i < numBatches; i++) {\r\n            // Check if user aborted\r\n            if (abortScan) {\r\n                debug.log();\r\n                break;\r\n            }\r\n\r\n            const batchMessages = batches[i];\r\n\r\n            // Calculate message range for progress display\r\n            const startIdx = batches.slice(0, i).reduce((sum, b) => sum + b.length, 0);\r\n            const endIdx = startIdx + batchMessages.length;\r\n\r\n            try {\r\n                showProgressBar(i + 1, numBatches, `Processing messages ${startIdx + 1}-${endIdx}...`);\r\n\r\n                // Build roster of characters found so far\r\n                const characterRoster = buildCharacterRoster();\r\n\r\n                // Call LLM for analysis with character context\r\n                const analysis = await callLLMAnalysis(batchMessages, characterRoster);\r\n\r\n                // Process the analysis\r\n                if (analysis.characters && Array.isArray(analysis.characters)) {\r\n                    await processAnalysisResults(analysis.characters);\r\n                    // Track unique characters\r\n                    analysis.characters.forEach(char => uniqueCharacters.add(char.name));\r\n                }\r\n\r\n                successfulBatches++;\r\n\r\n                // Small delay between batches\r\n                if (i < numBatches - 1) {\r\n                    await new Promise(resolve => setTimeout(resolve, 1000));\r\n                }\r\n\r\n            } catch (error) {\r\n                console.error(`Error processing batch ${i + 1}:`, error);\r\n                failedBatches++;\r\n\r\n                // Auto-retry logic could be added here\r\n                const continueOnError = confirm(`Batch ${i + 1} failed.\r\n\r\nError: ${error.message}\r\n\r\nContinue with remaining batches?`);\r\n                if (!continueOnError) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Hide progress bar\r\n        hideProgressBar();\r\n\r\n        // Update scan completion status\r\n        set_settings('lastScannedMessageId', totalMessages - 1);\r\n\r\n        // Show summary\r\n        const summary = `Full chat scan complete!\\n\\nMessages: ${totalMessages}\\nBatches: ${successfulBatches}/${numBatches}\\nCharacters found: ${uniqueCharacters.size}\\nFailed: ${failedBatches}`;\r\n\r\n        // Ensure summary is a string (defense against undefined values)\r\n        const safeSummary = String(summary || 'Scan completed');\r\n\r\n        if (failedBatches > 0) {\r\n            notifications.warning(safeSummary, 'Scan Complete', { timeOut: 10000 });\r\n        } else {\r\n            notifications.success(safeSummary, 'Scan Complete', { timeOut: 10000 });\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Add task to processing queue\r\n * @param {Function} task - Async function to execute\r\n * @returns {Promise<void>}\r\n */\r\nexport async function addToQueue(task) {\r\n    return withErrorBoundary('addToQueue', async () => {\r\n        processingQueue.push(task);\r\n\r\n        if (!isProcessing) {\r\n            await processQueue();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Process queued tasks\r\n * @returns {Promise<void>}\r\n */\r\nexport async function processQueue() {\r\n    return withErrorBoundary('processQueue', async () => {\r\n        if (isProcessing || processingQueue.length === 0) {\r\n            return;\r\n        }\r\n\r\n        isProcessing = true;\r\n\r\n        while (processingQueue.length > 0) {\r\n            const task = processingQueue.shift();\r\n            try {\r\n                await task();\r\n            } catch (error) {\r\n                console.error('Error processing queue task:', error);\r\n            }\r\n        }\r\n\r\n        isProcessing = false;\r\n    });\r\n}\r\n\r\n/**\r\n * Handle chat changed event\r\n * @returns {Promise<void>}\r\n */\r\nexport async function onChatChanged() {\r\n    return withErrorBoundary('onChatChanged', async () => {\r\n        debug.log();\r\n\r\n        // Clear processing state\r\n        processingQueue = [];\r\n        isProcessing = false;\r\n        abortScan = false;\r\n\r\n        // Reset scan state\r\n        set_settings('lastScannedMessageId', -1);\r\n        set_settings('messageCounter', 0);\r\n\r\n        debug.log();\r\n    });\r\n}\r\n\r\n/**\r\n * Clear the processing queue\r\n */\r\nexport function clearProcessingQueue() {\r\n    processingQueue = [];\r\n    isProcessing = false;\r\n    debug.log();\r\n}\r\n\r\n/**\r\n * Get processing status\r\n * @returns {Object} Processing status information\r\n */\r\nexport function getProcessingStatus() {\r\n    return {\r\n        isProcessing,\r\n        queueLength: processingQueue.length,\r\n        abortScan,\r\n    };\r\n}\r\n\r\n/**\r\n * Abort current scan operation\r\n */\r\nexport function abortCurrentScan() {\r\n    abortScan = true;\r\n    hideProgressBar();\r\n    debug.log();\r\n}\r\n","/**\r\n * UI Management Module\r\n *\r\n * Handles user interface components, settings panel management, character lists,\r\n * modal dialogs, and progress indicators for the Name Tracker extension.\r\n */\r\n\r\nimport { createModuleLogger } from '../core/debug.js';\r\nimport { withErrorBoundary, NameTrackerError } from '../core/errors.js';\r\nimport {\r\n    get_settings,\r\n    getCharacters, getCharacter, setCharacter, removeCharacter,\r\n    getSetting, setSetting,\r\n} from '../core/settings.js';\r\nimport { stContext } from '../core/context.js';\r\nimport { escapeHtml } from '../utils/helpers.js';\r\nimport { NotificationManager } from '../utils/notifications.js';\r\nimport { mergeCharacters, toggleIgnoreCharacter, createNewCharacter, purgeAllCharacters, hasUnresolvedRelationships } from './characters.js';\r\nimport { loadOllamaModels } from './llm.js';\r\nimport { harvestMessages, scanEntireChat, clearProcessingQueue } from './processing.js';\r\nimport { viewInLorebook } from './lorebook.js';\r\n\r\nconst debug = createModuleLogger('ui');\r\nconst notifications = new NotificationManager('UI Management');\r\n\r\n/**\r\n * Update character list display in settings\r\n * @returns {void}\r\n */\r\nexport function updateCharacterList() {\r\n    return withErrorBoundary('updateCharacterList', () => {\r\n        const $container = $('#name_tracker_character_list');\r\n        if ($container.length === 0) {\r\n            debug.log();\r\n            return;\r\n        }\r\n\r\n        const characters = getCharacters();\r\n        const characterNames = Object.keys(characters);\r\n\r\n        if (characterNames.length === 0) {\r\n            $container.html(`\r\n                <div class=\"name_tracker_no_characters\">\r\n                    <p style=\"text-align: center; color: var(--SmartThemeQuoteColor);\">\r\n                        No characters tracked yet. Start a conversation and character information will be extracted automatically!\r\n                    </p>\r\n                </div>\r\n            `);\r\n            return;\r\n        }\r\n\r\n        // Sort characters: Main characters first, then alphabetically\r\n        const sortedCharacters = Object.values(characters).sort((a, b) => {\r\n            if (a.isMainChar && !b.isMainChar) return -1;\r\n            if (!a.isMainChar && b.isMainChar) return 1;\r\n            return a.preferredName.localeCompare(b.preferredName);\r\n        });\r\n\r\n        let html = '<div class=\"name_tracker_character_list\">';\r\n\r\n        for (const character of sortedCharacters) {\r\n            const charIcon = character.isMainChar ? '<i class=\"fa-solid fa-user\"></i>' : '';\r\n            const ignoreIcon = character.ignored ? '<span class=\"char-ignored-badge\">IGNORED</span>' : '';\r\n            const reviewBadge = hasUnresolvedRelationships(character) ? '<span class=\"char-review-badge\">NEEDS REVIEW</span>' : '';\r\n\r\n            const aliasText = character.aliases && character.aliases.length > 0\r\n                ? `<div class=\"char-aliases\">Aliases: ${escapeHtml(character.aliases.join(', '))}</div>`\r\n                : '';\r\n\r\n            const relationshipText = character.relationships && character.relationships.length > 0\r\n                ? `<div class=\"char-relationships\">Relationships: ${escapeHtml(character.relationships.join('; '))}</div>`\r\n                : '';\r\n\r\n            const lastUpdated = character.lastUpdated\r\n                ? new Date(character.lastUpdated).toLocaleString()\r\n                : 'Never';\r\n\r\n            html += `\r\n                <div class=\"name_tracker_character_item\" data-character=\"${escapeHtml(character.preferredName)}\">\r\n                    <div class=\"char-header\">\r\n                        <span class=\"char-name\">\r\n                            ${charIcon}\r\n                            ${escapeHtml(character.preferredName)}\r\n                            ${ignoreIcon}\r\n                            ${reviewBadge}\r\n                        </span>\r\n                        <div class=\"char-actions\">\r\n                            <button class=\"char-action-btn char-action-edit\" data-name=\"${escapeHtml(character.preferredName)}\" title=\"Edit lorebook entry\">\r\n                                <i class=\"fa-solid fa-edit\"></i>\r\n                            </button>\r\n                            <button class=\"char-action-btn char-action-view\" data-name=\"${escapeHtml(character.preferredName)}\" title=\"View in lorebook\">\r\n                                <i class=\"fa-solid fa-book\"></i>\r\n                            </button>\r\n                            <button class=\"char-action-btn char-action-merge\" data-name=\"${escapeHtml(character.preferredName)}\" title=\"Merge with another character\">\r\n                                <i class=\"fa-solid fa-code-merge\"></i>\r\n                            </button>\r\n                            <button class=\"char-action-btn char-action-ignore\" data-name=\"${escapeHtml(character.preferredName)}\" title=\"${character.ignored ? 'Unignore' : 'Ignore'} character\">\r\n                                <i class=\"fa-solid ${character.ignored ? 'fa-eye' : 'fa-eye-slash'}\"></i>\r\n                            </button>\r\n                        </div>\r\n                    </div>\r\n                    ${aliasText}\r\n                    ${relationshipText}\r\n                    <div class=\"char-metadata\">\r\n                        <span>Confidence: ${character.confidence}%</span>\r\n                        <span>Updated: ${lastUpdated}</span>\r\n                    </div>\r\n                </div>\r\n            `;\r\n        }\r\n\r\n        html += '</div>';\r\n        $container.html(html);\r\n    });\r\n}\r\n\r\n/**\r\n * Update status display in settings\r\n * @returns {void}\r\n */\r\nexport function updateStatusDisplay() {\r\n    return withErrorBoundary('updateStatusDisplay', () => {\r\n        const $statusContainer = $('#name_tracker_status_display');\r\n        if ($statusContainer.length === 0) {\r\n            return;\r\n        }\r\n\r\n        const characters = getCharacters();\r\n        const characterCount = Object.keys(characters).length;\r\n        const messageCounter = getSetting('messageCounter', 0);\r\n        const lastScannedId = getSetting('lastScannedMessageId', -1);\r\n        const messageFreq = getSetting('messageFrequency', 10);\r\n\r\n        const context = stContext.getContext();\r\n        const currentMessageId = context?.chat?.length || 0;\r\n        const pendingMessages = Math.max(0, currentMessageId - lastScannedId);\r\n        const progressText = messageCounter > 0 ? ` (${messageCounter} analyzed)` : '';\r\n        const currentChatLength = context.chat ? context.chat.length : 0;\r\n        const messagesToNextScan = Math.max(0, messageFreq - (currentChatLength - lastScannedId));\r\n\r\n        const statusHtml = `\r\n            <div class=\"name_tracker_status\">\r\n                <div class=\"status-item\">\r\n                    <strong>Characters tracked:</strong> ${characterCount}${progressText}\r\n                </div>\r\n                <div class=\"status-item\">\r\n                    <strong>Messages in chat:</strong> ${currentChatLength}\r\n                </div>\r\n                <div class=\"status-item\">\r\n                    <strong>Last scanned message:</strong> ${lastScannedId >= 0 ? lastScannedId + 1 : 'None'}\r\n                </div>\r\n                <div class=\"status-item\">\r\n                    <strong>Pending messages:</strong> ${pendingMessages}\r\n                </div>\r\n                <div class=\"status-item\">\r\n                    <strong>Messages until next scan:</strong> ${messagesToNextScan}\r\n                </div>\r\n            </div>\r\n        `;\r\n\r\n        $statusContainer.html(statusHtml);\r\n    });\r\n}\r\n\r\n/**\r\n * Show character merge dialog\r\n * @param {string} sourceName - Name of source character\r\n * @returns {Promise<void>}\r\n */\r\nexport async function showMergeDialog(sourceName) {\r\n    return withErrorBoundary('showMergeDialog', async () => {\r\n        const characters = getCharacters();\r\n\r\n        // Create list of other characters\r\n        const otherChars = Object.keys(characters).filter(name => name !== sourceName);\r\n\r\n        if (otherChars.length === 0) {\r\n            notifications.warning('No other characters to merge with');\r\n            return;\r\n        }\r\n\r\n        // Simple prompt for target character\r\n        const targetName = prompt(`Merge \"${sourceName}\" into which character? Available: ${otherChars.join(', ')}`);\r\n        if (targetName && characters[targetName]) {\r\n            await mergeCharacters(sourceName, targetName);\r\n            updateCharacterList();\r\n            updateStatusDisplay();\r\n        } else if (targetName) {\r\n            notifications.error('Invalid target character name');\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Show character creation modal\r\n * @returns {Promise<void>}\r\n */\r\nexport async function showCreateCharacterModal() {\r\n    return withErrorBoundary('showCreateCharacterModal', async () => {\r\n        const characterName = prompt('Enter character name:');\r\n\r\n        if (!characterName || !characterName.trim()) {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            await createNewCharacter(characterName.trim());\r\n            updateCharacterList();\r\n            updateStatusDisplay();\r\n        } catch (error) {\r\n            notifications.error(error.message);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Show purge confirmation dialog\r\n * @returns {Promise<void>}\r\n */\r\nexport async function showPurgeConfirmation() {\r\n    return withErrorBoundary('showPurgeConfirmation', async () => {\r\n        const characters = getCharacters();\r\n        const characterCount = Object.keys(characters).length;\r\n\r\n        if (characterCount === 0) {\r\n            notifications.info('No characters to purge');\r\n            return;\r\n        }\r\n\r\n        const confirmed = confirm(`This will delete all ${characterCount} tracked characters and their lorebook entries.\\\\n\\\\nThis action cannot be undone!\\\\n\\\\nContinue?`);\r\n\r\n        if (confirmed) {\r\n            try {\r\n                const deletedCount = await purgeAllCharacters();\r\n                updateCharacterList();\r\n                updateStatusDisplay();\r\n                notifications.success(`Purged ${deletedCount} characters`);\r\n            } catch (error) {\r\n                notifications.error(`Failed to purge characters: ${error.message}`);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Show system prompt editor modal\r\n * @returns {Promise<void>}\r\n */\r\nexport async function showSystemPromptEditor() {\r\n    return withErrorBoundary('showSystemPromptEditor', async () => {\r\n        const currentPrompt = getSetting('systemPrompt') || '';\r\n\r\n        // Create modal dialog\r\n        const modal = $(`\r\n            <div class=\"nametracker-modal\" style=\"\r\n                position: fixed;\r\n                top: 50%;\r\n                left: 50%;\r\n                transform: translate(-50%, -50%);\r\n                background: var(--SmartThemeBlurTintColor);\r\n                border: 1px solid var(--SmartThemeBorderColor);\r\n                border-radius: 10px;\r\n                padding: 20px;\r\n                max-width: 700px;\r\n                width: 90%;\r\n                max-height: 80vh;\r\n                overflow-y: auto;\r\n                z-index: 9999;\r\n                box-shadow: 0 4px 20px rgba(0,0,0,0.5);\r\n            \">\r\n                <h3 style=\"margin-top: 0;\">Edit System Prompt</h3>\r\n                <p>Customize the system prompt used for character analysis. Leave blank to use default.</p>\r\n                <textarea id=\"system_prompt_editor\" rows=\"20\" style=\"width: 100%; margin: 10px 0;\" \r\n                          placeholder=\"Enter custom system prompt or leave blank for default...\">${escapeHtml(currentPrompt)}</textarea>\r\n                <div style=\"margin-top: 20px; text-align: right;\">\r\n                    <button class=\"menu_button\" id=\"system_prompt_save\">Save</button>\r\n                    <button class=\"menu_button\" id=\"system_prompt_reset\">Reset to Default</button>\r\n                    <button class=\"menu_button\" id=\"system_prompt_cancel\">Cancel</button>\r\n                </div>\r\n            </div>\r\n        `);\r\n\r\n        const overlay = $(`\r\n            <div class=\"nametracker-overlay\" style=\"\r\n                position: fixed;\r\n                top: 0;\r\n                left: 0;\r\n                width: 100%;\r\n                height: 100%;\r\n                background: rgba(0,0,0,0.7);\r\n                z-index: 9998;\r\n            \"></div>\r\n        `);\r\n\r\n        $('body').append(overlay).append(modal);\r\n\r\n        const removeModal = () => {\r\n            modal.remove();\r\n            overlay.remove();\r\n        };\r\n\r\n        modal.find('#system_prompt_save').on('click', () => {\r\n            const newPrompt = modal.find('#system_prompt_editor').val().trim();\r\n            setSetting('systemPrompt', newPrompt || null);\r\n            notifications.success('System prompt updated');\r\n            removeModal();\r\n        });\r\n\r\n        modal.find('#system_prompt_reset').on('click', () => {\r\n            modal.find('#system_prompt_editor').val('');\r\n            setSetting('systemPrompt', null);\r\n            notifications.success('Reset to default system prompt');\r\n            removeModal();\r\n        });\r\n\r\n        modal.find('#system_prompt_cancel').on('click', removeModal);\r\n        overlay.on('click', removeModal);\r\n    });\r\n}\r\n\r\n/**\r\n * Show character list modal\r\n * @returns {void}\r\n */\r\nexport function showCharacterListModal() {\r\n    return withErrorBoundary('showCharacterListModal', () => {\r\n        const characters = Object.values(getCharacters() || {});\r\n\r\n        // Build character list HTML\r\n        let charactersHtml = '';\r\n\r\n        if (characters.length === 0) {\r\n            charactersHtml = '<p style=\"text-align: center; color: var(--SmartThemeQuoteColor);\">No characters tracked yet</p>';\r\n        } else {\r\n            // Sort: Main characters first, then by name\r\n            characters.sort((a, b) => {\r\n                if (a.isMainChar && !b.isMainChar) return -1;\r\n                if (!a.isMainChar && b.isMainChar) return 1;\r\n                return a.preferredName.localeCompare(b.preferredName);\r\n            });\r\n\r\n            charactersHtml = '<div style=\"max-height: 400px; overflow-y: auto;\">';\r\n            for (const char of characters) {\r\n                const badges = [];\r\n                if (char.isMainChar) badges.push('<span style=\"background: var(--SmartThemeBodyColor); padding: 2px 6px; border-radius: 3px; font-size: 0.85em; margin-left: 5px;\">MAIN</span>');\r\n                if (char.ignored) badges.push('<span style=\"background: var(--black70a); padding: 2px 6px; border-radius: 3px; font-size: 0.85em; margin-left: 5px;\">IGNORED</span>');\r\n                if (hasUnresolvedRelationships(char)) badges.push('<span style=\"background: var(--crimsonDark); padding: 2px 6px; border-radius: 3px; font-size: 0.85em; margin-left: 5px;\">NEEDS REVIEW</span>');\r\n\r\n                const aliasText = char.aliases && char.aliases.length > 0\r\n                    ? `<div style=\"font-size: 0.9em; color: var(--SmartThemeQuoteColor); margin-top: 3px;\">Aliases: ${escapeHtml(char.aliases.join(', '))}</div>`\r\n                    : '';\r\n\r\n                charactersHtml += `\r\n                    <div style=\"padding: 10px; margin: 5px 0; background: var(--SmartThemeBlurTintColor); border: 1px solid var(--SmartThemeBorderColor); border-radius: 5px;\">\r\n                        <div style=\"font-weight: bold;\">\r\n                            ${char.isMainChar ? '<i class=\"fa-solid fa-user\" style=\"margin-right: 5px;\"></i>' : ''}\r\n                            ${escapeHtml(char.preferredName)}\r\n                            ${badges.join('')}\r\n                        </div>\r\n                        ${aliasText}\r\n                    </div>\r\n                `;\r\n            }\r\n            charactersHtml += '</div>';\r\n        }\r\n\r\n        // Create and show modal\r\n        const modalHtml = `\r\n            <div class=\"name-tracker-character-modal\">\r\n                <h3 style=\"margin-top: 0;\">Tracked Characters (${characters.length})</h3>\r\n                ${charactersHtml}\r\n                <div style=\"margin-top: 15px; text-align: center;\">\r\n                    <button class=\"menu_button\" onclick=\"$('#name_tracker_settings').find('.inline-drawer-toggle').click(); $(this).closest('.popup').remove();\">\r\n                        <i class=\"fa-solid fa-gear\"></i> Open Settings\r\n                    </button>\r\n                </div>\r\n            </div>\r\n        `;\r\n\r\n        const context = stContext.getContext();\r\n        context.callGenericPopup(modalHtml, context.POPUP_TYPE.TEXT, '', { wider: true, okButton: 'Close' });\r\n    });\r\n}\r\n\r\n/**\r\n * Initialize UI event handlers\r\n * @returns {void}\r\n */\r\nexport function initializeUIHandlers() {\r\n    return withErrorBoundary('initializeUIHandlers', () => {\r\n        // Character action handlers\r\n        $(document).on('click', '.char-action-merge', async function() {\r\n            const sourceName = $(this).data('name');\r\n            await showMergeDialog(sourceName);\r\n        });\r\n\r\n        $(document).on('click', '.char-action-ignore', async function() {\r\n            const name = $(this).data('name');\r\n            await toggleIgnoreCharacter(name);\r\n            updateCharacterList();\r\n            updateStatusDisplay();\r\n        });\r\n\r\n        $(document).on('click', '.char-action-view', async function() {\r\n            const name = $(this).data('name');\r\n            await viewInLorebook(name);\r\n        });\r\n\r\n        $(document).on('click', '.char-action-edit', async function() {\r\n            const name = $(this).data('name');\r\n            await showEditLorebookModal(name);\r\n        });\r\n\r\n        debug.log();\r\n    });\r\n}\r\n\r\n/**\r\n * Show edit lorebook entry modal\r\n * @param {string} characterName - Name of character to edit\r\n * @returns {Promise<void>}\r\n */\r\nasync function showEditLorebookModal(characterName) {\r\n    return withErrorBoundary('showEditLorebookModal', async () => {\r\n        const character = getCharacter(characterName);\r\n\r\n        if (!character) {\r\n            notifications.error('Character not found');\r\n            return;\r\n        }\r\n\r\n        // Build edit dialog\r\n        const currentKeys = [characterName, ...(character.aliases || [])].join(', ');\r\n\r\n        const dialogHtml = `\r\n            <div class=\"lorebook-entry-editor\">\r\n                <h3>Edit Lorebook Entry: ${escapeHtml(characterName)}</h3>\r\n                \r\n                <div class=\"editor-section\">\r\n                    <label for=\"entry-keys\">Keys (comma-separated):</label>\r\n                    <input type=\"text\" id=\"entry-keys\" class=\"text_pole\" value=\"${escapeHtml(currentKeys)}\" \r\n                           placeholder=\"${escapeHtml(characterName)}, aliases, nicknames\">\r\n                    <small>These words trigger this entry in the chat context</small>\r\n                </div>\r\n                \r\n                <div class=\"editor-section\">\r\n                    <label for=\"entry-content\">Entry Content:</label>\r\n                    <textarea id=\"entry-content\" rows=\"10\" class=\"text_pole\" \r\n                              placeholder=\"Description, personality, background, relationships...\">${escapeHtml(character.notes || '')}</textarea>\r\n                    <small>This will be injected into context when keys are mentioned</small>\r\n                </div>\r\n                \r\n                <div class=\"editor-section\">\r\n                    <label for=\"entry-relationships\">Relationships:</label>\r\n                    <textarea id=\"entry-relationships\" rows=\"3\" class=\"text_pole\" \r\n                              placeholder=\"Friend of Alice; Enemy of Bob; Works for XYZ Corp\">${escapeHtml((character.relationships || []).join('; '))}</textarea>\r\n                    <small>One relationship per line or semicolon-separated</small>\r\n                </div>\r\n            </div>\r\n        `;\r\n\r\n        // Create simple modal dialog\r\n        const modal = $(`\r\n            <div class=\"nametracker-modal\" style=\"\r\n                position: fixed;\r\n                top: 50%;\r\n                left: 50%;\r\n                transform: translate(-50%, -50%);\r\n                background: var(--SmartThemeBlurTintColor);\r\n                border: 1px solid var(--SmartThemeBorderColor);\r\n                border-radius: 10px;\r\n                padding: 20px;\r\n                max-width: 600px;\r\n                width: 90%;\r\n                max-height: 80vh;\r\n                overflow-y: auto;\r\n                z-index: 9999;\r\n                box-shadow: 0 4px 20px rgba(0,0,0,0.5);\r\n            \">\r\n                ${dialogHtml}\r\n                <div style=\"margin-top: 20px; text-align: right;\">\r\n                    <button class=\"menu_button\" id=\"entry-save\">Save</button>\r\n                    <button class=\"menu_button\" id=\"entry-cancel\">Cancel</button>\r\n                </div>\r\n            </div>\r\n        `);\r\n\r\n        const overlay = $(`\r\n            <div class=\"nametracker-overlay\" style=\"\r\n                position: fixed;\r\n                top: 0;\r\n                left: 0;\r\n                width: 100%;\r\n                height: 100%;\r\n                background: rgba(0,0,0,0.7);\r\n                z-index: 9998;\r\n            \"></div>\r\n        `);\r\n\r\n        $('body').append(overlay).append(modal);\r\n\r\n        const removeModal = () => {\r\n            modal.remove();\r\n            overlay.remove();\r\n        };\r\n\r\n        modal.find('#entry-save').on('click', async () => {\r\n            const keys = modal.find('#entry-keys').val().split(',').map(k => k.trim()).filter(k => k);\r\n            const content = modal.find('#entry-content').val();\r\n            const relationships = modal.find('#entry-relationships').val()\r\n                .split(/[;\\\\n]/)\r\n                .map(r => r.trim())\r\n                .filter(r => r);\r\n\r\n            // Update character data\r\n            const preferredName = keys[0] || characterName;\r\n            const aliases = keys.slice(1);\r\n\r\n            character.preferredName = preferredName;\r\n            character.aliases = aliases;\r\n            character.notes = content;\r\n            character.relationships = relationships;\r\n\r\n            // If preferred name changed, need to update the key in settings\r\n            if (preferredName !== characterName) {\r\n                removeCharacter(characterName);\r\n            }\r\n            setCharacter(preferredName, character);\r\n\r\n            updateCharacterList();\r\n            updateStatusDisplay();\r\n\r\n            notifications.success(`Updated lorebook entry for ${preferredName}`);\r\n            removeModal();\r\n        });\r\n\r\n        modal.find('#entry-cancel').on('click', removeModal);\r\n        overlay.on('click', removeModal);\r\n    });\r\n}\r\n\r\n/**\r\n * Add a menu button to the extensions menu\r\n * @param {string} text - Button text\r\n * @param {string} faIcon - Font Awesome icon classes\r\n * @param {Function} callback - Click handler\r\n * @param {string} hover - Tooltip text\r\n * @param {string} className - Optional additional CSS class\r\n * @returns {void}\r\n */\r\nexport function addMenuButton(text, faIcon, callback, hover = null, className = '') {\r\n    return withErrorBoundary('addMenuButton', () => {\r\n        const $button = $(`\r\n            <div class=\"list-group-item flex-container flexGap5 interactable ${className}\" title=\"${hover || text}\" tabindex=\"0\">\r\n                <i class=\"${faIcon}\"></i>\r\n                <span>${text}</span>\r\n            </div>\r\n        `);\r\n\r\n        const $extensionsMenu = $('#extensionsMenu');\r\n        if (!$extensionsMenu.length) {\r\n            console.error('[Name Tracker] Could not find the extensions menu');\r\n            return;\r\n        }\r\n\r\n        $button.appendTo($extensionsMenu);\r\n        $button.on('click', () => callback());\r\n    });\r\n}\r\n\r\n/**\r\n * Toggle auto-harvest on/off\r\n * @returns {void}\r\n */\r\nexport function toggleAutoHarvest() {\r\n    return withErrorBoundary('toggleAutoHarvest', () => {\r\n        const currentValue = getSetting('autoAnalyze', true);\r\n        setSetting('autoAnalyze', !currentValue);\r\n\r\n        // Update the settings UI\r\n        $('#name_tracker_auto_analyze').prop('checked', !currentValue);\r\n\r\n        // Update menu button icon to reflect state\r\n        const $menuButton = $('#extensionsMenu .name-tracker-toggle-harvest');\r\n        if (!currentValue) {\r\n            $menuButton.find('i').removeClass('fa-toggle-off').addClass('fa-toggle-on');\r\n        } else {\r\n            $menuButton.find('i').removeClass('fa-toggle-on').addClass('fa-toggle-off');\r\n        }\r\n\r\n        updateStatusDisplay();\r\n\r\n        notifications.success(\r\n            `Auto-harvest ${!currentValue ? 'enabled' : 'disabled'}`,\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Open the chat lorebook in the World Info editor\r\n * @returns {Promise<void>}\r\n */\r\nexport async function openChatLorebook() {\r\n    return withErrorBoundary('openChatLorebook', async () => {\r\n        const context = stContext.getContext();\r\n        const lorebookName = context.chatMetadata?.world_info;\r\n\r\n        if (!lorebookName) {\r\n            notifications.warning('No active chat or lorebook');\r\n            return;\r\n        }\r\n\r\n        if (typeof context.openWorldInfoEditor === 'function') {\r\n            await context.openWorldInfoEditor(lorebookName);\r\n        } else {\r\n            // Fallback: show the world info panel\r\n            $('#WorldInfo').click();\r\n            notifications.info(`Please select \"${lorebookName}\" from the World Info panel`);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Initialize extension menu buttons\r\n * @returns {void}\r\n */\r\nexport function initializeMenuButtons() {\r\n    return withErrorBoundary('initializeMenuButtons', () => {\r\n        // Add toggle auto-harvest button with visual state\r\n        const autoAnalyze = getSetting('autoAnalyze', true);\r\n        const toggleIcon = autoAnalyze ? 'fa-solid fa-toggle-on' : 'fa-solid fa-toggle-off';\r\n        addMenuButton(\r\n            'Toggle Auto-Harvest',\r\n            toggleIcon,\r\n            toggleAutoHarvest,\r\n            'Toggle automatic character harvesting on/off',\r\n            'name-tracker-toggle-harvest',\r\n        );\r\n\r\n        // Add character list button\r\n        addMenuButton(\r\n            'View Characters',\r\n            'fa-solid fa-users',\r\n            showCharacterListModal,\r\n            'View all tracked characters',\r\n        );\r\n\r\n        // Add open lorebook button\r\n        addMenuButton(\r\n            'Open Chat Lorebook',\r\n            'fa-solid fa-book',\r\n            openChatLorebook,\r\n            'Open the Name Tracker chat lorebook in the World Info editor',\r\n        );\r\n\r\n        debug.log();\r\n    });\r\n}\r\n\r\n/**\r\n * Bind settings UI event handlers\r\n * @returns {void}\r\n */\r\nexport function bindSettingsHandlers() {\r\n    return withErrorBoundary('bindSettingsHandlers', () => {\r\n        // Main settings handlers\r\n        $('#name_tracker_enabled').on('input', (event) => {\r\n            setSetting('enabled', event.target.checked);\r\n            updateStatusDisplay();\r\n        });\r\n\r\n        $('#name_tracker_auto_analyze').on('input', (event) => {\r\n            setSetting('autoAnalyze', event.target.checked);\r\n            updateStatusDisplay();\r\n        });\r\n\r\n        $('#name_tracker_message_frequency').on('input', (event) => {\r\n            setSetting('messageFrequency', parseInt(event.target.value) || 10);\r\n            updateStatusDisplay();\r\n        });\r\n\r\n        $('#name_tracker_llm_source').on('change', (event) => {\r\n            setSetting('llmSource', event.target.value);\r\n        });\r\n\r\n        $('#name_tracker_ollama_endpoint').on('input', (event) => {\r\n            setSetting('ollamaEndpoint', event.target.value);\r\n        });\r\n\r\n        $('#name_tracker_ollama_model').on('change', (event) => {\r\n            setSetting('ollamaModel', event.target.value);\r\n        });\r\n\r\n        $('#name_tracker_load_models').on('click', async () => {\r\n            try {\r\n                await loadOllamaModels();\r\n                notifications.success('Ollama models loaded');\r\n                // eslint-disable-next-line no-unused-vars\r\n            } catch (error) {\r\n                debug.log();\r\n                notifications.error('Failed to load Ollama models');\r\n            }\r\n        });\r\n\r\n        $('#name_tracker_confidence_threshold').on('input', (event) => {\r\n            setSetting('confidenceThreshold', parseInt(event.target.value) || 70);\r\n        });\r\n\r\n        // Lorebook settings handlers\r\n        $('#name_tracker_lorebook_position').on('change', (event) => {\r\n            setSetting('lorebookPosition', parseInt(event.target.value) || 0);\r\n        });\r\n\r\n        $('#name_tracker_lorebook_depth').on('input', (event) => {\r\n            setSetting('lorebookDepth', parseInt(event.target.value) || 1);\r\n        });\r\n\r\n        $('#name_tracker_lorebook_cooldown').on('input', (event) => {\r\n            setSetting('lorebookCooldown', parseInt(event.target.value) || 5);\r\n        });\r\n\r\n        $('#name_tracker_lorebook_probability').on('input', (event) => {\r\n            setSetting('lorebookProbability', parseInt(event.target.value) || 100);\r\n        });\r\n\r\n        $('#name_tracker_lorebook_enabled').on('input', (event) => {\r\n            setSetting('lorebookEnabled', event.target.checked);\r\n        });\r\n\r\n        $('#name_tracker_debug_mode').on('input', (event) => {\r\n            setSetting('debugMode', event.target.checked);\r\n        });\r\n\r\n        // Action button handlers\r\n        $('#name_tracker_manual_analyze').on('click', async () => {\r\n            const messageFreq = getSetting('messageFrequency', 10);\r\n            await harvestMessages(messageFreq, true);\r\n            updateCharacterList();\r\n            updateStatusDisplay();\r\n        });\r\n\r\n        $('#name_tracker_scan_all').on('click', async () => {\r\n            await scanEntireChat();\r\n            updateCharacterList();\r\n            updateStatusDisplay();\r\n        });\r\n\r\n        $('#name_tracker_create_character').on('click', () => {\r\n            showCreateCharacterModal();\r\n        });\r\n\r\n        $('#name_tracker_clear_cache').on('click', () => {\r\n            clearProcessingQueue();\r\n            notifications.info('Cache and processing queue cleared');\r\n        });\r\n\r\n        $('#name_tracker_undo_merge').on('click', async () => {\r\n            const { undoLastMerge } = await import('./characters.js');\r\n            const success = await undoLastMerge();\r\n            if (success) {\r\n                updateCharacterList();\r\n                updateStatusDisplay();\r\n            }\r\n        });\r\n\r\n        $('#name_tracker_purge_entries').on('click', () => {\r\n            showPurgeConfirmation();\r\n        });\r\n\r\n        $('#name_tracker_edit_prompt').on('click', () => {\r\n            showSystemPromptEditor();\r\n        });\r\n\r\n        $('#name_tracker_debug_status').on('click', () => {\r\n            showDebugStatus();\r\n        });\r\n\r\n        $('#name_tracker_dump_context').on('click', () => {\r\n            dumpContextToConsole();\r\n        });\r\n\r\n        debug.log();\r\n    });\r\n}\r\n\r\n/**\r\n * Show debug status popup with all relevant variables\r\n * @returns {void}\r\n */\r\nfunction showDebugStatus() {\r\n    return withErrorBoundary('showDebugStatus', async () => {\r\n        const settings = get_settings();\r\n        const characters = getCharacters();\r\n\r\n        // Reusable builder: compute debug info + HTML\r\n        const buildDebugContent = async () => {\r\n            // Get LLM context info\r\n            let llmConfig = {};\r\n            let maxPromptTokens = 4096;\r\n            let contextDetails = {};\r\n            let detectionMethod = 'unknown';\r\n            let detectionDebugLog = '';\r\n\r\n            try {\r\n                const { getLLMConfig, getMaxPromptLength } = await import('./llm.js');\r\n                const { stContext } = await import('../core/context.js');\r\n\r\n                llmConfig = getLLMConfig();\r\n                const maxPromptResultObj = await getMaxPromptLength();\r\n                maxPromptTokens = maxPromptResultObj.maxPrompt;\r\n                detectionMethod = maxPromptResultObj.detectionMethod;\r\n                detectionDebugLog = maxPromptResultObj.debugLog || '';\r\n\r\n                // Get raw context info (retry briefly if not yet ready)\r\n                let context = stContext.getContext();\r\n                if (!context || typeof context.maxContext === 'undefined') {\r\n                    for (let i = 0; i < 3; i++) {\r\n                        await new Promise(r => setTimeout(r, 200));\r\n                        context = stContext.getContext();\r\n                        if (context && typeof context.maxContext !== 'undefined') break;\r\n                    }\r\n                }\r\n\r\n                if (!context || typeof context.maxContext === 'undefined') {\r\n                    contextDetails = {\r\n                        totalContext: 'Not loaded yet (no chat active)',\r\n                        maxGeneration: 'N/A',\r\n                        maxGenerationNote: 'Context will be available after chat loads',\r\n                        modelName: context?.main_api || 'unknown',\r\n                    };\r\n                } else {\r\n                    const totalContext = context.maxContext;\r\n                    const extensionMaxTokens = Math.min(4096, Math.floor(totalContext * 0.15));\r\n\r\n                    contextDetails = {\r\n                        totalContext: totalContext,\r\n                        maxGeneration: extensionMaxTokens,\r\n                        maxGenerationNote: 'Extension-controlled (15% of context, max 4096)',\r\n                        modelName: context.main_api || 'unknown',\r\n                    };\r\n                }\r\n            } catch (_error) {\r\n                console.error('[NT-Debug] Error in buildDebugContent:', _error);\r\n                debug.log('Could not load LLM config:', _error);\r\n                contextDetails = {\r\n                    totalContext: 'Error loading',\r\n                    maxGeneration: 'Error',\r\n                    maxGenerationNote: 'Check console for details',\r\n                    modelName: 'unknown',\r\n                };\r\n                detectionMethod = 'error';\r\n            }\r\n\r\n            // Get batch size constants from processing module\r\n            const batchConstants = {\r\n                MIN_MESSAGES_PER_BATCH: 5,\r\n                TARGET_MESSAGES_PER_BATCH: 30,\r\n                MAX_MESSAGES_PER_BATCH: 50,\r\n                CONTEXT_TARGET_PERCENT: 80,\r\n                MIN_CONTEXT_TARGET: 50,\r\n            };\r\n\r\n            const systemPromptTokens = 500;\r\n            const maxGenTokens = typeof contextDetails.maxGeneration === 'number' ? contextDetails.maxGeneration : 2048;\r\n            const safetyMargin = 500;\r\n            const reservedTokens = systemPromptTokens + maxGenTokens + safetyMargin;\r\n            const availableTokens = maxPromptTokens;\r\n\r\n            // Compile debug info\r\n            const debugInfo = {\r\n                'Extension Status': {\r\n                    'Enabled': settings.enabled !== false,\r\n                    'Debug Mode': settings.debugMode !== false,\r\n                    'LLM Source': settings.llmSource || 'sillytavern',\r\n                    'Model API': contextDetails.modelName,\r\n                    'Tracked Characters': Object.keys(characters).length,\r\n                },\r\n                'SillyTavern Context': {\r\n                    'Total Context Window': contextDetails.totalContext,\r\n                    'Extension Max Tokens': `${contextDetails.maxGeneration} (${contextDetails.maxGenerationNote})`,\r\n                    'System Prompt Reserve': systemPromptTokens,\r\n                    'Safety Margin': safetyMargin,\r\n                    'Total Reserved': reservedTokens,\r\n                },\r\n                'Max Context Detection': {\r\n                    'Detection Method': detectionMethod || 'unknown',\r\n                    'Detected Max Context': contextDetails.totalContext,\r\n                    'Final Max Prompt': maxPromptTokens,\r\n                },\r\n                'Usable Token Budget': {\r\n                    'Max Prompt Tokens': maxPromptTokens,\r\n                    'Context Target %': batchConstants.CONTEXT_TARGET_PERCENT,\r\n                    'Tokens to Use': Math.floor(availableTokens * (batchConstants.CONTEXT_TARGET_PERCENT / 100)),\r\n                },\r\n                'Batch Configuration': {\r\n                    'Min Messages/Batch': batchConstants.MIN_MESSAGES_PER_BATCH,\r\n                    'Target Messages/Batch': batchConstants.TARGET_MESSAGES_PER_BATCH,\r\n                    'Max Messages/Batch': batchConstants.MAX_MESSAGES_PER_BATCH,\r\n                    'Min Context Target': batchConstants.MIN_CONTEXT_TARGET,\r\n                },\r\n                'Analysis Settings': {\r\n                    'Message Frequency': settings.messageFrequency || 10,\r\n                    'Auto-Analyze': settings.autoAnalyze !== false,\r\n                    'Confidence Threshold': settings.confidenceThreshold || 70,\r\n                },\r\n                'Lorebook Settings': {\r\n                    'Position': ['After Char', 'Before Char', 'Top', 'Bottom'][settings.lorebookPosition || 0],\r\n                    'Depth': settings.lorebookDepth || 1,\r\n                    'Cooldown': settings.lorebookCooldown || 5,\r\n                    'Probability %': settings.lorebookProbability || 100,\r\n                    'Enabled': settings.lorebookEnabled !== false,\r\n                },\r\n            };\r\n\r\n            // Format for display\r\n            let htmlContent = '<div style=\"font-family: monospace; font-size: 12px; max-height: 500px; overflow-y: auto;\">';\r\n            for (const [section, values] of Object.entries(debugInfo)) {\r\n                htmlContent += '<div style=\"margin-bottom: 15px; border-bottom: 1px solid #666; padding-bottom: 10px;\">';\r\n                htmlContent += `<strong style=\\\"color: #90EE90; font-size: 13px;\\\">${section}</strong><br>`;\r\n                for (const [key, value] of Object.entries(values)) {\r\n                    const displayValue = value === true ? '' : (value === false ? '' : value);\r\n                    htmlContent += `<div style=\\\"margin-left: 10px; padding: 2px 0;\\\">\\n                        <span style=\\\"color: #87CEEB;\\\">${key}:</span> \\n                        <span style=\\\"color: #FFFF99;\\\">${displayValue}</span>\\n                    </div>`;\r\n                }\r\n                htmlContent += '</div>';\r\n            }\r\n            htmlContent += '</div>';\r\n\r\n            return { debugInfo, htmlContent };\r\n        };\r\n\r\n        // Initial content\r\n        const initial = await buildDebugContent();\r\n\r\n        // Show in modal\r\n        const modal = $(`\r\n            <div class=\"nametracker-modal\" style=\"\r\n                position: fixed;\r\n                top: 50%;\r\n                left: 50%;\r\n                transform: translate(-50%, -50%);\r\n                background: #1a1a1a;\r\n                border: 2px solid #90EE90;\r\n                border-radius: 10px;\r\n                padding: 20px;\r\n                max-width: 550px;\r\n                width: 90%;\r\n                max-height: 75vh;\r\n                overflow-y: auto;\r\n                z-index: 9999;\r\n                box-shadow: 0 4px 20px rgba(0,0,0,0.8);\r\n            \">\r\n                <h3 style=\"margin-top: 0; color: #90EE90; border-bottom: 2px solid #90EE90; padding-bottom: 10px;\">\r\n                    <i class=\"fa-solid fa-bug\"></i> Debug Status\r\n                </h3>\r\n                <div id=\"nt-debug-content\">${initial.htmlContent}</div>\r\n                <div style=\"margin-top: 20px; display: flex; gap: 8px; justify-content: flex-end; border-top: 1px solid #666; padding-top: 10px;\">\r\n                    <button class=\"menu_button\" id=\"debug-refresh\" style=\"background: #2a2a2a; color: #FFFF99; border: 1px solid #90EE90;\">Refresh</button>\r\n                    <button class=\"menu_button\" id=\"debug-close\" style=\"background: #2a2a2a; color: #90EE90; border: 1px solid #90EE90;\">Close</button>\r\n                </div>\r\n            </div>\r\n        `);\r\n\r\n        const overlay = $(`\r\n            <div class=\"nametracker-overlay\" style=\"\r\n                position: fixed;\r\n                top: 0;\r\n                left: 0;\r\n                width: 100%;\r\n                height: 100%;\r\n                background: rgba(0,0,0,0.7);\r\n                z-index: 9998;\r\n            \"></div>\r\n        `);\r\n\r\n        $('body').append(overlay).append(modal);\r\n\r\n        const removeModal = () => {\r\n            modal.remove();\r\n            overlay.remove();\r\n        };\r\n\r\n        modal.find('#debug-close').on('click', removeModal);\r\n        overlay.on('click', removeModal);\r\n\r\n        // Log initial to console\r\n        console.log('[NT-Debug]', initial.debugInfo);\r\n\r\n        // Refresh handler: recompute and update content in-place\r\n        modal.find('#debug-refresh').on('click', async () => {\r\n            try {\r\n                const refreshed = await buildDebugContent();\r\n                modal.find('#nt-debug-content').html(refreshed.htmlContent);\r\n                console.log('[NT-Debug]', refreshed.debugInfo);\r\n            } catch (e) {\r\n                console.error('[NT-Debug] Refresh failed:', e);\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * Load and inject settings HTML\r\n * @param {string} extensionFolderPath - Path to extension folder\r\n * @returns {Promise<void>}\r\n */\r\nexport async function loadSettingsHTML(extensionFolderPath) {\r\n    return withErrorBoundary('loadSettingsHTML', async () => {\r\n        try {\r\n            // Load the settings HTML\r\n            const settingsHtml = await $.get(`${extensionFolderPath}/settings.html`);\r\n\r\n            // Append to the extensions settings panel\r\n            $('#extensions_settings').append(settingsHtml);\r\n\r\n            debug.log();\r\n        } catch (error) {\r\n            console.error('Failed to load settings HTML:', error);\r\n            throw new NameTrackerError(`Failed to load settings HTML: ${error.message}`);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Dump entire SillyTavern context to console for debugging\r\n * Shows all properties, values, and structure in readable format\r\n * @returns {void}\r\n */\r\nfunction dumpContextToConsole() {\r\n    return withErrorBoundary('dumpContextToConsole', () => {\r\n        try {\r\n            const dump = stContext.dumpContextToConsole();\r\n            notifications.success('Context dumped to console - Press F12 to view', 'Context Dump');\r\n            \r\n            // Also show a brief summary in a dialog\r\n            const summary = {\r\n                'Total Properties': dump.availableProperties.length,\r\n                'Key Properties Found': Object.keys(dump.detailedBreakdown).filter(k => k in dump.detailedBreakdown).length,\r\n                'Timestamp': dump.timestamp\r\n            };\r\n            \r\n            console.log('%c[Name Tracker] QUICK SUMMARY:', 'color: #ffaa00; font-weight: bold; font-size: 12px;');\r\n            console.table(summary);\r\n            \r\n        } catch (error) {\r\n            debug.log(`Failed to dump context: ${error.message}`);\r\n            notifications.error(`Failed to dump context: ${error.message}`, 'Context Dump');\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Update UI elements based on current settings\r\n * @returns {void}\r\n */\r\nexport function updateUI() {\r\n    return withErrorBoundary('updateUI', () => {\r\n        // Update all form elements with current settings\r\n        $('#name_tracker_enabled').prop('checked', getSetting('enabled', true));\r\n        $('#name_tracker_auto_analyze').prop('checked', getSetting('autoAnalyze', true));\r\n        $('#name_tracker_message_frequency').val(getSetting('messageFrequency', 10));\r\n        $('#name_tracker_llm_source').val(getSetting('llmSource', 'sillytavern'));\r\n        $('#name_tracker_ollama_endpoint').val(getSetting('ollamaEndpoint', 'http://localhost:11434'));\r\n        $('#name_tracker_ollama_model').val(getSetting('ollamaModel', ''));\r\n        $('#name_tracker_confidence_threshold').val(getSetting('confidenceThreshold', 70));\r\n        $('#name_tracker_lorebook_position').val(getSetting('lorebookPosition', 0));\r\n        $('#name_tracker_lorebook_depth').val(getSetting('lorebookDepth', 1));\r\n        $('#name_tracker_lorebook_cooldown').val(getSetting('lorebookCooldown', 5));\r\n        $('#name_tracker_lorebook_probability').val(getSetting('lorebookProbability', 100));\r\n        $('#name_tracker_lorebook_enabled').prop('checked', getSetting('lorebookEnabled', true));\r\n        $('#name_tracker_debug_mode').prop('checked', getSetting('debugMode', false));\r\n\r\n        // Update character list and status\r\n        updateCharacterList();\r\n        updateStatusDisplay();\r\n\r\n        debug.log();\r\n    });\r\n}\r\n","/**\r\n * Name Tracker Extension for SillyTavern - Modular Version\r\n * Main entry point and orchestration\r\n */\r\n\r\n// Import CSS\r\nimport '../style.css';\r\n\r\n// Core infrastructure\r\nimport debugLogger from './core/debug.js';\r\nimport { errorHandler } from './core/errors.js';\r\nimport sillyTavernContext from './core/context.js';\r\nimport { get_settings, getSetting, setChatData, getChatData } from './core/settings.js';\r\n\r\n// Utilities\r\nimport notifications from './utils/notifications.js';\r\nimport { /* escapeHtml, generateUID */ } from './utils/helpers.js';\r\n\r\n// Feature modules\r\nimport { /* initializeCharacterManager */ } from './modules/characters.js';\r\nimport { /* initializeLLMManager */ } from './modules/llm.js';\r\nimport { initializeLorebook } from './modules/lorebook.js';\r\nimport { onMessageReceived } from './modules/processing.js';\r\nimport { initializeUIHandlers, initializeMenuButtons, bindSettingsHandlers, updateUI } from './modules/ui.js';\r\n\r\n// Immediate import validation\r\nconsole.log('[STnametracker] Main index.js: Import validation');\r\nconsole.log('[STnametracker] Main index.js: initializeLorebook import =', typeof initializeLorebook, initializeLorebook);\r\nconsole.log('[STnametracker] Main index.js: initializeUIHandlers import =', typeof initializeUIHandlers, initializeUIHandlers);\r\nconsole.log('[STnametracker] Main index.js: initializeMenuButtons import =', typeof initializeMenuButtons, initializeMenuButtons);\r\nconsole.log('[STnametracker] Main index.js: bindSettingsHandlers import =', typeof bindSettingsHandlers, bindSettingsHandlers);\r\nconsole.log('[STnametracker] Main index.js: updateUI import =', typeof updateUI, updateUI);\r\n\r\nif (typeof initializeLorebook !== 'function') {\r\n    console.error('[STnametracker] Main index.js: CRITICAL ERROR - initializeLorebook import failed!');\r\n    console.error('[STnametracker] Main index.js: Expected function, got:', typeof initializeLorebook, initializeLorebook);\r\n}\r\n\r\n// Extension name constant - MUST match manifest\r\nconst extensionName = 'STnametracker';\r\nconst extensionFolderPath = `scripts/extensions/third-party/${extensionName}`;\r\n\r\n/**\r\n * Get extension settings - Required for SillyTavern integration\r\n * This is the pattern that SillyTavern expects\r\n * @returns {Object} Extension settings object\r\n */\r\n// Kept for potential future use with SillyTavern API\r\n// eslint-disable-next-line no-unused-vars\r\nfunction getExtensionSettings() {\r\n    // Use global extension_settings that SillyTavern provides\r\n    return window.extension_settings?.[extensionName] || {};\r\n}\r\n\r\n// Create the logger AFTER the getSettings function is defined\r\nconst logger = debugLogger.createModuleLogger('Main');\r\n\r\n/**\r\n * Name Tracker Extension main class\r\n */\r\nclass NameTrackerExtension {\r\n    constructor() {\r\n        this.initialized = false;\r\n        this.modules = new Map();\r\n    }\r\n\r\n    /**\r\n     * Initialize the extension\r\n     * @returns {Promise<void>}\r\n     */\r\n    async initialize() {\r\n        console.log('[STnametracker] Enter initialize() method');\r\n        return errorHandler.withErrorBoundary('Main', async () => {\r\n            console.log('[STnametracker] Inside error boundary');\r\n            if (this.initialized) {\r\n                console.log('[STnametracker] Already initialized, skipping');\r\n                return;\r\n            }\r\n\r\n            console.log('[STnametracker] Starting initialization sequence');\r\n            logger.log('Starting Name Tracker Extension v2.1.0');\r\n\r\n            // Initialize core systems\r\n            console.log('[STnametracker] Step 1: Initializing core systems...');\r\n            await this.initializeCore();\r\n            console.log('[STnametracker] Step 1: Core systems completed');\r\n\r\n            // Initialize feature modules\r\n            console.log('[STnametracker] Step 2: Initializing feature modules...');\r\n            await this.initializeModules();\r\n            console.log('[STnametracker] Step 2: Feature modules completed');\r\n\r\n            // Setup UI\r\n            console.log('[STnametracker] Step 3: Initializing UI...');\r\n            await this.initializeUI();\r\n            console.log('[STnametracker] Step 3: UI completed');\r\n\r\n            // Register event listeners\r\n            console.log('[STnametracker] Step 4: Registering event listeners...');\r\n            this.registerEventListeners();\r\n            console.log('[STnametracker] Step 4: Event listeners completed');\r\n\r\n            this.initialized = true;\r\n            console.log('[STnametracker] Marking as initialized');\r\n            logger.log('Name Tracker Extension initialized successfully');\r\n            console.log('[STnametracker] Full initialization sequence completed successfully');\r\n\r\n        }, {\r\n            retries: 2,\r\n            fallback: async (error) => {\r\n                logger.error('Failed to initialize extension:', error);\r\n                notifications.error('Failed to initialize', 'Extension Error');\r\n                return false;\r\n            },\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Initialize core infrastructure\r\n     * @returns {Promise<void>}\r\n     */\r\n    async initializeCore() {\r\n        console.log('[STnametracker] initializeCore: Starting...');\r\n        logger.debug('Initializing core systems...');\r\n\r\n        // Connect debug system to settings\r\n        console.log('[STnametracker] initializeCore: Connecting debug system...');\r\n        debugLogger.isDebugEnabled = () => getSetting('debugMode', false);\r\n        console.log('[STnametracker] initializeCore: Debug system connected');\r\n\r\n        // Settings are auto-initialized when accessed\r\n        console.log('[STnametracker] initializeCore: Settings ready');\r\n\r\n        // Setup error recovery strategies\r\n        this.setupErrorRecovery();\r\n\r\n        logger.debug('Core systems initialized');\r\n    }\r\n\r\n    /**\r\n     * Initialize feature modules\r\n     * @returns {Promise<void>}\r\n     */\r\n    async initializeModules() {\r\n        logger.debug('Initializing feature modules...');\r\n        console.log('[STnametracker] initializeModules: Starting module initialization');\r\n\r\n        // Add extensive debugging for imports\r\n        console.log('[STnametracker] initializeModules: Checking import of initializeLorebook...');\r\n        console.log('[STnametracker] initializeModules: initializeLorebook =', typeof initializeLorebook, initializeLorebook);\r\n\r\n        if (typeof initializeLorebook !== 'function') {\r\n            console.error('[STnametracker] initializeModules: CRITICAL - initializeLorebook is not a function!');\r\n            console.error('[STnametracker] initializeModules: Type:', typeof initializeLorebook);\r\n            console.error('[STnametracker] initializeModules: Value:', initializeLorebook);\r\n            throw new Error('initializeLorebook is not a function: ' + typeof initializeLorebook);\r\n        }\r\n\r\n        try {\r\n            // Initialize lorebook for current chat\r\n            console.log('[STnametracker] initializeModules: About to call initializeLorebook()...');\r\n            await initializeLorebook();\r\n            console.log('[STnametracker] initializeModules: initializeLorebook() completed successfully');\r\n\r\n            logger.debug('Feature modules initialized');\r\n        } catch (error) {\r\n            console.error('[STnametracker] initializeModules: Error in initializeLorebook:', error);\r\n            logger.error('Failed to initialize feature modules:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initialize UI components\r\n     * @returns {Promise<void>}\r\n     */\r\n    async initializeUI() {\r\n        console.log('[STnametracker] initializeUI: Starting UI initialization...');\r\n        logger.debug('Initializing UI...');\r\n\r\n        try {\r\n            // Load settings HTML using proper jQuery pattern\r\n            console.log('[STnametracker] initializeUI: Loading settings HTML from:', `${extensionFolderPath}/settings.html`);\r\n            const settingsHtml = await $.get(`${extensionFolderPath}/settings.html`);\r\n            console.log('[STnametracker] initializeUI: Settings HTML loaded, length:', settingsHtml.length);\r\n\r\n            console.log('[STnametracker] initializeUI: Finding #extensions_settings element...');\r\n            const targetElement = $('#extensions_settings');\r\n            console.log('[STnametracker] initializeUI: Target element found:', targetElement.length > 0);\r\n\r\n            targetElement.append(settingsHtml);\r\n            console.log('[STnametracker] initializeUI: Settings HTML appended');\r\n\r\n            // Initialize UI handlers\r\n            console.log('[STnametracker] initializeUI: Initializing UI handlers...');\r\n            initializeUIHandlers();\r\n            console.log('[STnametracker] initializeUI: UI handlers initialized');\r\n\r\n            console.log('[STnametracker] initializeUI: Initializing menu buttons...');\r\n            initializeMenuButtons();\r\n            console.log('[STnametracker] initializeUI: Menu buttons initialized');\r\n\r\n            // Bind settings form handlers\r\n            console.log('[STnametracker] initializeUI: Binding settings handlers...');\r\n            bindSettingsHandlers();\r\n            console.log('[STnametracker] initializeUI: Settings handlers bound');\r\n\r\n            // Update UI to reflect current settings\r\n            console.log('[STnametracker] initializeUI: Updating UI...');\r\n            updateUI();\r\n            console.log('[STnametracker] initializeUI: UI updated');\r\n\r\n            logger.debug('UI initialized');\r\n        } catch (error) {\r\n            logger.error('Failed to initialize UI:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register SillyTavern event listeners\r\n     */\r\n    registerEventListeners() {\r\n        logger.debug('Registering event listeners...');\r\n\r\n        try {\r\n            // Get event objects from SillyTavern context\r\n            const context = sillyTavernContext.getContext();\r\n            const eventSource = context.eventSource;\r\n            const event_types = context.event_types;\r\n\r\n            if (!eventSource || !event_types) {\r\n                logger.warn('SillyTavern event system not available');\r\n                return;\r\n            }\r\n\r\n            // Register for SillyTavern events\r\n            eventSource.on(event_types.MESSAGE_RECEIVED, async (messageId) => {\r\n                logger.debug('Message received event:', messageId);\r\n                await onMessageReceived(messageId);\r\n            });\r\n\r\n            eventSource.on(event_types.MESSAGE_SENT, async (messageId) => {\r\n                logger.debug('Message sent event:', messageId);\r\n                await onMessageReceived(messageId);\r\n            });\r\n\r\n            eventSource.on(event_types.CHAT_CHANGED, async () => {\r\n                logger.debug('Chat changed event received');\r\n                // Reset chat-level data when chat changes\r\n                setChatData({ characters: {}, lastScannedMessageId: -1 });\r\n            });\r\n\r\n            logger.debug('Event listeners registered');\r\n        } catch (error) {\r\n            logger.error('Failed to register event listeners:', error);\r\n        }\r\n    }\r\n    /**\r\n     * Setup error recovery strategies\r\n     */\r\n    setupErrorRecovery() {\r\n        // Network error recovery\r\n        errorHandler.registerRecoveryStrategy('NETWORK_ERROR', async (error) => {\r\n            logger.warn('Attempting network error recovery');\r\n            await errorHandler.delay(2000);\r\n            notifications.info('Retrying network operation...');\r\n            return null; // Signal to retry original operation\r\n        });\r\n\r\n        // Data format error recovery\r\n        errorHandler.registerRecoveryStrategy('DATA_FORMAT_ERROR', async (error) => {\r\n            logger.warn('Data format error, clearing cache');\r\n            // TODO: Clear relevant caches when modules are implemented\r\n            return null;\r\n        });\r\n\r\n        // Critical error handler\r\n        errorHandler.onCriticalError((error) => {\r\n            logger.error('Critical error occurred:', error);\r\n            // TODO: Save state for debugging when modules are implemented\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get extension status for debugging\r\n     * @returns {Object} Status information\r\n     */\r\n    getStatus() {\r\n        return {\r\n            initialized: this.initialized,\r\n            context: sillyTavernContext.getStatus(),\r\n            settings: { initialized: true, moduleCount: Object.keys(get_settings()).length },\r\n            debug: debugLogger.getPerformanceSummary(),\r\n            errors: errorHandler.getRecentErrors(5).length,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Shutdown the extension\r\n     * @returns {Promise<void>}\r\n     */\r\n    async shutdown() {\r\n        return errorHandler.withErrorBoundary('Main', async () => {\r\n            logger.log('Shutting down Name Tracker Extension');\r\n\r\n            // TODO: Cleanup modules\r\n            // TODO: Remove event listeners\r\n            // TODO: Save state\r\n\r\n            this.initialized = false;\r\n            debugLogger.clear();\r\n\r\n            logger.log('Extension shutdown complete');\r\n        }, { silent: true });\r\n    }\r\n}\r\n\r\n// Create extension instance\r\nconst nameTrackerExtension = new NameTrackerExtension();\r\n\r\n// Initialize extension when jQuery is ready - SillyTavern pattern\r\njQuery(async () => {\r\n    console.log('[STnametracker] jQuery ready, starting extension load...');\r\n    try {\r\n        console.log('[STnametracker] Logger available, initializing...');\r\n        logger.log('Name Tracker Extension loading...');\r\n\r\n        // Initialize extension_settings for this extension\r\n        console.log('[STnametracker] Setting up extension_settings...');\r\n        if (!window.extension_settings) {\r\n            console.log('[STnametracker] Creating window.extension_settings');\r\n            window.extension_settings = {};\r\n        }\r\n        console.log('[STnametracker] Current extension_settings keys:', Object.keys(window.extension_settings));\r\n        window.extension_settings[extensionName] = window.extension_settings[extensionName] || {};\r\n        console.log('[STnametracker] Extension settings initialized');\r\n\r\n        console.log('[STnametracker] Starting main initialization...');\r\n        await nameTrackerExtension.initialize();\r\n        console.log('[STnametracker] Main initialization completed');\r\n\r\n        // Make extension available globally for debugging\r\n        window.nameTrackerExtension = nameTrackerExtension;\r\n\r\n        // Add debug commands to browser console\r\n        window.ntDebug = {\r\n            status: () => nameTrackerExtension.getStatus(),\r\n            errors: () => errorHandler.getRecentErrors(),\r\n            settings: () => get_settings(),\r\n            chatData: () => getChatData(),\r\n            clear: () => debugLogger.clear(),\r\n        };\r\n\r\n        logger.log('Name Tracker Extension loaded successfully');\r\n        console.log('[STnametracker] Extension loaded. Use ntDebug.status() for diagnostics.');\r\n\r\n    } catch (error) {\r\n        console.error('[STnametracker] Failed to initialize:', error);\r\n        notifications.error('Extension failed to load', 'Critical Error');\r\n    }\r\n});\r\n\r\nexport default nameTrackerExtension;\r\n"],"names":["module","exports","styleElement","nonce","setAttribute","stylesInDOM","getIndexByIdentifier","identifier","result","i","length","modulesToDom","list","options","idCountMap","identifiers","item","id","base","count","concat","indexByIdentifier","obj","css","media","sourceMap","supports","layer","references","updater","addElementStyle","byIndex","splice","push","api","domAPI","update","newObj","remove","lastIdentifiers","newList","index","newLastIdentifiers","_i","_index","___CSS_LOADER_EXPORT___","logger","sillyTavernContext","constructor","this","_context","_lastUpdate","_updateInterval","getContext","now","Date","SillyTavern","error","Error","getChat","chat","getChatMetadata","chatMetadata","getChatId","chatId","getCharacterId","characterId","getCharacters","characters","getUserName","name1","getExtensionSettings","extensionSettings","saveExtensionSettings","withErrorBoundary","async","context","saveSettingsDebounced","warn","silent","saveChatMetadata","saveMetadata","generateQuietPrompt","retries","loadWorldInfo","lorebookName","saveWorldInfo","data","create","saveWorldInfoEntry","entryData","getEventSource","eventSource","getEventTypes","event_types","callGenericPopup","content","type","input","isContextAvailable","clearCache","debug","getStatus","available","cached","lastUpdate","dumpContextToConsole","dump","timestamp","toISOString","availableProperties","Object","keys","fullContext","detailedBreakdown","keyProps","prop","value","isNull","isUndefined","undefined","console","group","log","join","JSON","stringify","groupEnd","styleSheet","cssText","firstChild","removeChild","appendChild","document","createTextNode","stack","bind","notifications","initializeLorebook","stContext","METADATA_KEY","bookName","replace","substring","entries","info","timeOut","message","updateLorebookEntry","character","characterName","lorebookConfig","contentParts","physicalAge","mentalAge","ageInfo","physical","personality","sexuality","raceEthnicity","roleSkills","lastInteraction","relationships","forEach","rel","preferredName","aliases","worldInfo","messageFreq","calculatedCooldown","Math","max","floor","existingUid","lorebookEntryId","existingEntry","key","enabled","position","probability","depth","scanDepth","cooldown","newUid","newEntry","uid","keysecondary","comment","constant","selective","contextConfig","prefix","suffix","tokenBudget","reservedTokens","budgetPriority","trimDirection","insertionOrder","maximumTrimType","insertionPosition","excludeRecursion","preventRecursion","delayUntilRecursion","useProbability","selectiveLogic","caseSensitive","matchWholeWords","useGroupScoring","automationId","role","vectorized","sticky","delay","verifyWorldInfo","targetUid","viewInLorebook","warning","openWorldInfoEditor","success","$","click","cssWithMappingToString","toString","map","needLayer","modules","dedupe","alreadyImportedModules","k","_k","cssMapping","btoa","base64","unescape","encodeURIComponent","sourceMapping","NameTrackerError","code","recoverable","super","name","errorHandler","errorHistory","transactionStack","recoveryStrategies","Map","criticalErrorCallbacks","moduleName","operation","fallback","operationId","lastError","startTime","trace","attempt","pow","trackedError","trackError","duration","notifyUser","fallbackError","recovery","get","recoveryError","categorizeError","isRecoverable","shift","includes","startTransaction","transactionId","initialState","state","commitTransaction","findIndex","t","rollbackTransaction","transaction","parse","registerRecoveryStrategy","errorCode","strategy","set","onCriticalError","callback","toastr","callbackError","getRecentErrors","slice","clearHistory","ms","Promise","resolve","setTimeout","element","createElement","setAttributes","attributes","insert","MODULE_NAME","DEFAULT_SETTINGS","freeze","autoAnalyze","messageFrequency","llmSource","ollamaEndpoint","ollamaModel","confidenceThreshold","lorebookPosition","lorebookDepth","lorebookCooldown","lorebookScanDepth","lorebookProbability","lorebookEnabled","debugMode","systemPrompt","lastScannedMessageId","totalCharactersDetected","lastAnalysisTime","analysisCache","DEFAULT_CHAT_DATA","analysisHistory","lorebookEntries","processingStats","totalProcessed","charactersFound","lastProcessedTime","get_settings","extension_settings","set_settings","newSettings","assign","metadata","setCharacters","catch","err","getChatData","setChatData","removeCharacter","getSetting","defaultValue","settings","setSetting","getCharacter","setCharacter","chars","getLLMConfig","sillytavern_nametracker","source","getLorebookConfig","set_chat_metadata","debugLog","undoHistory","isIgnoredCharacter","values","some","char","ignored","findExistingCharacter","found","find","findPotentialMatch","analyzedChar","threshold","existingChar","calculateNameSimilarity","alias","name2","toLowerCase","words1","split","words2","filter","w","cleanAliases","Array","isArray","invalidAliases","lowerName","lowerAlias","trim","self","indexOf","createCharacter","isMainChar","confidence","lastUpdated","lastMessageProcessed","updateCharacter","addAsAlias","round","mergeCharacters","sourceName","targetName","sourceChar","targetChar","undoData","sourceData","targetDataBefore","undoLastMerge","lastOp","pop","toggleIgnoreCharacter","status","createNewCharacter","trimmedName","newChar","purgeAllCharacters","characterCount","hasUnresolvedRelationships","knownNames","reduce","names","add","Set","word","has","memo","style","target","styleTarget","querySelector","window","HTMLIFrameElement","contentDocument","head","e","getTarget","NotificationManager","defaultOptions","extendedTimeOut","closeButton","progressBar","preventDuplicates","title","opts","persistent","progress","notificationId","progressHtml","toastId","clear","confirm","onConfirm","onCancel","confirmId","confirmHtml","nameTrackerNotifications","confirmCallbacks","handleConfirmOk","callbacks","handleConfirmCancel","activeConfirms","GENERATION_TOP_P","ollamaModels","CHARACTER_EXTRACTION_SCHEMA","description","strict","DEFAULT_SYSTEM_PROMPT","loadOllamaModels","response","fetch","ok","statusText","json","models","m","getOllamaModelContext","modelName","method","headers","body","parameters","param","match","contextSize","parseInt","model_info","num_ctx","buildCharacterRoster","characterNames","getMaxPromptLength","detectionLog","logEntry","msg","llmConfig","maxContext","maxGenTokens","detectionMethod","contextKeys","detectedMaxContext","common","maxContextSize","token_limit","amount_gen","max_context","min","allKeys","sort","tokensForPrompt","finalValue","maxPrompt","calculateMessageTokens","messages","totalTokens","extra","token_count","text","mes","String","getTokenCountAsync","_error","ceil","parseJSONResponse","jsonMatch","firstBrace","lastBrace","lastIndexOf","parsed","endsWith","salvaged","openBraces","closeBraces","openBrackets","closeBrackets","recovered","callLLMAnalysis","messageObjs","knownCharacters","retryCount","maxPromptTokens","cacheKey","messagesText","idx","then","rosterStr","fullPrompt","promptTokens","tokenError","repeat","midpoint","firstHalf","secondHalf","result1","result2","all","mergedResult","prompt","calculatedMaxTokens","maxTokens","model","stream","format","temperature","top_p","top_k","repeat_penalty","num_predict","callOllama","onlineStatus","rep_pen","max_tokens","generateRaw","prefill","stop","jsonSchema","callSillyTavern","size","firstKey","next","delete","debugLogger","performanceMarks","operationTraces","createModuleLogger","args","addTrace","startTimer","timerName","endTimer","level","isDebugEnabled","toLocaleTimeString","getTrace","performance","toFixed","getPerformanceSummary","activeTimers","activeTraces","from","insertStyleElement","styleTagTransform","apply","parentNode","removeStyleElement","simpleHash","str","hash","charCodeAt","escapeHtml","div","textContent","innerHTML","generateUID","random","substr","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","prototype","hasOwnProperty","call","nc","locals","processingQueue","isProcessing","abortScan","currentProcessingState","totalBatches","currentBatch","failedCharacters","contextTarget","processAnalysisResults","analyzedCharacters","processCharacterData","isMainCharacter","potentialMatch","newCharacter","harvestMessages","messageCount","showProgress","endIdx","startIdx","messagesToAnalyze","availableTokens","messageTokens","batches","currentTokens","batchDetails","msgTokens","wouldExceedTokens","wouldExceedMessageCount","reason","tokens","batchSummary","b","avgBatchSize","notification","showProgressBar","successfulBatches","failedBatches","uniqueCharacters","hideProgressBar","batch","batchStart","sum","batchEnd","characterRoster","analysis","summary","onMessageReceived","messageId","currentMessageIndex","lastScannedId","shouldRescan","modal","append","on","fromMessage","val","rescan","showRescanModal","addToQueue","current","total","progressBarId","$existing","attr","bar","fadeOut","task","processQueue","updateCharacterList","$container","html","sortedCharacters","localeCompare","charIcon","ignoreIcon","reviewBadge","aliasText","relationshipText","toLocaleString","updateStatusDisplay","$statusContainer","messageCounter","currentMessageId","pendingMessages","progressText","currentChatLength","statusHtml","showCharacterListModal","charactersHtml","badges","modalHtml","POPUP_TYPE","TEXT","wider","okButton","initializeUIHandlers","otherChars","showMergeDialog","currentKeys","dialogHtml","notes","overlay","removeModal","r","showEditLorebookModal","addMenuButton","faIcon","hover","className","$button","$extensionsMenu","appendTo","toggleAutoHarvest","currentValue","$menuButton","removeClass","addClass","openChatLorebook","world_info","initializeMenuButtons","bindSettingsHandlers","event","checked","totalMessages","numBatches","batchMessages","safeSummary","scanEntireChat","showCreateCharacterModal","deletedCount","showPurgeConfirmation","currentPrompt","newPrompt","showSystemPromptEditor","buildDebugContent","contextDetails","detectionDebugLog","maxPromptResultObj","totalContext","maxGeneration","maxGenerationNote","main_api","batchConstants","MIN_MESSAGES_PER_BATCH","TARGET_MESSAGES_PER_BATCH","MAX_MESSAGES_PER_BATCH","CONTEXT_TARGET_PERCENT","MIN_CONTEXT_TARGET","systemPromptTokens","safetyMargin","debugInfo","htmlContent","section","initial","refreshed","table","updateUI","extensionName","extensionFolderPath","nameTrackerExtension","initialized","initialize","initializeCore","initializeModules","initializeUI","registerEventListeners","setupErrorRecovery","settingsHtml","targetElement","MESSAGE_RECEIVED","MESSAGE_SENT","CHAT_CHANGED","moduleCount","errors","shutdown","jQuery","ntDebug","chatData"],"ignoreList":[],"sourceRoot":""}