{"version":3,"file":"index.js","mappings":"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","sources":["webpack://sillytavern-nametracker/./src/core/errors.js","webpack://sillytavern-nametracker/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js","webpack://sillytavern-nametracker/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js","webpack://sillytavern-nametracker/./style.css","webpack://sillytavern-nametracker/./node_modules/style-loader/dist/runtime/styleTagTransform.js","webpack://sillytavern-nametracker/./src/core/debug.js","webpack://sillytavern-nametracker/./node_modules/css-loader/dist/runtime/api.js","webpack://sillytavern-nametracker/./node_modules/css-loader/dist/runtime/sourceMaps.js","webpack://sillytavern-nametracker/./src/utils/notifications.js","webpack://sillytavern-nametracker/./node_modules/style-loader/dist/runtime/insertStyleElement.js","webpack://sillytavern-nametracker/./src/core/settings.js","webpack://sillytavern-nametracker/./node_modules/style-loader/dist/runtime/insertBySelector.js","webpack://sillytavern-nametracker/./src/modules/characters.js","webpack://sillytavern-nametracker/./node_modules/style-loader/dist/runtime/styleDomAPI.js","webpack://sillytavern-nametracker/./src/core/context.js","webpack://sillytavern-nametracker/webpack/bootstrap","webpack://sillytavern-nametracker/webpack/runtime/compat get default export","webpack://sillytavern-nametracker/webpack/runtime/define property getters","webpack://sillytavern-nametracker/webpack/runtime/hasOwnProperty shorthand","webpack://sillytavern-nametracker/webpack/runtime/nonce","webpack://sillytavern-nametracker/./style.css?f696","webpack://sillytavern-nametracker/./src/utils/helpers.js","webpack://sillytavern-nametracker/./src/modules/llm.js","webpack://sillytavern-nametracker/./src/modules/lorebook.js","webpack://sillytavern-nametracker/./src/modules/processing.js","webpack://sillytavern-nametracker/./src/modules/ui.js","webpack://sillytavern-nametracker/./src/index.js"],"sourcesContent":["/**\r\n * Error handling and recovery system for Name Tracker extension\r\n * Provides error boundaries, graceful degradation, and transaction rollback\r\n */\r\n\r\nimport debugLogger from './debug.js';\r\n\r\nconst logger = debugLogger.createModuleLogger('ErrorHandler');\r\n\r\nclass NameTrackerError extends Error {\r\n    constructor(message, code, module, recoverable = true) {\r\n        super(message);\r\n        this.name = 'NameTrackerError';\r\n        this.code = code;\r\n        this.module = module;\r\n        this.recoverable = recoverable;\r\n        this.timestamp = Date.now();\r\n    }\r\n}\r\n\r\nclass ErrorHandler {\r\n    constructor() {\r\n        this.errorHistory = [];\r\n        this.transactionStack = [];\r\n        this.recoveryStrategies = new Map();\r\n        this.criticalErrorCallbacks = [];\r\n    }\r\n\r\n    /**\r\n     * Create error boundary for a module operation\r\n     * @param {string} moduleName - Module name\r\n     * @param {Function} operation - Operation to execute\r\n     * @param {Object} options - Error handling options\r\n     * @returns {Promise<any>} Operation result or error recovery result\r\n     */\r\n    async withErrorBoundary(moduleName, operation, options = {}) {\r\n        const {\r\n            fallback = null,\r\n            retries = 0,\r\n            silent = false,\r\n            operationId = null,\r\n        } = options;\r\n\r\n        let lastError = null;\r\n        const startTime = Date.now();\r\n\r\n        if (operationId) {\r\n            logger.trace(operationId, `Starting operation in ${moduleName}`);\r\n        }\r\n\r\n        for (let attempt = 0; attempt <= retries; attempt++) {\r\n            try {\r\n                const result = await operation();\r\n\r\n                if (operationId) {\r\n                    logger.trace(operationId, `Operation completed successfully in ${moduleName}`);\r\n                }\r\n\r\n                return result;\r\n            } catch (error) {\r\n                console.log(`[STnametracker] Error caught in ${moduleName}:`, error);\r\n                lastError = error;\r\n\r\n                if (attempt < retries) {\r\n                    console.log(`[STnametracker] Retrying operation in ${moduleName}, attempt ${attempt + 1}/${retries + 1}:`, error.message);\r\n                    logger.warn(`Retrying operation in ${moduleName}, attempt ${attempt + 1}/${retries + 1}:`, error.message);\r\n                    await this.delay(Math.pow(2, attempt) * 100); // Exponential backoff\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n\r\n        // All retries failed\r\n        console.log(`[STnametracker] All retries failed in ${moduleName}, tracking error:`, lastError);\r\n        const trackedError = this.trackError(lastError, moduleName, {\r\n            operation: operation.name || 'anonymous',\r\n            duration: Date.now() - startTime,\r\n            retries: retries,\r\n            operationId: operationId,\r\n        });\r\n\r\n        if (!silent) {\r\n            console.log(`[STnametracker] Notifying user of error in ${moduleName}`);\r\n            this.notifyUser(trackedError);\r\n        }\r\n\r\n        // Try recovery strategy\r\n        if (fallback) {\r\n            try {\r\n                logger.debug(`Attempting fallback for ${moduleName}:`, trackedError.code);\r\n                return await fallback(trackedError);\r\n            } catch (fallbackError) {\r\n                logger.error(`Fallback failed for ${moduleName}:`, fallbackError);\r\n            }\r\n        }\r\n\r\n        // Check if we have a recovery strategy\r\n        const recovery = this.recoveryStrategies.get(trackedError.code);\r\n        if (recovery) {\r\n            try {\r\n                return await recovery(trackedError);\r\n            } catch (recoveryError) {\r\n                logger.error(`Recovery strategy failed for ${trackedError.code}:`, recoveryError);\r\n            }\r\n        }\r\n\r\n        throw trackedError;\r\n    }\r\n\r\n    /**\r\n     * Track and categorize errors\r\n     * @param {Error} error - Original error\r\n     * @param {string} moduleName - Module where error occurred\r\n     * @param {Object} context - Additional context\r\n     * @returns {NameTrackerError} Tracked error\r\n     */\r\n    trackError(error, moduleName, context = {}) {\r\n        let trackedError;\r\n\r\n        if (error instanceof NameTrackerError) {\r\n            trackedError = error;\r\n        } else {\r\n            // Categorize common error types\r\n            const code = this.categorizeError(error, moduleName);\r\n            trackedError = new NameTrackerError(\r\n                error.message,\r\n                code,\r\n                moduleName,\r\n                this.isRecoverable(error, code),\r\n            );\r\n        }\r\n\r\n        trackedError.context = context;\r\n        this.errorHistory.push(trackedError);\r\n\r\n        // Keep only last 100 errors\r\n        if (this.errorHistory.length > 100) {\r\n            this.errorHistory.shift();\r\n        }\r\n\r\n        logger.error(`Error in ${moduleName}:`, {\r\n            code: trackedError.code,\r\n            message: trackedError.message,\r\n            context: context,\r\n        });\r\n\r\n        return trackedError;\r\n    }\r\n\r\n    /**\r\n     * Categorize error types for better handling\r\n     * @param {Error} error - Original error\r\n     * @param {string} moduleName - Module name\r\n     * @returns {string} Error code\r\n     */\r\n    categorizeError(error, moduleName) {\r\n        if (error.message.includes('fetch') || error.message.includes('network')) {\r\n            return 'NETWORK_ERROR';\r\n        }\r\n\r\n        if (error.message.includes('JSON') || error.message.includes('parse')) {\r\n            return 'DATA_FORMAT_ERROR';\r\n        }\r\n\r\n        if (error.message.includes('context') || error.message.includes('SillyTavern')) {\r\n            return 'CONTEXT_ERROR';\r\n        }\r\n\r\n        if (error.name === 'TypeError') {\r\n            return 'TYPE_ERROR';\r\n        }\r\n\r\n        if (moduleName === 'LLM' && (error.message.includes('quota') || error.message.includes('rate'))) {\r\n            return 'API_LIMIT_ERROR';\r\n        }\r\n\r\n        return 'UNKNOWN_ERROR';\r\n    }\r\n\r\n    /**\r\n     * Determine if an error is recoverable\r\n     * @param {Error} error - Original error\r\n     * @param {string} code - Error code\r\n     * @returns {boolean} Whether error is recoverable\r\n     */\r\n    isRecoverable(error, code) {\r\n        const nonRecoverableErrors = [\r\n            'CONTEXT_ERROR',\r\n            'TYPE_ERROR',\r\n        ];\r\n\r\n        return !nonRecoverableErrors.includes(code);\r\n    }\r\n\r\n    /**\r\n     * Start a transaction for rollback capability\r\n     * @param {string} transactionId - Unique transaction identifier\r\n     * @param {Object} initialState - State to potentially rollback to\r\n     */\r\n    startTransaction(transactionId, initialState) {\r\n        this.transactionStack.push({\r\n            id: transactionId,\r\n            state: JSON.stringify(initialState),\r\n            timestamp: Date.now(),\r\n        });\r\n\r\n        logger.debug(`Started transaction: ${transactionId}`);\r\n    }\r\n\r\n    /**\r\n     * Commit a transaction (remove from rollback stack)\r\n     * @param {string} transactionId - Transaction identifier\r\n     */\r\n    commitTransaction(transactionId) {\r\n        const index = this.transactionStack.findIndex(t => t.id === transactionId);\r\n        if (index !== -1) {\r\n            this.transactionStack.splice(index, 1);\r\n            logger.debug(`Committed transaction: ${transactionId}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rollback a transaction\r\n     * @param {string} transactionId - Transaction identifier\r\n     * @returns {Object|null} Previous state or null if not found\r\n     */\r\n    rollbackTransaction(transactionId) {\r\n        const index = this.transactionStack.findIndex(t => t.id === transactionId);\r\n        if (index !== -1) {\r\n            const transaction = this.transactionStack.splice(index, 1)[0];\r\n            logger.debug(`Rolled back transaction: ${transactionId}`);\r\n            return JSON.parse(transaction.state);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Register a recovery strategy for specific error codes\r\n     * @param {string} errorCode - Error code to handle\r\n     * @param {Function} strategy - Recovery function\r\n     */\r\n    registerRecoveryStrategy(errorCode, strategy) {\r\n        this.recoveryStrategies.set(errorCode, strategy);\r\n        logger.debug(`Registered recovery strategy for: ${errorCode}`);\r\n    }\r\n\r\n    /**\r\n     * Register callback for critical errors\r\n     * @param {Function} callback - Function to call on critical errors\r\n     */\r\n    onCriticalError(callback) {\r\n        this.criticalErrorCallbacks.push(callback);\r\n    }\r\n\r\n    /**\r\n     * Notify user of errors via toastr\r\n     * @param {NameTrackerError} error - Error to display\r\n     */\r\n    notifyUser(error) {\r\n        const message = `Name Tracker: ${error.message}`;\r\n\r\n        if (error.recoverable) {\r\n            toastr.warning(message, 'Warning', { timeOut: 5000 });\r\n        } else {\r\n            toastr.error(message, 'Error', { timeOut: 8000 });\r\n\r\n            // Notify critical error callbacks\r\n            this.criticalErrorCallbacks.forEach(callback => {\r\n                try {\r\n                    callback(error);\r\n                } catch (callbackError) {\r\n                    logger.error('Critical error callback failed:', callbackError);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get recent error history\r\n     * @param {number} count - Number of recent errors to return\r\n     * @returns {Array} Recent errors\r\n     */\r\n    getRecentErrors(count = 10) {\r\n        return this.errorHistory.slice(-count);\r\n    }\r\n\r\n    /**\r\n     * Clear error history\r\n     */\r\n    clearHistory() {\r\n        this.errorHistory = [];\r\n        logger.debug('Cleared error history');\r\n    }\r\n\r\n    /**\r\n     * Utility delay function for retries\r\n     * @param {number} ms - Milliseconds to delay\r\n     * @returns {Promise} Delay promise\r\n     */\r\n    delay(ms) {\r\n        return new Promise(resolve => setTimeout(resolve, ms));\r\n    }\r\n}\r\n\r\n// Create singleton instance\r\nconst errorHandler = new ErrorHandler();\r\n\r\nexport { errorHandler, NameTrackerError };\r\nexport const withErrorBoundary = errorHandler.withErrorBoundary.bind(errorHandler);\r\nexport default errorHandler;\r\n","\"use strict\";\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce = typeof __webpack_nonce__ !== \"undefined\" ? __webpack_nonce__ : null;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;","\"use strict\";\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"./node_modules/css-loader/dist/runtime/sourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"./node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `/* Styles for the Name Tracker extension */\r\n\r\n.name-tracker-settings {\r\n    padding: 5px;\r\n}\r\n\r\n.name-tracker_block {\r\n    margin-bottom: 10px;\r\n}\r\n\r\n.name-tracker_block h4 {\r\n    margin-top: 10px;\r\n    margin-bottom: 10px;\r\n    font-weight: bold;\r\n}\r\n\r\n/* Status Display */\r\n.name-tracker-status-block {\r\n    background-color: var(--SmartThemeBlurTintColor);\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    border-radius: 5px;\r\n    padding: 10px;\r\n}\r\n\r\n.name-tracker-status {\r\n    font-weight: bold;\r\n    color: var(--SmartThemeBodyColor);\r\n    padding: 5px;\r\n    text-align: center;\r\n}\r\n\r\n/* Character List */\r\n.name-tracker-character-list {\r\n    max-height: 400px;\r\n    overflow-y: auto;\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    border-radius: 5px;\r\n    padding: 5px;\r\n    margin-top: 5px;\r\n}\r\n\r\n.name-tracker-character {\r\n    padding: 10px;\r\n    margin-bottom: 10px;\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    border-radius: 5px;\r\n    background-color: var(--SmartThemeBlurTintColor);\r\n}\r\n\r\n.name-tracker-character:last-child {\r\n    margin-bottom: 0;\r\n}\r\n\r\n/* Active/loaded character styling (characters that are loaded in SillyTavern) */\r\n.name-tracker-character.main-character {\r\n    border-left: 3px solid #4CAF50;\r\n    background-color: rgba(76, 175, 80, 0.05);\r\n}\r\n\r\n.character-header {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    margin-bottom: 5px;\r\n}\r\n\r\n.character-name {\r\n    font-weight: bold;\r\n    font-size: 1.1em;\r\n    color: var(--SmartThemeBodyColor);\r\n}\r\n\r\n.character-name .fa-user {\r\n    color: #4CAF50;\r\n    margin-right: 5px;\r\n}\r\n\r\n.character-name.ignored {\r\n    color: var(--SmartThemeQuoteColor);\r\n    text-decoration: line-through;\r\n}\r\n\r\n.character-badge {\r\n    display: inline-block;\r\n    padding: 2px 8px;\r\n    border-radius: 3px;\r\n    font-size: 0.75em;\r\n    font-weight: bold;\r\n    margin-left: 5px;\r\n}\r\n\r\n.character-badge.main-char {\r\n    background-color: #4CAF50;\r\n    color: #fff;\r\n}\r\n\r\n.character-badge.ignored {\r\n    background-color: #666;\r\n    color: #fff;\r\n}\r\n\r\n.character-badge.unresolved {\r\n    background-color: #ff9800;\r\n    color: #000;\r\n}\r\n\r\n/* Lorebook entry editor modal */\r\n.lorebook-entry-editor h3 {\r\n    margin-top: 0;\r\n    margin-bottom: 20px;\r\n    color: var(--SmartThemeBodyColor);\r\n}\r\n\r\n.editor-section {\r\n    margin-bottom: 15px;\r\n}\r\n\r\n.editor-section label {\r\n    display: block;\r\n    font-weight: bold;\r\n    margin-bottom: 5px;\r\n    color: var(--SmartThemeBodyColor);\r\n}\r\n\r\n.editor-section small {\r\n    display: block;\r\n    margin-top: 3px;\r\n    color: var(--SmartThemeQuoteColor);\r\n    font-size: 0.85em;\r\n}\r\n\r\n.editor-section input,\r\n.editor-section textarea {\r\n    width: 100%;\r\n    box-sizing: border-box;\r\n}\r\n\r\n.character-aliases {\r\n    font-size: 0.9em;\r\n    color: var(--SmartThemeQuoteColor);\r\n    margin-bottom: 8px;\r\n    font-style: italic;\r\n}\r\n\r\n.lorebook-entry-id {\r\n    display: inline-block;\r\n    margin-left: 10px;\r\n    padding: 2px 6px;\r\n    background: var(--SmartThemeBlurTintColor);\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    border-radius: 3px;\r\n    font-family: monospace;\r\n    font-size: 0.85em;\r\n    font-style: normal;\r\n    color: var(--SmartThemeQuoteColor);\r\n}\r\n\r\n.character-details {\r\n    font-size: 0.85em;\r\n    color: var(--SmartThemeBodyColor);\r\n    margin: 8px 0;\r\n    padding: 8px;\r\n    background: var(--SmartThemeBlurTintColor);\r\n    border-left: 2px solid var(--SmartThemeBorderColor);\r\n    border-radius: 3px;\r\n    line-height: 1.4;\r\n}\r\n\r\n.character-actions {\r\n    display: flex;\r\n    gap: 5px;\r\n    flex-wrap: wrap;\r\n    margin-top: 8px;\r\n}\r\n\r\n.character-actions .menu_button {\r\n    flex: 1;\r\n    min-width: 100px;\r\n    padding: 5px 10px;\r\n    font-size: 0.9em;\r\n}\r\n\r\n.menu_button.compact {\r\n    padding: 5px 10px;\r\n    font-size: 0.9em;\r\n}\r\n\r\n.name-tracker-empty {\r\n    color: var(--SmartThemeQuoteColor);\r\n    font-style: italic;\r\n    text-align: center;\r\n    padding: 20px;\r\n}\r\n\r\n/* Ollama Settings */\r\n.ollama-settings {\r\n    background-color: var(--SmartThemeBlurTintColor);\r\n    border-left: 3px solid var(--SmartThemeBorderColor);\r\n    padding: 10px;\r\n    margin-top: 5px;\r\n    border-radius: 5px;\r\n}\r\n\r\n/* Merge Dialog */\r\n.merge-dialog {\r\n    padding: 15px;\r\n}\r\n\r\n.merge-dialog p {\r\n    margin-bottom: 10px;\r\n}\r\n\r\n.merge-dialog strong {\r\n    color: var(--SmartThemeBodyColor);\r\n    font-weight: bold;\r\n}\r\n\r\n.merge-warning {\r\n    color: #ff9800;\r\n    font-size: 0.9em;\r\n    margin-top: 10px;\r\n    padding: 10px;\r\n    background-color: rgba(255, 152, 0, 0.1);\r\n    border-left: 3px solid #ff9800;\r\n    border-radius: 3px;\r\n}\r\n\r\n/* Button states */\r\nbutton:disabled {\r\n    opacity: 0.5;\r\n    cursor: not-allowed;\r\n}\r\n\r\n/* Flex utilities */\r\n.flexGap5 {\r\n    gap: 5px;\r\n}\r\n\r\n.flex1 {\r\n    flex: 1;\r\n}\r\n\r\n/* Progress indicator */\r\n.name-tracker-progress {\r\n    margin: 10px 0;\r\n    padding: 10px;\r\n    background-color: var(--SmartThemeBlurTintColor);\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    border-radius: 5px;\r\n    text-align: center;\r\n}\r\n\r\n.name-tracker-progress .progress-text {\r\n    margin-bottom: 5px;\r\n    font-weight: bold;\r\n}\r\n\r\n.name-tracker-progress .progress-bar {\r\n    width: 100%;\r\n    height: 20px;\r\n    background-color: var(--black50a);\r\n    border-radius: 10px;\r\n    overflow: hidden;\r\n}\r\n\r\n.name-tracker-progress .progress-fill {\r\n    height: 100%;\r\n    background-color: var(--SmartThemeQuoteColor);\r\n    transition: width 0.3s ease;\r\n}\r\n\r\n/* Character details preview (for potential future use) */\r\n.character-details {\r\n    display: none;\r\n    margin-top: 10px;\r\n    padding: 10px;\r\n    background-color: var(--black30a);\r\n    border-radius: 5px;\r\n    font-size: 0.9em;\r\n}\r\n\r\n.character-details.expanded {\r\n    display: block;\r\n}\r\n\r\n.character-details-section {\r\n    margin-bottom: 8px;\r\n}\r\n\r\n.character-details-section:last-child {\r\n    margin-bottom: 0;\r\n}\r\n\r\n.character-details-label {\r\n    font-weight: bold;\r\n    color: var(--SmartThemeQuoteColor);\r\n    margin-right: 5px;\r\n}\r\n\r\n/* Responsive adjustments */\r\n@media (max-width: 768px) {\r\n    .character-actions {\r\n        flex-direction: column;\r\n    }\r\n    \r\n    .character-actions .menu_button {\r\n        width: 100%;\r\n    }\r\n}\r\n\r\n/* Animation for new characters */\r\n@keyframes fadeIn {\r\n    from {\r\n        opacity: 0;\r\n        transform: translateY(-10px);\r\n    }\r\n    to {\r\n        opacity: 1;\r\n        transform: translateY(0);\r\n    }\r\n}\r\n\r\n.name-tracker-character.new {\r\n    animation: fadeIn 0.3s ease;\r\n}\r\n\r\n/* System Prompt Editor */\r\n.system-prompt-editor h3 {\r\n    margin-top: 0;\r\n    margin-bottom: 10px;\r\n    color: var(--SmartThemeBodyColor);\r\n}\r\n\r\n.system-prompt-editor p {\r\n    margin-bottom: 10px;\r\n    color: var(--SmartThemeQuoteColor);\r\n    font-size: 0.9em;\r\n}\r\n\r\n#system_prompt_editor {\r\n    background-color: var(--SmartThemeBlurTintColor);\r\n    color: var(--SmartThemeBodyColor);\r\n    border: 1px solid var(--SmartThemeBorderColor);\r\n    border-radius: 3px;\r\n    padding: 10px;\r\n    resize: vertical;\r\n}\r\n\r\n#system_prompt_editor:focus {\r\n    outline: none;\r\n    border-color: var(--SmartThemeEmColor);\r\n}\r\n\r\n.system-prompt-actions button {\r\n    min-width: 100px;\r\n}\r\n\r\n#system_prompt_reset {\r\n    margin-right: auto;\r\n}\r\n\r\n\r\n`, \"\",{\"version\":3,\"sources\":[\"webpack://./style.css\"],\"names\":[],\"mappings\":\"AAAA,0CAA0C;;AAE1C;IACI,YAAY;AAChB;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,gBAAgB;IAChB,mBAAmB;IACnB,iBAAiB;AACrB;;AAEA,mBAAmB;AACnB;IACI,gDAAgD;IAChD,8CAA8C;IAC9C,kBAAkB;IAClB,aAAa;AACjB;;AAEA;IACI,iBAAiB;IACjB,iCAAiC;IACjC,YAAY;IACZ,kBAAkB;AACtB;;AAEA,mBAAmB;AACnB;IACI,iBAAiB;IACjB,gBAAgB;IAChB,8CAA8C;IAC9C,kBAAkB;IAClB,YAAY;IACZ,eAAe;AACnB;;AAEA;IACI,aAAa;IACb,mBAAmB;IACnB,8CAA8C;IAC9C,kBAAkB;IAClB,gDAAgD;AACpD;;AAEA;IACI,gBAAgB;AACpB;;AAEA,gFAAgF;AAChF;IACI,8BAA8B;IAC9B,yCAAyC;AAC7C;;AAEA;IACI,aAAa;IACb,8BAA8B;IAC9B,mBAAmB;IACnB,kBAAkB;AACtB;;AAEA;IACI,iBAAiB;IACjB,gBAAgB;IAChB,iCAAiC;AACrC;;AAEA;IACI,cAAc;IACd,iBAAiB;AACrB;;AAEA;IACI,kCAAkC;IAClC,6BAA6B;AACjC;;AAEA;IACI,qBAAqB;IACrB,gBAAgB;IAChB,kBAAkB;IAClB,iBAAiB;IACjB,iBAAiB;IACjB,gBAAgB;AACpB;;AAEA;IACI,yBAAyB;IACzB,WAAW;AACf;;AAEA;IACI,sBAAsB;IACtB,WAAW;AACf;;AAEA;IACI,yBAAyB;IACzB,WAAW;AACf;;AAEA,gCAAgC;AAChC;IACI,aAAa;IACb,mBAAmB;IACnB,iCAAiC;AACrC;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,cAAc;IACd,iBAAiB;IACjB,kBAAkB;IAClB,iCAAiC;AACrC;;AAEA;IACI,cAAc;IACd,eAAe;IACf,kCAAkC;IAClC,iBAAiB;AACrB;;AAEA;;IAEI,WAAW;IACX,sBAAsB;AAC1B;;AAEA;IACI,gBAAgB;IAChB,kCAAkC;IAClC,kBAAkB;IAClB,kBAAkB;AACtB;;AAEA;IACI,qBAAqB;IACrB,iBAAiB;IACjB,gBAAgB;IAChB,0CAA0C;IAC1C,8CAA8C;IAC9C,kBAAkB;IAClB,sBAAsB;IACtB,iBAAiB;IACjB,kBAAkB;IAClB,kCAAkC;AACtC;;AAEA;IACI,iBAAiB;IACjB,iCAAiC;IACjC,aAAa;IACb,YAAY;IACZ,0CAA0C;IAC1C,mDAAmD;IACnD,kBAAkB;IAClB,gBAAgB;AACpB;;AAEA;IACI,aAAa;IACb,QAAQ;IACR,eAAe;IACf,eAAe;AACnB;;AAEA;IACI,OAAO;IACP,gBAAgB;IAChB,iBAAiB;IACjB,gBAAgB;AACpB;;AAEA;IACI,iBAAiB;IACjB,gBAAgB;AACpB;;AAEA;IACI,kCAAkC;IAClC,kBAAkB;IAClB,kBAAkB;IAClB,aAAa;AACjB;;AAEA,oBAAoB;AACpB;IACI,gDAAgD;IAChD,mDAAmD;IACnD,aAAa;IACb,eAAe;IACf,kBAAkB;AACtB;;AAEA,iBAAiB;AACjB;IACI,aAAa;AACjB;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,iCAAiC;IACjC,iBAAiB;AACrB;;AAEA;IACI,cAAc;IACd,gBAAgB;IAChB,gBAAgB;IAChB,aAAa;IACb,wCAAwC;IACxC,8BAA8B;IAC9B,kBAAkB;AACtB;;AAEA,kBAAkB;AAClB;IACI,YAAY;IACZ,mBAAmB;AACvB;;AAEA,mBAAmB;AACnB;IACI,QAAQ;AACZ;;AAEA;IACI,OAAO;AACX;;AAEA,uBAAuB;AACvB;IACI,cAAc;IACd,aAAa;IACb,gDAAgD;IAChD,8CAA8C;IAC9C,kBAAkB;IAClB,kBAAkB;AACtB;;AAEA;IACI,kBAAkB;IAClB,iBAAiB;AACrB;;AAEA;IACI,WAAW;IACX,YAAY;IACZ,iCAAiC;IACjC,mBAAmB;IACnB,gBAAgB;AACpB;;AAEA;IACI,YAAY;IACZ,6CAA6C;IAC7C,2BAA2B;AAC/B;;AAEA,yDAAyD;AACzD;IACI,aAAa;IACb,gBAAgB;IAChB,aAAa;IACb,iCAAiC;IACjC,kBAAkB;IAClB,gBAAgB;AACpB;;AAEA;IACI,cAAc;AAClB;;AAEA;IACI,kBAAkB;AACtB;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,iBAAiB;IACjB,kCAAkC;IAClC,iBAAiB;AACrB;;AAEA,2BAA2B;AAC3B;IACI;QACI,sBAAsB;IAC1B;;IAEA;QACI,WAAW;IACf;AACJ;;AAEA,iCAAiC;AACjC;IACI;QACI,UAAU;QACV,4BAA4B;IAChC;IACA;QACI,UAAU;QACV,wBAAwB;IAC5B;AACJ;;AAEA;IACI,2BAA2B;AAC/B;;AAEA,yBAAyB;AACzB;IACI,aAAa;IACb,mBAAmB;IACnB,iCAAiC;AACrC;;AAEA;IACI,mBAAmB;IACnB,kCAAkC;IAClC,gBAAgB;AACpB;;AAEA;IACI,gDAAgD;IAChD,iCAAiC;IACjC,8CAA8C;IAC9C,kBAAkB;IAClB,aAAa;IACb,gBAAgB;AACpB;;AAEA;IACI,aAAa;IACb,sCAAsC;AAC1C;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,kBAAkB;AACtB\",\"sourcesContent\":[\"/* Styles for the Name Tracker extension */\\r\\n\\r\\n.name-tracker-settings {\\r\\n    padding: 5px;\\r\\n}\\r\\n\\r\\n.name-tracker_block {\\r\\n    margin-bottom: 10px;\\r\\n}\\r\\n\\r\\n.name-tracker_block h4 {\\r\\n    margin-top: 10px;\\r\\n    margin-bottom: 10px;\\r\\n    font-weight: bold;\\r\\n}\\r\\n\\r\\n/* Status Display */\\r\\n.name-tracker-status-block {\\r\\n    background-color: var(--SmartThemeBlurTintColor);\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 5px;\\r\\n    padding: 10px;\\r\\n}\\r\\n\\r\\n.name-tracker-status {\\r\\n    font-weight: bold;\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n    padding: 5px;\\r\\n    text-align: center;\\r\\n}\\r\\n\\r\\n/* Character List */\\r\\n.name-tracker-character-list {\\r\\n    max-height: 400px;\\r\\n    overflow-y: auto;\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 5px;\\r\\n    padding: 5px;\\r\\n    margin-top: 5px;\\r\\n}\\r\\n\\r\\n.name-tracker-character {\\r\\n    padding: 10px;\\r\\n    margin-bottom: 10px;\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 5px;\\r\\n    background-color: var(--SmartThemeBlurTintColor);\\r\\n}\\r\\n\\r\\n.name-tracker-character:last-child {\\r\\n    margin-bottom: 0;\\r\\n}\\r\\n\\r\\n/* Active/loaded character styling (characters that are loaded in SillyTavern) */\\r\\n.name-tracker-character.main-character {\\r\\n    border-left: 3px solid #4CAF50;\\r\\n    background-color: rgba(76, 175, 80, 0.05);\\r\\n}\\r\\n\\r\\n.character-header {\\r\\n    display: flex;\\r\\n    justify-content: space-between;\\r\\n    align-items: center;\\r\\n    margin-bottom: 5px;\\r\\n}\\r\\n\\r\\n.character-name {\\r\\n    font-weight: bold;\\r\\n    font-size: 1.1em;\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n}\\r\\n\\r\\n.character-name .fa-user {\\r\\n    color: #4CAF50;\\r\\n    margin-right: 5px;\\r\\n}\\r\\n\\r\\n.character-name.ignored {\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n    text-decoration: line-through;\\r\\n}\\r\\n\\r\\n.character-badge {\\r\\n    display: inline-block;\\r\\n    padding: 2px 8px;\\r\\n    border-radius: 3px;\\r\\n    font-size: 0.75em;\\r\\n    font-weight: bold;\\r\\n    margin-left: 5px;\\r\\n}\\r\\n\\r\\n.character-badge.main-char {\\r\\n    background-color: #4CAF50;\\r\\n    color: #fff;\\r\\n}\\r\\n\\r\\n.character-badge.ignored {\\r\\n    background-color: #666;\\r\\n    color: #fff;\\r\\n}\\r\\n\\r\\n.character-badge.unresolved {\\r\\n    background-color: #ff9800;\\r\\n    color: #000;\\r\\n}\\r\\n\\r\\n/* Lorebook entry editor modal */\\r\\n.lorebook-entry-editor h3 {\\r\\n    margin-top: 0;\\r\\n    margin-bottom: 20px;\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n}\\r\\n\\r\\n.editor-section {\\r\\n    margin-bottom: 15px;\\r\\n}\\r\\n\\r\\n.editor-section label {\\r\\n    display: block;\\r\\n    font-weight: bold;\\r\\n    margin-bottom: 5px;\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n}\\r\\n\\r\\n.editor-section small {\\r\\n    display: block;\\r\\n    margin-top: 3px;\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n    font-size: 0.85em;\\r\\n}\\r\\n\\r\\n.editor-section input,\\r\\n.editor-section textarea {\\r\\n    width: 100%;\\r\\n    box-sizing: border-box;\\r\\n}\\r\\n\\r\\n.character-aliases {\\r\\n    font-size: 0.9em;\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n    margin-bottom: 8px;\\r\\n    font-style: italic;\\r\\n}\\r\\n\\r\\n.lorebook-entry-id {\\r\\n    display: inline-block;\\r\\n    margin-left: 10px;\\r\\n    padding: 2px 6px;\\r\\n    background: var(--SmartThemeBlurTintColor);\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 3px;\\r\\n    font-family: monospace;\\r\\n    font-size: 0.85em;\\r\\n    font-style: normal;\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n}\\r\\n\\r\\n.character-details {\\r\\n    font-size: 0.85em;\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n    margin: 8px 0;\\r\\n    padding: 8px;\\r\\n    background: var(--SmartThemeBlurTintColor);\\r\\n    border-left: 2px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 3px;\\r\\n    line-height: 1.4;\\r\\n}\\r\\n\\r\\n.character-actions {\\r\\n    display: flex;\\r\\n    gap: 5px;\\r\\n    flex-wrap: wrap;\\r\\n    margin-top: 8px;\\r\\n}\\r\\n\\r\\n.character-actions .menu_button {\\r\\n    flex: 1;\\r\\n    min-width: 100px;\\r\\n    padding: 5px 10px;\\r\\n    font-size: 0.9em;\\r\\n}\\r\\n\\r\\n.menu_button.compact {\\r\\n    padding: 5px 10px;\\r\\n    font-size: 0.9em;\\r\\n}\\r\\n\\r\\n.name-tracker-empty {\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n    font-style: italic;\\r\\n    text-align: center;\\r\\n    padding: 20px;\\r\\n}\\r\\n\\r\\n/* Ollama Settings */\\r\\n.ollama-settings {\\r\\n    background-color: var(--SmartThemeBlurTintColor);\\r\\n    border-left: 3px solid var(--SmartThemeBorderColor);\\r\\n    padding: 10px;\\r\\n    margin-top: 5px;\\r\\n    border-radius: 5px;\\r\\n}\\r\\n\\r\\n/* Merge Dialog */\\r\\n.merge-dialog {\\r\\n    padding: 15px;\\r\\n}\\r\\n\\r\\n.merge-dialog p {\\r\\n    margin-bottom: 10px;\\r\\n}\\r\\n\\r\\n.merge-dialog strong {\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n    font-weight: bold;\\r\\n}\\r\\n\\r\\n.merge-warning {\\r\\n    color: #ff9800;\\r\\n    font-size: 0.9em;\\r\\n    margin-top: 10px;\\r\\n    padding: 10px;\\r\\n    background-color: rgba(255, 152, 0, 0.1);\\r\\n    border-left: 3px solid #ff9800;\\r\\n    border-radius: 3px;\\r\\n}\\r\\n\\r\\n/* Button states */\\r\\nbutton:disabled {\\r\\n    opacity: 0.5;\\r\\n    cursor: not-allowed;\\r\\n}\\r\\n\\r\\n/* Flex utilities */\\r\\n.flexGap5 {\\r\\n    gap: 5px;\\r\\n}\\r\\n\\r\\n.flex1 {\\r\\n    flex: 1;\\r\\n}\\r\\n\\r\\n/* Progress indicator */\\r\\n.name-tracker-progress {\\r\\n    margin: 10px 0;\\r\\n    padding: 10px;\\r\\n    background-color: var(--SmartThemeBlurTintColor);\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 5px;\\r\\n    text-align: center;\\r\\n}\\r\\n\\r\\n.name-tracker-progress .progress-text {\\r\\n    margin-bottom: 5px;\\r\\n    font-weight: bold;\\r\\n}\\r\\n\\r\\n.name-tracker-progress .progress-bar {\\r\\n    width: 100%;\\r\\n    height: 20px;\\r\\n    background-color: var(--black50a);\\r\\n    border-radius: 10px;\\r\\n    overflow: hidden;\\r\\n}\\r\\n\\r\\n.name-tracker-progress .progress-fill {\\r\\n    height: 100%;\\r\\n    background-color: var(--SmartThemeQuoteColor);\\r\\n    transition: width 0.3s ease;\\r\\n}\\r\\n\\r\\n/* Character details preview (for potential future use) */\\r\\n.character-details {\\r\\n    display: none;\\r\\n    margin-top: 10px;\\r\\n    padding: 10px;\\r\\n    background-color: var(--black30a);\\r\\n    border-radius: 5px;\\r\\n    font-size: 0.9em;\\r\\n}\\r\\n\\r\\n.character-details.expanded {\\r\\n    display: block;\\r\\n}\\r\\n\\r\\n.character-details-section {\\r\\n    margin-bottom: 8px;\\r\\n}\\r\\n\\r\\n.character-details-section:last-child {\\r\\n    margin-bottom: 0;\\r\\n}\\r\\n\\r\\n.character-details-label {\\r\\n    font-weight: bold;\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n    margin-right: 5px;\\r\\n}\\r\\n\\r\\n/* Responsive adjustments */\\r\\n@media (max-width: 768px) {\\r\\n    .character-actions {\\r\\n        flex-direction: column;\\r\\n    }\\r\\n    \\r\\n    .character-actions .menu_button {\\r\\n        width: 100%;\\r\\n    }\\r\\n}\\r\\n\\r\\n/* Animation for new characters */\\r\\n@keyframes fadeIn {\\r\\n    from {\\r\\n        opacity: 0;\\r\\n        transform: translateY(-10px);\\r\\n    }\\r\\n    to {\\r\\n        opacity: 1;\\r\\n        transform: translateY(0);\\r\\n    }\\r\\n}\\r\\n\\r\\n.name-tracker-character.new {\\r\\n    animation: fadeIn 0.3s ease;\\r\\n}\\r\\n\\r\\n/* System Prompt Editor */\\r\\n.system-prompt-editor h3 {\\r\\n    margin-top: 0;\\r\\n    margin-bottom: 10px;\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n}\\r\\n\\r\\n.system-prompt-editor p {\\r\\n    margin-bottom: 10px;\\r\\n    color: var(--SmartThemeQuoteColor);\\r\\n    font-size: 0.9em;\\r\\n}\\r\\n\\r\\n#system_prompt_editor {\\r\\n    background-color: var(--SmartThemeBlurTintColor);\\r\\n    color: var(--SmartThemeBodyColor);\\r\\n    border: 1px solid var(--SmartThemeBorderColor);\\r\\n    border-radius: 3px;\\r\\n    padding: 10px;\\r\\n    resize: vertical;\\r\\n}\\r\\n\\r\\n#system_prompt_editor:focus {\\r\\n    outline: none;\\r\\n    border-color: var(--SmartThemeEmColor);\\r\\n}\\r\\n\\r\\n.system-prompt-actions button {\\r\\n    min-width: 100px;\\r\\n}\\r\\n\\r\\n#system_prompt_reset {\\r\\n    margin-right: auto;\\r\\n}\\r\\n\\r\\n\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","\"use strict\";\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;","/**\r\n * Debug and logging utilities for Name Tracker extension\r\n * Provides module-specific logging, performance monitoring, and state inspection\r\n */\r\n\r\nconst MODULE_NAME = 'STnametracker';\r\n\r\nclass DebugLogger {\r\n    constructor() {\r\n        this.modules = new Map();\r\n        this.performanceMarks = new Map();\r\n        this.operationTraces = new Map();\r\n    }\r\n\r\n    /**\r\n     * Create a module-specific logger\r\n     * @param {string} moduleName - Name of the module\r\n     * @returns {Object} Logger instance with module-specific methods\r\n     */\r\n    createModuleLogger(moduleName) {\r\n        if (this.modules.has(moduleName)) {\r\n            return this.modules.get(moduleName);\r\n        }\r\n\r\n        const logger = {\r\n            log: (...args) => this.log(moduleName, 'log', ...args),\r\n            warn: (...args) => this.log(moduleName, 'warn', ...args),\r\n            error: (...args) => this.log(moduleName, 'error', ...args),\r\n            debug: (...args) => this.log(moduleName, 'debug', ...args),\r\n            trace: (operationId, message) => this.addTrace(moduleName, operationId, message),\r\n            startTimer: (timerName) => this.startTimer(moduleName, timerName),\r\n            endTimer: (timerName) => this.endTimer(moduleName, timerName),\r\n        };\r\n\r\n        this.modules.set(moduleName, logger);\r\n        return logger;\r\n    }\r\n\r\n    /**\r\n     * Internal logging method\r\n     * @param {string} moduleName - Module name\r\n     * @param {string} level - Log level\r\n     * @param {...any} args - Arguments to log\r\n     */\r\n    log(moduleName, level, ...args) {\r\n        if (!this.isDebugEnabled()) {\r\n            return;\r\n        }\r\n\r\n        const timestamp = new Date().toLocaleTimeString();\r\n        const prefix = `[${MODULE_NAME}:${moduleName}] ${timestamp}`;\r\n\r\n        switch (level) {\r\n            case 'error':\r\n                console.error(prefix, ...args);\r\n                break;\r\n            case 'warn':\r\n                console.warn(prefix, ...args);\r\n                break;\r\n            case 'debug':\r\n                console.debug(prefix, ...args);\r\n                break;\r\n            default:\r\n                console.log(prefix, ...args);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add operation trace for debugging workflows\r\n     * @param {string} moduleName - Module name\r\n     * @param {string} operationId - Unique operation identifier\r\n     * @param {string} message - Trace message\r\n     */\r\n    addTrace(moduleName, operationId, message) {\r\n        if (!this.isDebugEnabled()) {\r\n            return;\r\n        }\r\n\r\n        if (!this.operationTraces.has(operationId)) {\r\n            this.operationTraces.set(operationId, []);\r\n        }\r\n\r\n        this.operationTraces.get(operationId).push({\r\n            module: moduleName,\r\n            timestamp: Date.now(),\r\n            message: message,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get trace history for an operation\r\n     * @param {string} operationId - Operation identifier\r\n     * @returns {Array} Trace entries\r\n     */\r\n    getTrace(operationId) {\r\n        return this.operationTraces.get(operationId) || [];\r\n    }\r\n\r\n    /**\r\n     * Start performance timer\r\n     * @param {string} moduleName - Module name\r\n     * @param {string} timerName - Timer identifier\r\n     */\r\n    startTimer(moduleName, timerName) {\r\n        const key = `${moduleName}:${timerName}`;\r\n        this.performanceMarks.set(key, performance.now());\r\n    }\r\n\r\n    /**\r\n     * End performance timer and log duration\r\n     * @param {string} moduleName - Module name\r\n     * @param {string} timerName - Timer identifier\r\n     * @returns {number} Duration in milliseconds\r\n     */\r\n    endTimer(moduleName, timerName) {\r\n        const key = `${moduleName}:${timerName}`;\r\n        const startTime = this.performanceMarks.get(key);\r\n\r\n        if (startTime === undefined) {\r\n            this.log(moduleName, 'warn', `Timer '${timerName}' was not started`);\r\n            return 0;\r\n        }\r\n\r\n        const duration = performance.now() - startTime;\r\n        this.performanceMarks.delete(key);\r\n\r\n        this.log(moduleName, 'debug', `Timer '${timerName}': ${duration.toFixed(2)}ms`);\r\n        return duration;\r\n    }\r\n\r\n    /**\r\n     * Check if debug mode is enabled\r\n     * @returns {boolean} Debug mode status\r\n     */\r\n    isDebugEnabled() {\r\n        // This will be overridden by main.js to connect to settings\r\n        return true; // Default during initialization\r\n    }\r\n\r\n    /**\r\n     * Clear all traces and performance data\r\n     */\r\n    clear() {\r\n        this.operationTraces.clear();\r\n        this.performanceMarks.clear();\r\n    }\r\n\r\n    /**\r\n     * Get performance summary\r\n     * @returns {Object} Performance statistics\r\n     */\r\n    getPerformanceSummary() {\r\n        return {\r\n            activeTimers: this.performanceMarks.size,\r\n            activeTraces: this.operationTraces.size,\r\n            modules: Array.from(this.modules.keys()),\r\n        };\r\n    }\r\n}\r\n\r\n// Create singleton instance\r\nconst debugLogger = new DebugLogger();\r\n\r\n// Export the instance and key methods for easy access\r\nexport { debugLogger };\r\nexport const createModuleLogger = debugLogger.createModuleLogger.bind(debugLogger);\r\nexport const addTrace = debugLogger.addTrace.bind(debugLogger);\r\nexport const startTimer = debugLogger.startTimer.bind(debugLogger);\r\nexport const endTimer = debugLogger.endTimer.bind(debugLogger);\r\nexport default debugLogger;\r\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};","\"use strict\";\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n  if (!cssMapping) {\n    return content;\n  }\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    return [content].concat([sourceMapping]).join(\"\\n\");\n  }\n  return [content].join(\"\\n\");\n};","/**\r\n * Notification utilities for Name Tracker extension\r\n * Centralizes toastr notifications with consistent styling\r\n */\r\n\r\nimport debugLogger from '../core/debug.js';\r\n\r\nconst logger = debugLogger.createModuleLogger('Notifications');\r\n\r\nclass NotificationManager {\r\n    constructor() {\r\n        this.defaultOptions = {\r\n            timeOut: 5000,\r\n            extendedTimeOut: 2000,\r\n            closeButton: true,\r\n            progressBar: true,\r\n            preventDuplicates: true,\r\n        };\r\n\r\n        this.prefix = 'Name Tracker: ';\r\n    }\r\n\r\n    /**\r\n     * Show success notification\r\n     * @param {string} message - Message to display\r\n     * @param {string} title - Optional title\r\n     * @param {Object} options - Toastr options\r\n     */\r\n    success(message, title = 'Success', options = {}) {\r\n        const opts = { ...this.defaultOptions, ...options };\r\n        toastr.success(this.prefix + message, title, opts);\r\n        logger.debug('Success notification:', message);\r\n    }\r\n\r\n    /**\r\n     * Show info notification\r\n     * @param {string} message - Message to display\r\n     * @param {string} title - Optional title\r\n     * @param {Object} options - Toastr options\r\n     */\r\n    info(message, title = 'Info', options = {}) {\r\n        const opts = { ...this.defaultOptions, ...options };\r\n        toastr.info(this.prefix + message, title, opts);\r\n        logger.debug('Info notification:', message);\r\n    }\r\n\r\n    /**\r\n     * Show warning notification\r\n     * @param {string} message - Message to display\r\n     * @param {string} title - Optional title\r\n     * @param {Object} options - Toastr options\r\n     */\r\n    warning(message, title = 'Warning', options = {}) {\r\n        const opts = { ...this.defaultOptions, timeOut: 8000, ...options };\r\n        toastr.warning(this.prefix + message, title, opts);\r\n        logger.debug('Warning notification:', message);\r\n    }\r\n\r\n    /**\r\n     * Show error notification\r\n     * @param {string} message - Message to display\r\n     * @param {string} title - Optional title\r\n     * @param {Object} options - Toastr options\r\n     */\r\n    error(message, title = 'Error', options = {}) {\r\n        const opts = {\r\n            ...this.defaultOptions,\r\n            timeOut: 10000,\r\n            extendedTimeOut: 5000,\r\n            ...options,\r\n        };\r\n        toastr.error(this.prefix + message, title, opts);\r\n        logger.error('Error notification:', message);\r\n    }\r\n\r\n    /**\r\n     * Show persistent notification that doesn't auto-close\r\n     * @param {string} message - Message to display\r\n     * @param {string} title - Optional title\r\n     * @param {string} type - Notification type (info, success, warning, error)\r\n     */\r\n    persistent(message, title = 'Notice', type = 'info') {\r\n        const opts = {\r\n            ...this.defaultOptions,\r\n            timeOut: 0,\r\n            extendedTimeOut: 0,\r\n        };\r\n\r\n        switch (type) {\r\n            case 'success':\r\n                toastr.success(this.prefix + message, title, opts);\r\n                break;\r\n            case 'warning':\r\n                toastr.warning(this.prefix + message, title, opts);\r\n                break;\r\n            case 'error':\r\n                toastr.error(this.prefix + message, title, opts);\r\n                break;\r\n            default:\r\n                toastr.info(this.prefix + message, title, opts);\r\n        }\r\n\r\n        logger.debug('Persistent notification:', message);\r\n    }\r\n\r\n    /**\r\n     * Show progress notification for long operations\r\n     * @param {string} message - Message to display\r\n     * @param {number} progress - Progress percentage (0-100)\r\n     * @param {string} id - Unique ID for updating the same notification\r\n     * @returns {string} Notification ID for updates\r\n     */\r\n    progress(message, progress = 0, id = null) {\r\n        const notificationId = id || `progress_${Date.now()}`;\r\n        const progressHtml = `\r\n            <div style=\"margin-bottom: 8px;\">${this.prefix}${message}</div>\r\n            <div style=\"background: #333; border-radius: 3px; overflow: hidden;\">\r\n                <div style=\"background: #007acc; height: 6px; width: ${progress}%; transition: width 0.3s ease;\"></div>\r\n            </div>\r\n            <div style=\"text-align: center; font-size: 11px; margin-top: 4px;\">${progress}%</div>\r\n        `;\r\n\r\n        const opts = {\r\n            timeOut: 0,\r\n            extendedTimeOut: 0,\r\n            closeButton: false,\r\n            progressBar: false,\r\n            preventDuplicates: false,\r\n            toastId: notificationId,\r\n        };\r\n\r\n        // Remove existing notification with same ID\r\n        toastr.remove();\r\n\r\n        toastr.info(progressHtml, '', opts);\r\n        logger.debug('Progress notification:', message, `${progress}%`);\r\n\r\n        return notificationId;\r\n    }\r\n\r\n    /**\r\n     * Clear all notifications\r\n     */\r\n    clear() {\r\n        toastr.clear();\r\n        logger.debug('Cleared all notifications');\r\n    }\r\n\r\n    /**\r\n     * Show a confirmation-style notification with action buttons\r\n     * @param {string} message - Message to display\r\n     * @param {Function} onConfirm - Callback for confirm action\r\n     * @param {Function} onCancel - Callback for cancel action\r\n     * @param {string} title - Optional title\r\n     */\r\n    confirm(message, onConfirm, onCancel = null, title = 'Confirm') {\r\n        const confirmId = `confirm_${Date.now()}`;\r\n        const confirmHtml = `\r\n            <div style=\"margin-bottom: 12px;\">${message}</div>\r\n            <div style=\"text-align: right;\">\r\n                <button class=\"btn btn-sm btn-secondary me-2\" onclick=\"nameTrackerNotifications.handleConfirmCancel('${confirmId}')\">Cancel</button>\r\n                <button class=\"btn btn-sm btn-primary\" onclick=\"nameTrackerNotifications.handleConfirmOk('${confirmId}')\">Confirm</button>\r\n            </div>\r\n        `;\r\n\r\n        // Store callbacks globally for onclick handlers\r\n        window.nameTrackerNotifications = window.nameTrackerNotifications || {};\r\n        window.nameTrackerNotifications.confirmCallbacks = window.nameTrackerNotifications.confirmCallbacks || {};\r\n        window.nameTrackerNotifications.confirmCallbacks[confirmId] = { onConfirm, onCancel };\r\n\r\n        window.nameTrackerNotifications.handleConfirmOk = (id) => {\r\n            const callbacks = window.nameTrackerNotifications.confirmCallbacks[id];\r\n            if (callbacks && callbacks.onConfirm) {\r\n                callbacks.onConfirm();\r\n            }\r\n            delete window.nameTrackerNotifications.confirmCallbacks[id];\r\n            toastr.clear();\r\n        };\r\n\r\n        window.nameTrackerNotifications.handleConfirmCancel = (id) => {\r\n            const callbacks = window.nameTrackerNotifications.confirmCallbacks[id];\r\n            if (callbacks && callbacks.onCancel) {\r\n                callbacks.onCancel();\r\n            }\r\n            delete window.nameTrackerNotifications.confirmCallbacks[id];\r\n            toastr.clear();\r\n        };\r\n\r\n        const opts = {\r\n            timeOut: 0,\r\n            extendedTimeOut: 0,\r\n            closeButton: false,\r\n            progressBar: false,\r\n            preventDuplicates: false,\r\n            toastId: confirmId,\r\n        };\r\n\r\n        toastr.info(confirmHtml, this.prefix + title, opts);\r\n        logger.debug('Confirmation notification:', message);\r\n\r\n        return confirmId;\r\n    }\r\n\r\n    /**\r\n     * Get notification status for debugging\r\n     * @returns {Object} Status information\r\n     */\r\n    getStatus() {\r\n        return {\r\n            defaultOptions: this.defaultOptions,\r\n            prefix: this.prefix,\r\n            activeConfirms: Object.keys(window.nameTrackerNotifications?.confirmCallbacks || {}).length,\r\n        };\r\n    }\r\n}\r\n\r\n// Create singleton instance\r\nconst notifications = new NotificationManager();\r\n\r\nlogger.debug('Notifications module loaded');\r\n\r\nexport { NotificationManager };\r\nexport default notifications;\r\n","\"use strict\";\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;","/**\r\n * Centralized settings management for Name Tracker extension\r\n * Handles both global extension settings and chat-level data persistence\r\n */\r\n\r\nimport debugLogger from './debug.js';\r\nimport { errorHandler } from './errors.js';\r\nimport sillyTavernContext from './context.js';\r\n\r\nconst logger = debugLogger.createModuleLogger('Settings');\r\n\r\nconst EXTENSION_NAME = 'STnametracker';\r\n\r\n// Default settings structure\r\nconst DEFAULT_SETTINGS = Object.freeze({\r\n    enabled: true,\r\n    autoAnalyze: true,\r\n    messageFrequency: 10,\r\n    llmSource: 'sillytavern', // 'sillytavern' or 'ollama'\r\n    ollamaEndpoint: 'http://localhost:11434',\r\n    ollamaModel: '',\r\n    confidenceThreshold: 70,\r\n    lorebookPosition: 0, // after character defs\r\n    lorebookDepth: 1,\r\n    lorebookCooldown: 5,\r\n    lorebookScanDepth: 1,\r\n    lorebookProbability: 100,\r\n    lorebookEnabled: true,\r\n    debugMode: false,\r\n    systemPrompt: null, // null means use default\r\n});\r\n\r\n// Default chat-level data structure\r\nconst DEFAULT_CHAT_DATA = Object.freeze({\r\n    characters: {}, // character data indexed by preferred name\r\n    messageCounter: 0,\r\n    lastHarvestMessage: 0,\r\n    lastScannedMessageId: -1, // Track last scanned message by ID\r\n});\r\n\r\nclass SettingsManager {\r\n    constructor() {\r\n        this._settings = null;\r\n        this._chatData = null;\r\n        this._settingsCallbacks = [];\r\n        this._chatCallbacks = [];\r\n        this._saveTimeout = null;\r\n        this._initialized = false;\r\n    }\r\n\r\n    /**\r\n     * Initialize settings system\r\n     * @returns {Promise<void>}\r\n     */\r\n    async initialize() {\r\n        console.log('[STnametracker] SettingsManager.initialize: Starting...');\r\n        return errorHandler.withErrorBoundary('Settings', async () => {\r\n            console.log('[STnametracker] SettingsManager.initialize: Inside error boundary');\r\n            if (this._initialized) {\r\n                console.log('[STnametracker] SettingsManager.initialize: Already initialized');\r\n                return;\r\n            }\r\n\r\n            console.log('[STnametracker] SettingsManager.initialize: Initializing settings manager');\r\n            logger.debug('Initializing settings manager');\r\n\r\n            // Load global settings\r\n            console.log('[STnametracker] SettingsManager.initialize: Loading global settings...');\r\n            await this.loadSettings();\r\n            console.log('[STnametracker] SettingsManager.initialize: Global settings loaded');\r\n\r\n            // Load chat-level data\r\n            console.log('[STnametracker] SettingsManager.initialize: Loading chat data...');\r\n            await this.loadChatData();\r\n            console.log('[STnametracker] SettingsManager.initialize: Chat data loaded');\r\n\r\n            this._initialized = true;\r\n            console.log('[STnametracker] SettingsManager.initialize: Marked as initialized');\r\n            logger.debug('Settings manager initialized');\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load global extension settings\r\n     * @returns {Promise<void>}\r\n     */\r\n    async loadSettings() {\r\n        return errorHandler.withErrorBoundary('Settings', async () => {\r\n            const extensionSettings = sillyTavernContext.getExtensionSettings();\r\n\r\n            // Initialize with defaults if not exists\r\n            if (!extensionSettings[EXTENSION_NAME]) {\r\n                extensionSettings[EXTENSION_NAME] = {};\r\n            }\r\n\r\n            // Merge with defaults to ensure all properties exist\r\n            this._settings = { ...DEFAULT_SETTINGS };\r\n            Object.assign(this._settings, extensionSettings[EXTENSION_NAME]);\r\n\r\n            // Update the reference in SillyTavern\r\n            extensionSettings[EXTENSION_NAME] = this._settings;\r\n\r\n            logger.debug('Loaded global settings:', Object.keys(this._settings));\r\n\r\n            // Trigger callbacks\r\n            this._settingsCallbacks.forEach(callback => {\r\n                try {\r\n                    callback(this._settings);\r\n                } catch (error) {\r\n                    logger.error('Settings callback error:', error);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load chat-level data from metadata\r\n     * @returns {Promise<void>}\r\n     */\r\n    async loadChatData() {\r\n        return errorHandler.withErrorBoundary('Settings', async () => {\r\n            const chatMetadata = sillyTavernContext.getChatMetadata();\r\n\r\n            // Initialize chat data if not exists\r\n            if (!chatMetadata[EXTENSION_NAME]) {\r\n                this._chatData = { ...DEFAULT_CHAT_DATA };\r\n                chatMetadata[EXTENSION_NAME] = this._chatData;\r\n                logger.debug('Initialized new chat data');\r\n            } else {\r\n                // Merge with defaults to ensure all properties exist\r\n                this._chatData = { ...DEFAULT_CHAT_DATA };\r\n                Object.assign(this._chatData, chatMetadata[EXTENSION_NAME]);\r\n                chatMetadata[EXTENSION_NAME] = this._chatData;\r\n                logger.debug('Loaded existing chat data:', Object.keys(this._chatData.characters));\r\n            }\r\n\r\n            // Trigger callbacks\r\n            this._chatCallbacks.forEach(callback => {\r\n                try {\r\n                    callback(this._chatData);\r\n                } catch (error) {\r\n                    logger.error('Chat data callback error:', error);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get current settings object\r\n     * @returns {Object} Current settings\r\n     */\r\n    getSettings() {\r\n        if (!this._initialized) {\r\n            throw new Error('Settings manager not initialized');\r\n        }\r\n        return this._settings;\r\n    }\r\n\r\n    /**\r\n     * Get current chat data\r\n     * @returns {Object} Current chat data\r\n     */\r\n    getChatData() {\r\n        if (!this._initialized) {\r\n            throw new Error('Settings manager not initialized');\r\n        }\r\n        return this._chatData;\r\n    }\r\n\r\n    /**\r\n     * Update a setting value\r\n     * @param {string} key - Setting key\r\n     * @param {any} value - New value\r\n     * @returns {Promise<void>}\r\n     */\r\n    async updateSetting(key, value) {\r\n        return errorHandler.withErrorBoundary('Settings', async () => {\r\n            if (!this._initialized) {\r\n                throw new Error('Settings manager not initialized');\r\n            }\r\n\r\n            if (!(key in DEFAULT_SETTINGS)) {\r\n                throw new Error(`Unknown setting key: ${key}`);\r\n            }\r\n\r\n            const oldValue = this._settings[key];\r\n            this._settings[key] = value;\r\n\r\n            logger.debug(`Updated setting ${key}: ${oldValue}  ${value}`);\r\n\r\n            // Trigger callbacks\r\n            this._settingsCallbacks.forEach(callback => {\r\n                try {\r\n                    callback(this._settings, key, value, oldValue);\r\n                } catch (error) {\r\n                    logger.error('Settings callback error:', error);\r\n                }\r\n            });\r\n\r\n            // Save with debounce\r\n            await this.saveSettings();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Update chat data\r\n     * @param {string} key - Data key\r\n     * @param {any} value - New value\r\n     * @returns {Promise<void>}\r\n     */\r\n    async updateChatData(key, value) {\r\n        return errorHandler.withErrorBoundary('Settings', async () => {\r\n            if (!this._initialized) {\r\n                throw new Error('Settings manager not initialized');\r\n            }\r\n\r\n            if (!(key in DEFAULT_CHAT_DATA)) {\r\n                throw new Error(`Unknown chat data key: ${key}`);\r\n            }\r\n\r\n            const oldValue = this._chatData[key];\r\n            this._chatData[key] = value;\r\n\r\n            logger.debug(`Updated chat data ${key}`);\r\n\r\n            // Trigger callbacks\r\n            this._chatCallbacks.forEach(callback => {\r\n                try {\r\n                    callback(this._chatData, key, value, oldValue);\r\n                } catch (error) {\r\n                    logger.error('Chat data callback error:', error);\r\n                }\r\n            });\r\n\r\n            // Save with debounce\r\n            await this.saveChatData();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get specific setting value\r\n     * @param {string} key - Setting key\r\n     * @param {any} defaultValue - Default if not found\r\n     * @returns {any} Setting value\r\n     */\r\n    getSetting(key, defaultValue = undefined) {\r\n        if (!this._initialized) {\r\n            return defaultValue;\r\n        }\r\n        return this._settings[key] ?? defaultValue;\r\n    }\r\n\r\n    /**\r\n     * Save global settings to SillyTavern\r\n     * @returns {Promise<void>}\r\n     */\r\n    async saveSettings() {\r\n        if (this._saveTimeout) {\r\n            clearTimeout(this._saveTimeout);\r\n        }\r\n\r\n        this._saveTimeout = setTimeout(async () => {\r\n            await errorHandler.withErrorBoundary('Settings', async () => {\r\n                await sillyTavernContext.saveExtensionSettings();\r\n                logger.debug('Saved global settings');\r\n            }, { silent: true });\r\n        }, 500); // Debounce 500ms\r\n    }\r\n\r\n    /**\r\n     * Save chat data to metadata\r\n     * @returns {Promise<void>}\r\n     */\r\n    async saveChatData() {\r\n        return errorHandler.withErrorBoundary('Settings', async () => {\r\n            await sillyTavernContext.saveChatMetadata();\r\n            logger.debug('Saved chat metadata');\r\n        }, { silent: true });\r\n    }\r\n\r\n    /**\r\n     * Register callback for settings changes\r\n     * @param {Function} callback - Callback function\r\n     */\r\n    onSettingsChange(callback) {\r\n        this._settingsCallbacks.push(callback);\r\n    }\r\n\r\n    /**\r\n     * Register callback for chat data changes\r\n     * @param {Function} callback - Callback function\r\n     */\r\n    onChatDataChange(callback) {\r\n        this._chatCallbacks.push(callback);\r\n    }\r\n\r\n    /**\r\n     * Handle chat change event\r\n     * @returns {Promise<void>}\r\n     */\r\n    async onChatChanged() {\r\n        return errorHandler.withErrorBoundary('Settings', async () => {\r\n            logger.debug('Chat changed, reloading chat data');\r\n            await this.loadChatData();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if extension is enabled\r\n     * @returns {boolean} Enabled status\r\n     */\r\n    isEnabled() {\r\n        return this.getSetting('enabled', false);\r\n    }\r\n\r\n    /**\r\n     * Check if debug mode is enabled\r\n     * @returns {boolean} Debug mode status\r\n     */\r\n    isDebugMode() {\r\n        return this.getSetting('debugMode', false);\r\n    }\r\n\r\n    /**\r\n     * Get auto-analysis settings\r\n     * @returns {Object} Auto-analysis configuration\r\n     */\r\n    getAutoAnalysisConfig() {\r\n        return {\r\n            enabled: this.getSetting('autoAnalyze', false),\r\n            frequency: this.getSetting('messageFrequency', 10),\r\n            lastScanned: this._chatData?.lastScannedMessageId ?? -1,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get LLM configuration\r\n     * @returns {Object} LLM settings\r\n     */\r\n    getLLMConfig() {\r\n        return {\r\n            source: this.getSetting('llmSource', 'sillytavern'),\r\n            ollamaEndpoint: this.getSetting('ollamaEndpoint', 'http://localhost:11434'),\r\n            ollamaModel: this.getSetting('ollamaModel', ''),\r\n            systemPrompt: this.getSetting('systemPrompt'),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get lorebook configuration\r\n     * @returns {Object} Lorebook settings\r\n     */\r\n    getLorebookConfig() {\r\n        return {\r\n            position: this.getSetting('lorebookPosition', 0),\r\n            depth: this.getSetting('lorebookDepth', 1),\r\n            cooldown: this.getSetting('lorebookCooldown', 5),\r\n            scanDepth: this.getSetting('lorebookScanDepth', 1),\r\n            probability: this.getSetting('lorebookProbability', 100),\r\n            enabled: this.getSetting('lorebookEnabled', true),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Reset to default settings\r\n     * @returns {Promise<void>}\r\n     */\r\n    async reset() {\r\n        return errorHandler.withErrorBoundary('Settings', async () => {\r\n            logger.warn('Resetting settings to defaults');\r\n\r\n            Object.assign(this._settings, DEFAULT_SETTINGS);\r\n            Object.assign(this._chatData, DEFAULT_CHAT_DATA);\r\n\r\n            await this.saveSettings();\r\n            await this.saveChatData();\r\n\r\n            // Trigger callbacks\r\n            this._settingsCallbacks.forEach(callback => {\r\n                try {\r\n                    callback(this._settings);\r\n                } catch (error) {\r\n                    logger.error('Settings callback error:', error);\r\n                }\r\n            });\r\n\r\n            this._chatCallbacks.forEach(callback => {\r\n                try {\r\n                    callback(this._chatData);\r\n                } catch (error) {\r\n                    logger.error('Chat data callback error:', error);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get settings status for debugging\r\n     * @returns {Object} Settings status\r\n     */\r\n    getStatus() {\r\n        return {\r\n            initialized: this._initialized,\r\n            settingsLoaded: !!this._settings,\r\n            chatDataLoaded: !!this._chatData,\r\n            charactersCount: Object.keys(this._chatData?.characters || {}).length,\r\n            callbacks: {\r\n                settings: this._settingsCallbacks.length,\r\n                chatData: this._chatCallbacks.length,\r\n            },\r\n        };\r\n    }\r\n}\r\n\r\n// Create singleton instance\r\nconst settingsManager = new SettingsManager();\r\n\r\nexport { settingsManager as settings };\r\nexport default settingsManager;\r\n","\"use strict\";\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;","/**\r\n * Character Management Module\r\n *\r\n * Handles character CRUD operations, merging, alias detection, and relationship management\r\n * for the Name Tracker extension.\r\n */\r\n\r\nimport { createModuleLogger } from '../core/debug.js';\r\nimport { withErrorBoundary, NameTrackerError } from '../core/errors.js';\r\nimport { settings } from '../core/settings.js';\r\nimport { NotificationManager } from '../utils/notifications.js';\r\n\r\nconst debug = createModuleLogger('characters');\r\nconst notifications = new NotificationManager('Character Management');\r\n\r\n// Character management state\r\nlet undoHistory = []; // Store last 3 merge operations\r\n\r\n/**\r\n * Character data structure\r\n * @typedef {Object} CharacterData\r\n * @property {string} preferredName - The preferred/canonical name\r\n * @property {string[]} aliases - List of alternative names\r\n * @property {string} physicalAge - Physical age description\r\n * @property {string} mentalAge - Mental age description\r\n * @property {string} physical - Physical description\r\n * @property {string} personality - Personality traits\r\n * @property {string} sexuality - Sexual orientation/preferences\r\n * @property {string} raceEthnicity - Race/ethnicity information\r\n * @property {string} roleSkills - Role and skills description\r\n * @property {string} lastInteraction - Last interaction with user\r\n * @property {string[]} relationships - Relationships with other characters\r\n * @property {boolean} ignored - Whether character is ignored\r\n * @property {number} confidence - Confidence score (0-100)\r\n * @property {string|null} lorebookEntryId - Associated lorebook entry ID\r\n * @property {number} lastUpdated - Timestamp of last update\r\n * @property {boolean} isMainChar - Whether this is the main character\r\n */\r\n\r\n/**\r\n * Check if a character is in the ignored list\r\n * @param {string} name - Character name to check\r\n * @returns {boolean} True if character is ignored\r\n */\r\nexport function isIgnoredCharacter(name) {\r\n    return withErrorBoundary('isIgnoredCharacter', () => {\r\n        const chars = settings.getCharacters();\r\n        return Object.values(chars).some(\r\n            char => char.ignored && (char.preferredName === name || char.aliases.includes(name)),\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Find existing character by name or alias\r\n * @param {string} name - Name to search for\r\n * @returns {CharacterData|null} Character data if found, null otherwise\r\n */\r\nexport function findExistingCharacter(name) {\r\n    return withErrorBoundary('findExistingCharacter', () => {\r\n        const chars = settings.getCharacters();\r\n        return Object.values(chars).find(\r\n            char => char.preferredName === name || char.aliases.includes(name),\r\n        ) || null;\r\n    });\r\n}\r\n\r\n/**\r\n * Find potential match for a new character based on confidence threshold\r\n * @param {Object} analyzedChar - Character data from LLM analysis\r\n * @returns {Promise<CharacterData|null>} Potential match if found\r\n */\r\nexport async function findPotentialMatch(analyzedChar) {\r\n    return withErrorBoundary('findPotentialMatch', async () => {\r\n        const chars = settings.getCharacters();\r\n        const threshold = settings.getSetting('confidenceThreshold', 70);\r\n\r\n        debug('Searching for potential match with threshold:', threshold);\r\n\r\n        // Simple matching logic - can be enhanced with LLM-based similarity\r\n        for (const existingChar of Object.values(chars)) {\r\n            // Check for name similarity (simple approach)\r\n            const similarity = calculateNameSimilarity(analyzedChar.name, existingChar.preferredName);\r\n\r\n            if (similarity >= threshold) {\r\n                debug('Found name similarity match:', similarity);\r\n                return existingChar;\r\n            }\r\n\r\n            // Check aliases\r\n            for (const alias of existingChar.aliases) {\r\n                const aliasSimilarity = calculateNameSimilarity(analyzedChar.name, alias);\r\n                if (aliasSimilarity >= threshold) {\r\n                    debug('Found alias similarity match:', aliasSimilarity);\r\n                    return existingChar;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    });\r\n}\r\n\r\n/**\r\n * Calculate simple name similarity (0-100)\r\n * @param {string} name1 - First name to compare\r\n * @param {string} name2 - Second name to compare\r\n * @returns {number} Similarity score 0-100\r\n */\r\nexport function calculateNameSimilarity(name1, name2) {\r\n    return withErrorBoundary('calculateNameSimilarity', () => {\r\n        name1 = name1.toLowerCase();\r\n        name2 = name2.toLowerCase();\r\n\r\n        // Exact match\r\n        if (name1 === name2) {\r\n            return 100;\r\n        }\r\n\r\n        // One contains the other\r\n        if (name1.includes(name2) || name2.includes(name1)) {\r\n            return 85;\r\n        }\r\n\r\n        // Check if they share significant parts\r\n        const words1 = name1.split(/\\s+/);\r\n        const words2 = name2.split(/\\s+/);\r\n\r\n        const commonWords = words1.filter(w => words2.includes(w));\r\n        if (commonWords.length > 0) {\r\n            return 70;\r\n        }\r\n\r\n        // No significant similarity\r\n        return 0;\r\n    });\r\n}\r\n\r\n/**\r\n * Filter and clean aliases\r\n * Removes character's own name, relationship words, and other invalid aliases\r\n * @param {string[]} aliases - Array of alias strings\r\n * @param {string} characterName - The character's actual name\r\n * @returns {string[]} Cleaned array of unique aliases\r\n */\r\nexport function cleanAliases(aliases, characterName) {\r\n    return withErrorBoundary('cleanAliases', () => {\r\n        if (!aliases || !Array.isArray(aliases)) {\r\n            return [];\r\n        }\r\n\r\n        // Common relationship/role words that shouldn't be aliases\r\n        const invalidAliases = [\r\n            'son', 'daughter', 'mother', 'father', 'mom', 'dad', 'parent',\r\n            'brother', 'sister', 'sibling', 'cousin', 'uncle', 'aunt',\r\n            'friend', 'boyfriend', 'girlfriend', 'husband', 'wife', 'spouse',\r\n            'boss', 'employee', 'coworker', 'colleague', 'partner',\r\n            'neighbor', 'roommate', 'child', 'kid', 'baby',\r\n            'man', 'woman', 'person', 'guy', 'girl', 'boy',\r\n            'user', '{{user}}', 'char', '{{char}}',\r\n        ];\r\n\r\n        const lowerName = characterName.toLowerCase();\r\n\r\n        return aliases.filter(alias => {\r\n            if (!alias || typeof alias !== 'string') return false;\r\n\r\n            const lowerAlias = alias.trim().toLowerCase();\r\n\r\n            // Remove if it's the character's own name\r\n            if (lowerAlias === lowerName) return false;\r\n\r\n            // Remove if it's just a relationship word\r\n            if (invalidAliases.includes(lowerAlias)) return false;\r\n\r\n            // Remove if it's too short (likely not a real alias)\r\n            if (lowerAlias.length < 2) return false;\r\n\r\n            return true;\r\n        })\r\n            .map(alias => alias.trim()) // Trim whitespace\r\n            .filter((alias, index, self) => self.indexOf(alias) === index); // Remove duplicates\r\n    });\r\n}\r\n\r\n/**\r\n * Create a new character entry\r\n * @param {Object} analyzedChar - Character data from LLM analysis\r\n * @param {boolean} isMainChar - Whether this is the main character\r\n * @returns {Promise<CharacterData>} Created character data\r\n */\r\nexport async function createCharacter(analyzedChar, isMainChar = false) {\r\n    return withErrorBoundary('createCharacter', async () => {\r\n        debug('Creating character with data:', analyzedChar);\r\n\r\n        // Clean and filter aliases\r\n        const aliases = cleanAliases(analyzedChar.aliases || [], analyzedChar.name);\r\n\r\n        const character = {\r\n            preferredName: analyzedChar.name,\r\n            aliases: aliases,\r\n            physicalAge: analyzedChar.physicalAge || '',\r\n            mentalAge: analyzedChar.mentalAge || '',\r\n            physical: analyzedChar.physical || '',\r\n            personality: analyzedChar.personality || '',\r\n            sexuality: analyzedChar.sexuality || '',\r\n            raceEthnicity: analyzedChar.raceEthnicity || '',\r\n            roleSkills: analyzedChar.roleSkills || '',\r\n            lastInteraction: analyzedChar.lastInteraction || '',\r\n            relationships: analyzedChar.relationships || [],\r\n            ignored: false,\r\n            confidence: analyzedChar.confidence || 50,\r\n            lorebookEntryId: null,\r\n            lastUpdated: Date.now(),\r\n            isMainChar: isMainChar || false,\r\n        };\r\n\r\n        debug('Created character object:', character);\r\n\r\n        // Store character in settings\r\n        settings.setCharacter(character.preferredName, character);\r\n\r\n        debug(`Created new character: ${character.preferredName}${isMainChar ? ' (MAIN CHARACTER)' : ''}`);\r\n\r\n        return character;\r\n    });\r\n}\r\n\r\n/**\r\n * Update existing character with new information\r\n * @param {CharacterData} existingChar - Existing character data\r\n * @param {Object} analyzedChar - New character data from LLM analysis\r\n * @param {boolean} addAsAlias - Whether to add the analyzed name as an alias\r\n * @param {boolean} isMainChar - Whether this is the main character\r\n * @returns {Promise<CharacterData>} Updated character data\r\n */\r\nexport async function updateCharacter(existingChar, analyzedChar, addAsAlias = false, isMainChar = false) {\r\n    return withErrorBoundary('updateCharacter', async () => {\r\n        debug('Updating character:', existingChar.preferredName, 'with:', analyzedChar);\r\n\r\n        // Mark as main character if detected\r\n        if (isMainChar) {\r\n            existingChar.isMainChar = true;\r\n        }\r\n\r\n        // If adding as alias, add the analyzed name to aliases if not already present\r\n        if (addAsAlias && analyzedChar.name !== existingChar.preferredName) {\r\n            if (!existingChar.aliases) existingChar.aliases = [];\r\n            if (!existingChar.aliases.includes(analyzedChar.name) &&\r\n                analyzedChar.name.toLowerCase() !== existingChar.preferredName.toLowerCase()) {\r\n                existingChar.aliases.push(analyzedChar.name);\r\n            }\r\n        }\r\n\r\n        // Clean up all aliases using the helper function\r\n        existingChar.aliases = cleanAliases(existingChar.aliases || [], existingChar.preferredName);\r\n\r\n        // Update consolidated fields (new data takes precedence if not empty)\r\n        if (analyzedChar.physicalAge) existingChar.physicalAge = analyzedChar.physicalAge;\r\n        if (analyzedChar.mentalAge) existingChar.mentalAge = analyzedChar.mentalAge;\r\n        if (analyzedChar.physical) existingChar.physical = analyzedChar.physical;\r\n        if (analyzedChar.personality) existingChar.personality = analyzedChar.personality;\r\n        if (analyzedChar.sexuality) existingChar.sexuality = analyzedChar.sexuality;\r\n        if (analyzedChar.raceEthnicity) existingChar.raceEthnicity = analyzedChar.raceEthnicity;\r\n        if (analyzedChar.roleSkills) existingChar.roleSkills = analyzedChar.roleSkills;\r\n\r\n        // lastInteraction is always updated (most recent)\r\n        if (analyzedChar.lastInteraction) existingChar.lastInteraction = analyzedChar.lastInteraction;\r\n\r\n        // Merge relationships array - deduplicate\r\n        if (analyzedChar.relationships && Array.isArray(analyzedChar.relationships)) {\r\n            if (!existingChar.relationships) existingChar.relationships = [];\r\n            for (const rel of analyzedChar.relationships) {\r\n                if (!existingChar.relationships.includes(rel)) {\r\n                    existingChar.relationships.push(rel);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update confidence (average of old and new)\r\n        if (analyzedChar.confidence) {\r\n            existingChar.confidence = Math.round((existingChar.confidence + analyzedChar.confidence) / 2);\r\n        }\r\n\r\n        existingChar.lastUpdated = Date.now();\r\n\r\n        // Update character in settings\r\n        settings.setCharacter(existingChar.preferredName, existingChar);\r\n\r\n        debug(`Updated character: ${existingChar.preferredName}`);\r\n\r\n        return existingChar;\r\n    });\r\n}\r\n\r\n/**\r\n * Merge two characters\r\n * @param {string} sourceName - Name of character to merge from\r\n * @param {string} targetName - Name of character to merge into\r\n * @returns {Promise<void>}\r\n */\r\nexport async function mergeCharacters(sourceName, targetName) {\r\n    return withErrorBoundary('mergeCharacters', async () => {\r\n        const chars = settings.getCharacters();\r\n\r\n        const sourceChar = chars[sourceName];\r\n        const targetChar = chars[targetName];\r\n\r\n        if (!sourceChar || !targetChar) {\r\n            throw new NameTrackerError('One or both characters not found');\r\n        }\r\n\r\n        // Store for undo\r\n        const undoData = {\r\n            operation: 'merge',\r\n            timestamp: Date.now(),\r\n            sourceName: sourceName,\r\n            targetName: targetName,\r\n            sourceData: JSON.parse(JSON.stringify(sourceChar)),\r\n            targetDataBefore: JSON.parse(JSON.stringify(targetChar)),\r\n        };\r\n\r\n        // Add to undo history\r\n        undoHistory.push(undoData);\r\n        if (undoHistory.length > 3) {\r\n            undoHistory.shift();\r\n        }\r\n\r\n        // Merge aliases\r\n        for (const alias of sourceChar.aliases) {\r\n            if (!targetChar.aliases.includes(alias)) {\r\n                targetChar.aliases.push(alias);\r\n            }\r\n        }\r\n\r\n        // Add source name as alias if not the same\r\n        if (sourceChar.preferredName !== targetChar.preferredName &&\r\n            !targetChar.aliases.includes(sourceChar.preferredName)) {\r\n            targetChar.aliases.push(sourceChar.preferredName);\r\n        }\r\n\r\n        // Merge fields (target takes precedence for conflicts, but add new fields)\r\n        if (sourceChar.physicalAge && !targetChar.physicalAge) targetChar.physicalAge = sourceChar.physicalAge;\r\n        if (sourceChar.mentalAge && !targetChar.mentalAge) targetChar.mentalAge = sourceChar.mentalAge;\r\n        if (sourceChar.physical && !targetChar.physical) targetChar.physical = sourceChar.physical;\r\n        if (sourceChar.personality && !targetChar.personality) targetChar.personality = sourceChar.personality;\r\n        if (sourceChar.sexuality && !targetChar.sexuality) targetChar.sexuality = sourceChar.sexuality;\r\n        if (sourceChar.raceEthnicity && !targetChar.raceEthnicity) targetChar.raceEthnicity = sourceChar.raceEthnicity;\r\n        if (sourceChar.roleSkills && !targetChar.roleSkills) targetChar.roleSkills = sourceChar.roleSkills;\r\n        if (sourceChar.lastInteraction && !targetChar.lastInteraction) targetChar.lastInteraction = sourceChar.lastInteraction;\r\n\r\n        // Merge relationships\r\n        for (const rel of sourceChar.relationships) {\r\n            if (!targetChar.relationships.includes(rel)) {\r\n                targetChar.relationships.push(rel);\r\n            }\r\n        }\r\n\r\n        // Update timestamp\r\n        targetChar.lastUpdated = Date.now();\r\n\r\n        // Update target character and delete source\r\n        settings.setCharacter(targetChar.preferredName, targetChar);\r\n        settings.removeCharacter(sourceName);\r\n\r\n        debug(`Merged ${sourceName} into ${targetName}`);\r\n        notifications.success(`Merged ${sourceName} into ${targetName}`);\r\n\r\n        return undoData;\r\n    });\r\n}\r\n\r\n/**\r\n * Undo last merge operation\r\n * @returns {Promise<boolean>} True if undo was successful\r\n */\r\nexport async function undoLastMerge() {\r\n    return withErrorBoundary('undoLastMerge', async () => {\r\n        if (undoHistory.length === 0) {\r\n            notifications.warning('No merge operations to undo');\r\n            return false;\r\n        }\r\n\r\n        const lastOp = undoHistory.pop();\r\n\r\n        if (lastOp.operation !== 'merge') {\r\n            notifications.error('Last operation was not a merge');\r\n            return false;\r\n        }\r\n\r\n        // Restore source character\r\n        settings.setCharacter(lastOp.sourceName, lastOp.sourceData);\r\n\r\n        // Restore target character to pre-merge state\r\n        settings.setCharacter(lastOp.targetName, lastOp.targetDataBefore);\r\n\r\n        debug('Merge undone successfully');\r\n        notifications.success('Merge undone successfully');\r\n\r\n        return true;\r\n    });\r\n}\r\n\r\n/**\r\n * Toggle ignore status for a character\r\n * @param {string} characterName - Name of character to toggle\r\n * @returns {boolean} New ignore status\r\n */\r\nexport function toggleIgnoreCharacter(characterName) {\r\n    return withErrorBoundary('toggleIgnoreCharacter', () => {\r\n        const character = settings.getCharacter(characterName);\r\n\r\n        if (!character) {\r\n            throw new NameTrackerError('Character not found');\r\n        }\r\n\r\n        character.ignored = !character.ignored;\r\n\r\n        settings.setCharacter(characterName, character);\r\n\r\n        const status = character.ignored ? 'ignored' : 'unignored';\r\n        notifications.info(`${characterName} ${status}`);\r\n        debug(`Character ${characterName} ${status}`);\r\n\r\n        return character.ignored;\r\n    });\r\n}\r\n\r\n/**\r\n * Manually create a new character\r\n * @param {string} characterName - Name of new character\r\n * @returns {Promise<CharacterData>} Created character\r\n */\r\nexport async function createNewCharacter(characterName) {\r\n    return withErrorBoundary('createNewCharacter', async () => {\r\n        if (!characterName || !characterName.trim()) {\r\n            throw new NameTrackerError('Character name is required');\r\n        }\r\n\r\n        const trimmedName = characterName.trim();\r\n\r\n        // Check if character already exists\r\n        if (settings.getCharacter(trimmedName)) {\r\n            throw new NameTrackerError(`Character \"${trimmedName}\" already exists`);\r\n        }\r\n\r\n        // Create basic character structure\r\n        const newChar = {\r\n            name: trimmedName,\r\n            aliases: [],\r\n            physicalAge: '',\r\n            mentalAge: '',\r\n            physical: '',\r\n            personality: '',\r\n            sexuality: '',\r\n            raceEthnicity: '',\r\n            roleSkills: '',\r\n            lastInteraction: '',\r\n            relationships: [],\r\n            confidence: 100, // Manually created = 100% confidence\r\n        };\r\n\r\n        const character = await createCharacter(newChar, false);\r\n\r\n        debug(`Manually created character: ${trimmedName}`);\r\n        notifications.success(`Created character: ${trimmedName}`);\r\n\r\n        return character;\r\n    });\r\n}\r\n\r\n/**\r\n * Purge all character entries\r\n * @returns {Promise<number>} Number of characters purged\r\n */\r\nexport async function purgeAllCharacters() {\r\n    return withErrorBoundary('purgeAllCharacters', async () => {\r\n        const chars = settings.getCharacters();\r\n        const characterCount = Object.keys(chars).length;\r\n\r\n        if (characterCount === 0) {\r\n            notifications.info('No characters to purge');\r\n            return 0;\r\n        }\r\n\r\n        // Clear all character data\r\n        settings.clearAllCharacters();\r\n\r\n        // Clear undo history\r\n        undoHistory = [];\r\n\r\n        debug(`Purged ${characterCount} characters`);\r\n        notifications.success(`Purged ${characterCount} characters`);\r\n\r\n        return characterCount;\r\n    });\r\n}\r\n\r\n/**\r\n * Check if character has unresolved relationships\r\n * @param {CharacterData} character - Character to check\r\n * @returns {boolean} True if character has relationships to unknown characters\r\n */\r\nexport function hasUnresolvedRelationships(character) {\r\n    return withErrorBoundary('hasUnresolvedRelationships', () => {\r\n        if (!character.relationships || character.relationships.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        const chars = settings.getCharacters();\r\n        const knownNames = Object.values(chars).reduce((names, char) => {\r\n            names.add(char.preferredName.toLowerCase());\r\n            char.aliases.forEach(alias => names.add(alias.toLowerCase()));\r\n            return names;\r\n        }, new Set());\r\n\r\n        return character.relationships.some(rel => {\r\n            // Simple check - extract character names from relationship strings\r\n            const words = rel.toLowerCase().split(/\\s+/);\r\n            return words.some(word => {\r\n                return word.length > 2 && !knownNames.has(word);\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * Get undo history\r\n * @returns {Array} Array of undo operations\r\n */\r\nexport function getUndoHistory() {\r\n    return [...undoHistory];\r\n}\r\n\r\n/**\r\n * Clear undo history\r\n */\r\nexport function clearUndoHistory() {\r\n    undoHistory = [];\r\n    debug('Undo history cleared');\r\n}\r\n\r\n/**\r\n * Export all characters as JSON\r\n * @returns {Object} Character data\r\n */\r\nexport function exportCharacters() {\r\n    return withErrorBoundary('exportCharacters', () => {\r\n        return settings.getCharacters();\r\n    });\r\n}\r\n\r\n/**\r\n * Import characters from JSON\r\n * @param {Object} characterData - Character data to import\r\n * @param {boolean} merge - Whether to merge with existing characters\r\n * @returns {Promise<number>} Number of characters imported\r\n */\r\nexport async function importCharacters(characterData, merge = false) {\r\n    return withErrorBoundary('importCharacters', async () => {\r\n        if (!characterData || typeof characterData !== 'object') {\r\n            throw new NameTrackerError('Invalid character data');\r\n        }\r\n\r\n        let importCount = 0;\r\n\r\n        for (const [name, character] of Object.entries(characterData)) {\r\n            if (merge || !settings.getCharacter(name)) {\r\n                settings.setCharacter(name, character);\r\n                importCount++;\r\n            }\r\n        }\r\n\r\n        debug(`Imported ${importCount} characters`);\r\n        notifications.success(`Imported ${importCount} characters`);\r\n\r\n        return importCount;\r\n    });\r\n}\n","\"use strict\";\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;","/**\r\n * SillyTavern context abstraction layer for Name Tracker extension\r\n * Provides a thin wrapper around SillyTavern.getContext() with error handling\r\n */\r\n\r\nimport debugLogger from './debug.js';\r\nimport { errorHandler } from './errors.js';\r\n\r\nconst logger = debugLogger.createModuleLogger('Context');\r\n\r\nclass SillyTavernContext {\r\n    constructor() {\r\n        this._context = null;\r\n        this._lastUpdate = 0;\r\n        this._updateInterval = 1000; // Cache context for 1 second\r\n    }\r\n\r\n    /**\r\n     * Get fresh SillyTavern context\r\n     * @returns {Object} SillyTavern context object\r\n     */\r\n    getContext() {\r\n        const now = Date.now();\r\n        if (!this._context || (now - this._lastUpdate) > this._updateInterval) {\r\n            try {\r\n                this._context = SillyTavern.getContext();\r\n                this._lastUpdate = now;\r\n            } catch (error) {\r\n                logger.error('Failed to get SillyTavern context:', error);\r\n                throw new Error('SillyTavern context not available');\r\n            }\r\n        }\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * Get current chat\r\n     * @returns {Array} Current chat messages\r\n     */\r\n    getChat() {\r\n        return this.getContext().chat || [];\r\n    }\r\n\r\n    /**\r\n     * Get current chat metadata\r\n     * @returns {Object} Chat metadata object\r\n     */\r\n    getChatMetadata() {\r\n        return this.getContext().chatMetadata || {};\r\n    }\r\n\r\n    /**\r\n     * Get current chat ID\r\n     * @returns {string|null} Chat identifier\r\n     */\r\n    getChatId() {\r\n        return this.getContext().chatId || null;\r\n    }\r\n\r\n    /**\r\n     * Get current character ID\r\n     * @returns {number|null} Character index\r\n     */\r\n    getCharacterId() {\r\n        return this.getContext().characterId;\r\n    }\r\n\r\n    /**\r\n     * Get characters list\r\n     * @returns {Array} Available characters\r\n     */\r\n    getCharacters() {\r\n        return this.getContext().characters || [];\r\n    }\r\n\r\n    /**\r\n     * Get user name (name1)\r\n     * @returns {string} User's persona name\r\n     */\r\n    getUserName() {\r\n        return this.getContext().name1 || 'User';\r\n    }\r\n\r\n    /**\r\n     * Get extension settings object\r\n     * @returns {Object} Extension settings\r\n     */\r\n    getExtensionSettings() {\r\n        return this.getContext().extensionSettings || {};\r\n    }\r\n\r\n    /**\r\n     * Save extension settings\r\n     * @returns {Promise<void>}\r\n     */\r\n    async saveExtensionSettings() {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            if (context.saveSettingsDebounced) {\r\n                context.saveSettingsDebounced();\r\n            } else {\r\n                logger.warn('saveSettingsDebounced not available');\r\n            }\r\n        }, { silent: true });\r\n    }\r\n\r\n    /**\r\n     * Save chat metadata\r\n     * @returns {Promise<void>}\r\n     */\r\n    async saveChatMetadata() {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            if (context.saveMetadata) {\r\n                await context.saveMetadata();\r\n            } else {\r\n                logger.warn('saveMetadata not available');\r\n            }\r\n        }, { silent: true });\r\n    }\r\n\r\n    /**\r\n     * Generate quiet prompt (background LLM call)\r\n     * @param {Object} options - Generation options\r\n     * @returns {Promise<string>} Generated text\r\n     */\r\n    async generateQuietPrompt(options) {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            if (!context.generateQuietPrompt) {\r\n                throw new Error('generateQuietPrompt not available');\r\n            }\r\n            return await context.generateQuietPrompt(options);\r\n        }, { retries: 1 });\r\n    }\r\n\r\n    /**\r\n     * Load world info (lorebook)\r\n     * @param {string} lorebookName - Name of lorebook to load\r\n     * @returns {Promise<Object|null>} Lorebook data\r\n     */\r\n    async loadWorldInfo(lorebookName) {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            if (!context.loadWorldInfo) {\r\n                throw new Error('loadWorldInfo not available');\r\n            }\r\n            return await context.loadWorldInfo(lorebookName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Save world info (lorebook)\r\n     * @param {string} lorebookName - Name of lorebook\r\n     * @param {Object} data - Lorebook data\r\n     * @param {boolean} create - Create if doesn't exist\r\n     * @returns {Promise<void>}\r\n     */\r\n    async saveWorldInfo(lorebookName, data, create = false) {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            if (!context.saveWorldInfo) {\r\n                throw new Error('saveWorldInfo not available');\r\n            }\r\n            return await context.saveWorldInfo(lorebookName, data, create);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Save world info entry\r\n     * @param {string} lorebookName - Lorebook name\r\n     * @param {Object} entryData - Entry data\r\n     * @returns {Promise<void>}\r\n     */\r\n    async saveWorldInfoEntry(lorebookName, entryData) {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            if (!context.saveWorldInfoEntry) {\r\n                throw new Error('saveWorldInfoEntry not available');\r\n            }\r\n            return await context.saveWorldInfoEntry(lorebookName, entryData);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get event source for listening to SillyTavern events\r\n     * @returns {Object} Event source object\r\n     */\r\n    getEventSource() {\r\n        const context = this.getContext();\r\n        return context.eventSource;\r\n    }\r\n\r\n    /**\r\n     * Get event types constants\r\n     * @returns {Object} Event types\r\n     */\r\n    getEventTypes() {\r\n        const context = this.getContext();\r\n        return context.event_types;\r\n    }\r\n\r\n    /**\r\n     * Call generic popup\r\n     * @param {string} content - HTML content\r\n     * @param {number} type - Popup type\r\n     * @param {string} input - Input placeholder\r\n     * @param {Object} options - Additional options\r\n     * @returns {Promise<any>} Popup result\r\n     */\r\n    async callGenericPopup(content, type, input = '', options = {}) {\r\n        return errorHandler.withErrorBoundary('Context', async () => {\r\n            const context = this.getContext();\r\n            if (!context.callGenericPopup) {\r\n                throw new Error('callGenericPopup not available');\r\n            }\r\n            return await context.callGenericPopup(content, type, input, options);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if SillyTavern context is available\r\n     * @returns {boolean} Context availability\r\n     */\r\n    isContextAvailable() {\r\n        try {\r\n            return !!this.getContext();\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear cached context (force refresh on next access)\r\n     */\r\n    clearCache() {\r\n        this._context = null;\r\n        this._lastUpdate = 0;\r\n        logger.debug('Cleared context cache');\r\n    }\r\n\r\n    /**\r\n     * Get context status information for debugging\r\n     * @returns {Object} Context status\r\n     */\r\n    getStatus() {\r\n        return {\r\n            available: this.isContextAvailable(),\r\n            cached: !!this._context,\r\n            lastUpdate: this._lastUpdate,\r\n            chatId: this.getChatId(),\r\n            characterId: this.getCharacterId(),\r\n        };\r\n    }\r\n}\r\n\r\n// Create singleton instance\r\nconst sillyTavernContext = new SillyTavernContext();\r\n\r\nexport { sillyTavernContext as stContext };\r\nexport default sillyTavernContext;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nc = undefined;","\n      import API from \"!./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!./node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!./node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!./node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!./node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!./node_modules/css-loader/dist/cjs.js!./style.css\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\noptions.insert = insertFn.bind(null, \"head\");\noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!./node_modules/css-loader/dist/cjs.js!./style.css\";\n       export default content && content.locals ? content.locals : undefined;\n","/**\r\n * Utility functions for Name Tracker extension\r\n * Common helpers and shared functionality\r\n */\r\n\r\nimport debugLogger from '../core/debug.js';\r\n\r\nconst logger = debugLogger.createModuleLogger('Utils');\r\n\r\n/**\r\n * Simple hash function for generating unique identifiers\r\n * @param {string} str - String to hash\r\n * @returns {string} Hash value in base-36 format\r\n */\r\nexport function simpleHash(str) {\r\n    let hash = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        const char = str.charCodeAt(i);\r\n        hash = ((hash << 5) - hash) + char;\r\n        hash = hash & hash;\r\n    }\r\n    return hash.toString(36);\r\n}\r\n\r\n/**\r\n * Escape HTML special characters to prevent XSS\r\n * @param {string} text - Text to escape\r\n * @returns {string} HTML-safe text\r\n */\r\nexport function escapeHtml(text) {\r\n    if (typeof text !== 'string') {\r\n        return '';\r\n    }\r\n\r\n    const div = document.createElement('div');\r\n    div.textContent = text;\r\n    return div.innerHTML;\r\n}\r\n\r\n/**\r\n * Generate unique identifier\r\n * @returns {string} Unique ID\r\n */\r\nexport function generateUID() {\r\n    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);\r\n}\r\n\r\n/**\r\n * Deep clone an object\r\n * @param {any} obj - Object to clone\r\n * @returns {any} Cloned object\r\n */\r\nexport function deepClone(obj) {\r\n    if (obj === null || typeof obj !== 'object') {\r\n        return obj;\r\n    }\r\n\r\n    if (obj instanceof Date) {\r\n        return new Date(obj.getTime());\r\n    }\r\n\r\n    if (obj instanceof Array) {\r\n        return obj.map(item => deepClone(item));\r\n    }\r\n\r\n    if (typeof obj === 'object') {\r\n        const cloned = {};\r\n        Object.keys(obj).forEach(key => {\r\n            cloned[key] = deepClone(obj[key]);\r\n        });\r\n        return cloned;\r\n    }\r\n\r\n    return obj;\r\n}\r\n\r\n/**\r\n * Debounce function calls\r\n * @param {Function} func - Function to debounce\r\n * @param {number} wait - Wait time in milliseconds\r\n * @returns {Function} Debounced function\r\n */\r\nexport function debounce(func, wait) {\r\n    let timeout;\r\n    return function executedFunction(...args) {\r\n        const later = () => {\r\n            clearTimeout(timeout);\r\n            func(...args);\r\n        };\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(later, wait);\r\n    };\r\n}\r\n\r\n/**\r\n * Throttle function calls\r\n * @param {Function} func - Function to throttle\r\n * @param {number} limit - Time limit in milliseconds\r\n * @returns {Function} Throttled function\r\n */\r\nexport function throttle(func, limit) {\r\n    let inThrottle;\r\n    return function executedFunction(...args) {\r\n        if (!inThrottle) {\r\n            func.apply(this, args);\r\n            inThrottle = true;\r\n            setTimeout(() => inThrottle = false, limit);\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Check if a value is empty (null, undefined, empty string, empty array, empty object)\r\n * @param {any} value - Value to check\r\n * @returns {boolean} True if empty\r\n */\r\nexport function isEmpty(value) {\r\n    if (value == null) return true;\r\n    if (typeof value === 'string') return value.trim() === '';\r\n    if (Array.isArray(value)) return value.length === 0;\r\n    if (typeof value === 'object') return Object.keys(value).length === 0;\r\n    return false;\r\n}\r\n\r\n/**\r\n * Normalize character names (remove extra spaces, normalize case)\r\n * @param {string} name - Name to normalize\r\n * @returns {string} Normalized name\r\n */\r\nexport function normalizeName(name) {\r\n    if (typeof name !== 'string') {\r\n        return '';\r\n    }\r\n\r\n    return name\r\n        .trim()\r\n        .replace(/\\s+/g, ' ') // Replace multiple spaces with single space\r\n        .split(' ')\r\n        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\r\n        .join(' ');\r\n}\r\n\r\n/**\r\n * Calculate similarity between two strings\r\n * @param {string} str1 - First string\r\n * @param {string} str2 - Second string\r\n * @returns {number} Similarity score (0-1)\r\n */\r\nexport function calculateSimilarity(str1, str2) {\r\n    if (!str1 || !str2) return 0;\r\n\r\n    const a = str1.toLowerCase();\r\n    const b = str2.toLowerCase();\r\n\r\n    if (a === b) return 1;\r\n\r\n    // Simple Levenshtein distance\r\n    const matrix = [];\r\n\r\n    for (let i = 0; i <= b.length; i++) {\r\n        matrix[i] = [i];\r\n    }\r\n\r\n    for (let j = 0; j <= a.length; j++) {\r\n        matrix[0][j] = j;\r\n    }\r\n\r\n    for (let i = 1; i <= b.length; i++) {\r\n        for (let j = 1; j <= a.length; j++) {\r\n            if (b.charAt(i - 1) === a.charAt(j - 1)) {\r\n                matrix[i][j] = matrix[i - 1][j - 1];\r\n            } else {\r\n                matrix[i][j] = Math.min(\r\n                    matrix[i - 1][j - 1] + 1, // substitution\r\n                    matrix[i][j - 1] + 1,     // insertion\r\n                    matrix[i - 1][j] + 1,      // deletion\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    const maxLength = Math.max(a.length, b.length);\r\n    return 1 - (matrix[b.length][a.length] / maxLength);\r\n}\r\n\r\n/**\r\n * Format timestamp for display\r\n * @param {number} timestamp - Unix timestamp\r\n * @returns {string} Formatted time string\r\n */\r\nexport function formatTimestamp(timestamp) {\r\n    const date = new Date(timestamp);\r\n    const now = new Date();\r\n    const diff = now - date;\r\n\r\n    const seconds = Math.floor(diff / 1000);\r\n    const minutes = Math.floor(seconds / 60);\r\n    const hours = Math.floor(minutes / 60);\r\n    const days = Math.floor(hours / 24);\r\n\r\n    if (days > 0) return `${days}d ago`;\r\n    if (hours > 0) return `${hours}h ago`;\r\n    if (minutes > 0) return `${minutes}m ago`;\r\n    return 'Just now';\r\n}\r\n\r\n/**\r\n * Truncate text with ellipsis\r\n * @param {string} text - Text to truncate\r\n * @param {number} maxLength - Maximum length\r\n * @returns {string} Truncated text\r\n */\r\nexport function truncate(text, maxLength) {\r\n    if (typeof text !== 'string') return '';\r\n    if (text.length <= maxLength) return text;\r\n    return text.substring(0, maxLength - 3) + '...';\r\n}\r\n\r\nlogger.debug('Utils module loaded');\r\n\r\nexport default {\r\n    simpleHash,\r\n    escapeHtml,\r\n    generateUID,\r\n    deepClone,\r\n    debounce,\r\n    throttle,\r\n    isEmpty,\r\n    normalizeName,\r\n    calculateSimilarity,\r\n    formatTimestamp,\r\n    truncate,\r\n};\n","/**\r\n * LLM Integration Module\r\n * \r\n * Handles LLM API calls to SillyTavern and Ollama for character analysis.\r\n * Includes token management, context window handling, and JSON parsing.\r\n */\r\n\r\nimport { createModuleLogger } from '../core/debug.js';\r\nimport { withErrorBoundary, NameTrackerError } from '../core/errors.js';\r\nimport { settings } from '../core/settings.js';\r\nimport { stContext } from '../core/context.js';\r\nimport { simpleHash } from '../utils/helpers.js';\r\nimport { NotificationManager } from '../utils/notifications.js';\r\n\r\nconst debug = createModuleLogger('llm');\r\nconst notifications = new NotificationManager('LLM Integration');\r\n\r\n// LLM state management\r\nlet analysisCache = new Map(); // Cache for LLM analysis results\r\nlet ollamaModels = []; // Available Ollama models\r\n\r\n/**\r\n * Default system prompt for character analysis\r\n */\r\nconst DEFAULT_SYSTEM_PROMPT = `You are a character analysis assistant. Your task is to extract character information from chat messages and return it in a structured JSON format.\r\n\r\nCRITICAL: You MUST respond with ONLY valid JSON. Do not include any explanatory text, markdown formatting, or commentary. Just the raw JSON object.\r\n\r\nIMPORTANT PROCESSING RULES:\r\n1. Process messages in CHRONOLOGICAL ORDER (oldest to newest)\r\n2. When there is conflicting information about a character, ALWAYS use the MOST RECENT information\r\n3. Be smart about name variations - \"Alex\" and \"Alexandra\" may be the same person\r\n4. Track physical attributes, personality traits, relationships, and interactions with {{user}}\r\n5. Don't create entries for generic references like \"the bartender\" unless given specific names\r\n\r\nRequired JSON structure:\r\n{\r\n  \"characters\": [\r\n    {\r\n      \"name\": \"Character's primary/preferred name\",\r\n      \"aliases\": [\"Alternative names\", \"Nicknames\"],\r\n      \"physicalAge\": \"Age or age range\",\r\n      \"mentalAge\": \"Mental/emotional age if different\",\r\n      \"physical\": \"Physical description and appearance\",\r\n      \"personality\": \"Personality traits and behavior\", \r\n      \"sexuality\": \"Sexual orientation or preferences\",\r\n      \"raceEthnicity\": \"Race/ethnicity information\",\r\n      \"roleSkills\": \"Job, role, skills, abilities\",\r\n      \"lastInteraction\": \"Most recent interaction or scene with {{user}}\",\r\n      \"relationships\": [\"Relationship with other characters\"],\r\n      \"confidence\": 85\r\n    }\r\n  ]\r\n}\r\n\r\nConfidence scores (0-100):\r\n- 90-100: Character explicitly named with detailed info\r\n- 70-89: Character clearly identified with some details\r\n- 50-69: Character mentioned but limited info\r\n- Below 50: Uncertain or vague reference\r\n\r\nFocus on major speaking characters and those with significant interactions. Avoid analyzing every minor mention.`;\r\n\r\n/**\r\n * Get the system prompt for analysis\r\n * @returns {string} System prompt text\r\n */\r\nfunction getSystemPrompt() {\r\n    return settings.getSetting('systemPrompt') || DEFAULT_SYSTEM_PROMPT;\r\n}\r\n\r\n/**\r\n * Load available Ollama models\r\n * @returns {Promise<Array>} Array of available models\r\n */\r\nexport async function loadOllamaModels() {\r\n    return withErrorBoundary('loadOllamaModels', async () => {\r\n        const ollamaEndpoint = settings.getSetting('ollamaEndpoint', 'http://localhost:11434');\r\n        \r\n        debug('Loading Ollama models from:', ollamaEndpoint);\r\n        \r\n        try {\r\n            const response = await fetch(`${ollamaEndpoint}/api/tags`);\r\n            \r\n            if (!response.ok) {\r\n                throw new Error(`Failed to connect to Ollama: ${response.statusText}`);\r\n            }\r\n            \r\n            const data = await response.json();\r\n            ollamaModels = data.models || [];\r\n            \r\n            debug(`Loaded ${ollamaModels.length} Ollama models:`, ollamaModels.map(m => m.name));\r\n            \r\n            return ollamaModels;\r\n        } catch (error) {\r\n            console.error('Error loading Ollama models:', error);\r\n            notifications.error('Failed to load Ollama models. Check endpoint and try again.');\r\n            throw error;\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Get Ollama model context size\r\n * @param {string} modelName - Name of the Ollama model\r\n * @returns {Promise<number>} Context size in tokens, or default 4096\r\n */\r\nexport async function getOllamaModelContext(modelName) {\r\n    return withErrorBoundary('getOllamaModelContext', async () => {\r\n        const ollamaEndpoint = settings.getSetting('ollamaEndpoint', 'http://localhost:11434');\r\n        \r\n        if (!modelName) {\r\n            debug('No Ollama model specified, using default context size');\r\n            return 4096;\r\n        }\r\n        \r\n        try {\r\n            const response = await fetch(`${ollamaEndpoint}/api/show`, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                },\r\n                body: JSON.stringify({\r\n                    name: modelName\r\n                })\r\n            });\r\n            \r\n            if (!response.ok) {\r\n                throw new Error(`Failed to fetch model info: ${response.statusText}`);\r\n            }\r\n            \r\n            const data = await response.json();\r\n            \r\n            // Look for num_ctx in parameters array\r\n            if (data.parameters && Array.isArray(data.parameters)) {\r\n                for (const param of data.parameters) {\r\n                    const match = param.match(/num_ctx\\\\s+(\\\\d+)/);\r\n                    if (match) {\r\n                        const contextSize = parseInt(match[1]);\r\n                        debug(`Ollama model ${modelName} context size: ${contextSize} tokens`);\r\n                        return contextSize;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // Fallback: check if it's in model details\r\n            if (data.model_info && data.model_info.num_ctx) {\r\n                const contextSize = parseInt(data.model_info.num_ctx);\r\n                debug(`Ollama model ${modelName} context size: ${contextSize} tokens`);\r\n                return contextSize;\r\n            }\r\n            \r\n            debug(`Could not find context size for ${modelName}, using default 4096`);\r\n            return 4096;\r\n        } catch (error) {\r\n            console.error('Error fetching Ollama model context:', error);\r\n            debug(`Failed to get Ollama context size, using default 4096`);\r\n            return 4096;\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Build a roster of known characters for context\r\n * @returns {string} Formatted roster text\r\n */\r\nexport function buildCharacterRoster() {\r\n    return withErrorBoundary('buildCharacterRoster', () => {\r\n        const characters = settings.getCharacters();\r\n        const characterNames = Object.keys(characters);\r\n        \r\n        if (characterNames.length === 0) {\r\n            return '';\r\n        }\r\n        \r\n        const roster = characterNames.map(name => {\r\n            const char = characters[name];\r\n            const aliases = char.aliases && char.aliases.length > 0 \r\n                ? ` (also known as: ${char.aliases.join(', ')})`\r\n                : '';\r\n            const relationships = char.relationships && char.relationships.length > 0\r\n                ? `\\\\n    Relationships: ${char.relationships.join('; ')}`\r\n                : '';\r\n            return `  - ${name}${aliases}${relationships}`;\r\n        }).join('\\\\n');\r\n        \r\n        return `\\\\n\\\\n[KNOWN CHARACTERS]\\\\nThe following characters have already been identified. If you encounter them again, use the same name and add any new details:\\\\n${roster}\\\\n`;\r\n    });\r\n}\r\n\r\n/**\r\n * Get the maximum safe prompt length based on API context window\r\n * Uses actual token counts from messages when available\r\n * @returns {Promise<number>} Maximum prompt length in tokens\r\n */\r\nexport async function getMaxPromptLength() {\r\n    return withErrorBoundary('getMaxPromptLength', async () => {\r\n        const llmConfig = settings.getLLMConfig();\r\n        let maxContext = 4096; // Default\r\n        \r\n        if (llmConfig.source === 'ollama' && llmConfig.ollamaModel) {\r\n            // Get Ollama model's context size\r\n            maxContext = await getOllamaModelContext(llmConfig.ollamaModel);\r\n        } else {\r\n            // Use SillyTavern's context\r\n            const context = stContext.getSillyTavernContext();\r\n            maxContext = context.maxContext || 4096;\r\n        }\r\n        \r\n        // Reserve 50% of context for system prompt, response, and safety margin\r\n        const tokensForPrompt = Math.floor(maxContext * 0.5);\r\n        \r\n        debug(`API max context: ${maxContext} tokens, calculated max prompt: ${tokensForPrompt} tokens`);\r\n        \r\n        // Return at least 1000 tokens, max 25000 tokens\r\n        return Math.max(1000, Math.min(tokensForPrompt, 25000));\r\n    });\r\n}\r\n\r\n/**\r\n * Calculate total token count for a batch of messages\r\n * Uses pre-calculated token counts from SillyTavern when available\r\n * @param {Array} messages - Array of chat message objects\r\n * @returns {Promise<number>} Total token count\r\n */\r\nexport async function calculateMessageTokens(messages) {\r\n    return withErrorBoundary('calculateMessageTokens', async () => {\r\n        const context = stContext.getSillyTavernContext();\r\n        let totalTokens = 0;\r\n        \r\n        // Try to use pre-calculated token counts from message objects\r\n        for (const msg of messages) {\r\n            if (msg && typeof msg === 'object' && msg.extra && typeof msg.extra.token_count === 'number') {\r\n                // SillyTavern stores token count in extra.token_count\r\n                totalTokens += msg.extra.token_count;\r\n            } else {\r\n                // Fallback: use getTokenCountAsync for the message text\r\n                const text = msg?.mes || msg?.message || String(msg);\r\n                if (text && context.getTokenCountAsync) {\r\n                    try {\r\n                        const count = await context.getTokenCountAsync(text);\r\n                        totalTokens += count;\r\n                    } catch (e) {\r\n                        // Final fallback: rough estimate (4 chars per token)\r\n                        totalTokens += Math.ceil(text.length / 4);\r\n                    }\r\n                } else {\r\n                    // Character-based estimate\r\n                    totalTokens += Math.ceil(text.length / 4);\r\n                }\r\n            }\r\n        }\r\n        \r\n        return totalTokens;\r\n    });\r\n}\r\n\r\n/**\r\n * Call SillyTavern's LLM with optimized parameters for JSON extraction\r\n * Uses low temperature and focused sampling for deterministic, structured output\r\n * These settings override the user's chat settings to ensure reliable parsing\r\n * @param {string} prompt - The complete prompt to send\r\n * @returns {Promise<Object>} Parsed JSON response\r\n */\r\nexport async function callSillyTavern(prompt) {\r\n    return withErrorBoundary('callSillyTavern', async () => {\r\n        debug('Calling SillyTavern LLM...');\r\n        \r\n        // Use SillyTavern.getContext() as recommended in official docs\r\n        const context = stContext.getSillyTavernContext();\r\n        \r\n        // Check if we have an active API connection\r\n        if (!context.onlineStatus) {\r\n            throw new NameTrackerError('No API connection available. Please connect to an API first.');\r\n        }\r\n        \r\n        // Get token count for the prompt\r\n        let promptTokens;\r\n        try {\r\n            promptTokens = await context.getTokenCountAsync(prompt);\r\n            debug(`Generating with prompt: ${promptTokens} tokens (~${prompt.length} chars)`);\r\n        } catch (e) {\r\n            promptTokens = Math.ceil(prompt.length / 4);\r\n            debug(`Generating with prompt length: ${prompt.length} chars (est. ${promptTokens} tokens)`);\r\n        }\r\n        \r\n        // Calculate max_tokens dynamically: 1/4 of context size, minimum 4000\r\n        // This scales with the model's context window for better headroom\r\n        const maxContext = context.maxContext || 4096;\r\n        const calculatedMaxTokens = Math.floor(maxContext * 0.25);\r\n        const maxTokens = Math.max(4000, calculatedMaxTokens);\r\n        debug(`Max tokens for response: ${maxTokens} (context: ${maxContext}, 25% = ${calculatedMaxTokens})`);\r\n        \r\n        // Use generateRaw as documented in:\r\n        // https://docs.sillytavern.app/for-contributors/writing-extensions/#raw-generation\r\n        const result = await context.generateRaw({\r\n            prompt: prompt,  // Can be string (Text Completion) or array (Chat Completion)\r\n            systemPrompt: '',  // Empty, we include instructions in prompt\r\n            prefill: '',  // No prefill needed for analysis\r\n            // Override generation settings for structured output\r\n            // These ensure consistent, deterministic JSON regardless of user's chat settings\r\n            temperature: 0.3,  // Low temp for focused, deterministic output (user's setting is ignored)\r\n            top_p: 0.9,        // Slightly reduced for more predictable results\r\n            top_k: 40,         // Standard focused sampling\r\n            min_p: 0.05,       // Prevent very low probability tokens\r\n            rep_pen: 1.1,      // Slight repetition penalty\r\n            max_tokens: maxTokens,  // Dynamic: 25% of context, min 4000 (prevents truncation)\r\n            stop: []           // No custom stop sequences needed\r\n        });\r\n        \r\n        debug('SillyTavern LLM raw response:', result?.substring(0, 200));\r\n        \r\n        // The result should be a string\r\n        if (!result) {\r\n            throw new NameTrackerError('Empty response from SillyTavern LLM');\r\n        }\r\n        \r\n        return parseJSONResponse(result);\r\n    });\r\n}\r\n\r\n/**\r\n * Call Ollama API with optimized parameters for JSON extraction\r\n * Uses low temperature and focused sampling for deterministic, structured output\r\n * @param {string} prompt - The complete prompt to send\r\n * @returns {Promise<Object>} Parsed JSON response\r\n */\r\nexport async function callOllama(prompt) {\r\n    return withErrorBoundary('callOllama', async () => {\r\n        const llmConfig = settings.getLLMConfig();\r\n        \r\n        if (!llmConfig.ollamaModel) {\r\n            throw new NameTrackerError('No Ollama model selected');\r\n        }\r\n        \r\n        debug(`Calling Ollama with model ${llmConfig.ollamaModel}...`);\r\n        \r\n        // Calculate max_tokens dynamically: 1/4 of context size, minimum 4000\r\n        const maxContext = await getOllamaModelContext(llmConfig.ollamaModel);\r\n        const calculatedMaxTokens = Math.floor(maxContext * 0.25);\r\n        const maxTokens = Math.max(4000, calculatedMaxTokens);\r\n        debug(`Max tokens for response: ${maxTokens} (context: ${maxContext}, 25% = ${calculatedMaxTokens})`);\r\n        \r\n        const response = await fetch(`${llmConfig.ollamaEndpoint}/api/generate`, {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify({\r\n                model: llmConfig.ollamaModel,\r\n                prompt: prompt,\r\n                stream: false,\r\n                format: 'json',\r\n                // Ollama-specific generation parameters for structured output\r\n                options: {\r\n                    temperature: 0.3,      // Low temp for deterministic output\r\n                    top_p: 0.9,           // Focused sampling\r\n                    top_k: 40,            // Standard focused sampling\r\n                    repeat_penalty: 1.1,  // Slight repetition penalty\r\n                    num_predict: maxTokens  // Dynamic: 25% of context, min 4000 (prevents truncation)\r\n                }\r\n            }),\r\n        });\r\n        \r\n        if (!response.ok) {\r\n            throw new NameTrackerError(`Ollama API error: ${response.statusText}`);\r\n        }\r\n        \r\n        const data = await response.json();\r\n        debug('Ollama raw response:', data);\r\n        debug('Ollama response text:', data.response?.substring(0, 200));\r\n        \r\n        return parseJSONResponse(data.response);\r\n    });\r\n}\r\n\r\n/**\r\n * Parse JSON response from LLM, handling various formats\r\n * @param {string} text - Raw text response from LLM\r\n * @returns {Object} Parsed JSON object\r\n */\r\nexport function parseJSONResponse(text) {\r\n    return withErrorBoundary('parseJSONResponse', () => {\r\n        if (!text || typeof text !== 'string') {\r\n            console.error('Invalid response text:', text);\r\n            throw new NameTrackerError('LLM returned empty or invalid response');\r\n        }\r\n        \r\n        // Remove any leading/trailing whitespace\r\n        text = text.trim();\r\n        \r\n        // Try to extract JSON from markdown code blocks (```json or ```)\r\n        let jsonMatch = text.match(/```(?:json)?\\\\s*([\\\\s\\\\S]*?)```/);\r\n        if (jsonMatch) {\r\n            text = jsonMatch[1].trim();\r\n        }\r\n        \r\n        // Try to find JSON object in the text (look for first { to last })\r\n        const firstBrace = text.indexOf('{');\r\n        const lastBrace = text.lastIndexOf('}');\r\n        \r\n        if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {\r\n            text = text.substring(firstBrace, lastBrace + 1);\r\n        }\r\n        \r\n        // Remove common prefixes that LLMs add\r\n        text = text.replace(/^(?:Here's the analysis:|Here is the JSON:|Result:|Output:)\\\\s*/i, '');\r\n        \r\n        // Clean up common formatting issues\r\n        text = text.trim();\r\n        \r\n        try {\r\n            const parsed = JSON.parse(text);\r\n            \r\n            // Validate structure\r\n            if (!parsed.characters || !Array.isArray(parsed.characters)) {\r\n                console.warn('Response missing characters array, returning empty:', parsed);\r\n                return { characters: [] };\r\n            }\r\n            \r\n            return parsed;\r\n        } catch (error) {\r\n            console.error('Failed to parse JSON response. Original text:', text);\r\n            console.error('Parse error:', error.message);\r\n            \r\n            // Check if response was truncated (common issue with long responses)\r\n            if (text.includes('\"characters\"') && !text.trim().endsWith('}')) {\r\n                debug('Response appears truncated - missing closing braces');\r\n                debug(`Response length: ${text.length} chars, ends with: \"${text.slice(-50)}\"`);\r\n                \r\n                // Try to salvage partial data by attempting to close the JSON\r\n                let salvaged = text;\r\n                \r\n                // Count open vs closed braces to determine how many we need\r\n                const openBraces = (text.match(/\\{/g) || []).length;\r\n                const closeBraces = (text.match(/\\}/g) || []).length;\r\n                const openBrackets = (text.match(/\\[/g) || []).length;\r\n                const closeBrackets = (text.match(/\\]/g) || []).length;\r\n                \r\n                // Try to close incomplete strings and objects\r\n                if (salvaged.match(/\"[^\"]*$/)) {\r\n                    // Has unclosed quote\r\n                    salvaged += '\"';\r\n                }\r\n                \r\n                // Close missing brackets/braces\r\n                for (let i = 0; i < (openBrackets - closeBrackets); i++) {\r\n                    salvaged += ']';\r\n                }\r\n                for (let i = 0; i < (openBraces - closeBraces); i++) {\r\n                    salvaged += '}';\r\n                }\r\n                \r\n                try {\r\n                    const recovered = JSON.parse(salvaged);\r\n                    debug(`Successfully recovered ${recovered.characters?.length || 0} characters from truncated response`);\r\n                    return recovered;\r\n                } catch (e) {\r\n                    debug('Failed to recover truncated JSON:', e.message);\r\n                }\r\n            }\r\n            \r\n            // Try one more time with more aggressive extraction\r\n            const fallbackMatch = text.match(/\\\\{[\\\\s\\\\S]*\"characters\"[\\\\s\\\\S]*\\\\}/);\r\n            if (fallbackMatch) {\r\n                try {\r\n                    return JSON.parse(fallbackMatch[0]);\r\n                } catch (e) {\r\n                    // Give up\r\n                }\r\n            }\r\n            \r\n            throw new NameTrackerError('Failed to parse LLM response as JSON. The response may be too long or truncated. Try analyzing fewer messages at once.');\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Call LLM for character analysis with automatic batch splitting if prompt is too long\r\n * @param {Array} messageObjs - Array of message objects (with .mes property) or strings\r\n * @param {string} knownCharacters - Roster of previously identified characters\r\n * @param {number} depth - Recursion depth (for logging)\r\n * @param {number} retryCount - Number of retries attempted\r\n * @returns {Promise<Object>} Analysis result with merged characters\r\n */\r\nexport async function callLLMAnalysis(messageObjs, knownCharacters = '', depth = 0, retryCount = 0) {\r\n    return withErrorBoundary('callLLMAnalysis', async () => {\r\n        const llmConfig = settings.getLLMConfig();\r\n        const maxPromptTokens = await getMaxPromptLength(); // Dynamic based on API context window\r\n        const MAX_RETRIES = 3;\r\n        \r\n        debug(`Starting LLM analysis (depth: ${depth}, retry: ${retryCount})`);\r\n        \r\n        // Extract message text\r\n        const messages = messageObjs.map(msg => {\r\n            if (typeof msg === 'string') return msg;\r\n            if (msg.mes) return msg.mes;\r\n            if (msg.message) return msg.message;\r\n            return JSON.stringify(msg);\r\n        });\r\n        \r\n        // Create cache key\r\n        const cacheKey = simpleHash(messages.join('\\\\n') + llmConfig.source + llmConfig.ollamaModel);\r\n        \r\n        // Check cache\r\n        if (analysisCache.has(cacheKey)) {\r\n            debug('Using cached analysis result');\r\n            return analysisCache.get(cacheKey);\r\n        }\r\n        \r\n        // Build the prompt\r\n        const messagesText = messages.map((msg, idx) => `Message ${idx + 1}:\\\\n${msg}`).join('\\\\n\\\\n');\r\n        const systemInstructions = `[SYSTEM INSTRUCTION - DO NOT ROLEPLAY]\\\\n${getSystemPrompt()}${knownCharacters}\\\\n\\\\n[DATA TO ANALYZE]`;\r\n        const fullPrompt = `${systemInstructions}\\\\n${messagesText}\\\\n\\\\n[RESPOND WITH JSON ONLY - NO STORY CONTINUATION]`;\r\n        \r\n        // Calculate actual token count for the prompt\r\n        let promptTokens;\r\n        try {\r\n            promptTokens = await calculateMessageTokens([{ mes: fullPrompt }]);\r\n            debug(`Prompt tokens: ${promptTokens}, limit: ${maxPromptTokens}`);\r\n        } catch (e) {\r\n            // Fallback to character-based estimate\r\n            promptTokens = Math.ceil(fullPrompt.length / 4);\r\n        }\r\n        \r\n        // If prompt is too long, split into sub-batches\r\n        if (promptTokens > maxPromptTokens && messageObjs.length > 1) {\r\n            const indent = '  '.repeat(depth);\r\n            debug(`${indent}Prompt too long (${promptTokens} > ${maxPromptTokens}), splitting ${messageObjs.length} messages into batches...`);\r\n            \r\n            // Split roughly in half\r\n            const midpoint = Math.floor(messageObjs.length / 2);\r\n            const firstHalf = messageObjs.slice(0, midpoint);\r\n            const secondHalf = messageObjs.slice(midpoint);\r\n            \r\n            debug(`${indent}First batch: ${firstHalf.length} messages, second batch: ${secondHalf.length} messages`);\r\n            \r\n            // Analyze both halves in parallel\r\n            const [result1, result2] = await Promise.all([\r\n                callLLMAnalysis(firstHalf, knownCharacters, depth + 1),\r\n                callLLMAnalysis(secondHalf, knownCharacters, depth + 1)\r\n            ]);\r\n            \r\n            // Merge the results\r\n            const mergedResult = {\r\n                characters: [\r\n                    ...(result1.characters || []),\r\n                    ...(result2.characters || [])\r\n                ]\r\n            };\r\n            \r\n            debug(`${indent}Merged ${result1.characters?.length || 0} + ${result2.characters?.length || 0} = ${mergedResult.characters.length} characters`);\r\n            return mergedResult;\r\n        }\r\n        \r\n        // Prompt is acceptable length, proceed with analysis\r\n        let result;\r\n        \r\n        try {\r\n            if (llmConfig.source === 'ollama') {\r\n                result = await callOllama(fullPrompt);\r\n            } else {\r\n                result = await callSillyTavern(fullPrompt);\r\n            }\r\n        } catch (error) {\r\n            // Retry on JSON parsing errors or empty responses\r\n            if (retryCount < MAX_RETRIES && \r\n                (error.message.includes('JSON') || \r\n                 error.message.includes('empty') || \r\n                 error.message.includes('truncated'))) {\r\n                \r\n                debug(`Retrying LLM call (attempt ${retryCount + 1}/${MAX_RETRIES}): ${error.message}`);\r\n                \r\n                // Add exponential backoff delay\r\n                const delay = Math.pow(2, retryCount) * 1000; // 1s, 2s, 4s\r\n                await new Promise(resolve => setTimeout(resolve, delay));\r\n                \r\n                // Retry the same call\r\n                return await callLLMAnalysis(messageObjs, knownCharacters, depth, retryCount + 1);\r\n            }\r\n            \r\n            // Max retries exceeded or non-retryable error\r\n            throw error;\r\n        }\r\n        \r\n        // Cache the result\r\n        if (analysisCache.size > 50) {\r\n            // Clear oldest entries if cache is getting too large\r\n            const firstKey = analysisCache.keys().next().value;\r\n            analysisCache.delete(firstKey);\r\n        }\r\n        analysisCache.set(cacheKey, result);\r\n        \r\n        debug(`LLM analysis complete: found ${result.characters?.length || 0} characters`);\r\n        return result;\r\n    });\r\n}\r\n\r\n/**\r\n * Clear the analysis cache\r\n */\r\nexport function clearAnalysisCache() {\r\n    analysisCache.clear();\r\n    debug('Analysis cache cleared');\r\n}\r\n\r\n/**\r\n * Get analysis cache statistics\r\n * @returns {Object} Cache statistics\r\n */\r\nexport function getCacheStats() {\r\n    return {\r\n        size: analysisCache.size,\r\n        entries: [...analysisCache.keys()].map(key => ({\r\n            key: key.substring(0, 8) + '...',\r\n            timestamp: Date.now()\r\n        }))\r\n    };\r\n}\r\n\r\n/**\r\n * Get available Ollama models\r\n * @returns {Array} Array of available models\r\n */\r\nexport function getOllamaModels() {\r\n    return [...ollamaModels];\r\n}","/**\r\n * Lorebook Management Module\r\n *\r\n * Handles chat-level lorebook creation, entry formatting, and SillyTavern integration\r\n * for the Name Tracker extension.\r\n */\r\n\r\nimport { createModuleLogger } from '../core/debug.js';\r\nimport { withErrorBoundary, NameTrackerError } from '../core/errors.js';\r\nimport { settings } from '../core/settings.js';\r\nimport { stContext } from '../core/context.js';\r\nimport { generateUID } from '../utils/helpers.js';\r\nimport { NotificationManager } from '../utils/notifications.js';\r\n\r\nconst debug = createModuleLogger('lorebook');\r\nconst notifications = new NotificationManager('Lorebook Management');\r\n\r\n// Lorebook state\r\nlet lorebookName = null;\r\n\r\n/**\r\n * Initialize or get the lorebook for this chat\r\n * @returns {Promise<string|null>} Lorebook name if successful, null if no chat\r\n */\r\nexport async function initializeLorebook() {\r\n    return withErrorBoundary('initializeLorebook', async () => {\r\n        const context = stContext.getSillyTavernContext();\r\n\r\n        if (!context.chatId) {\r\n            debug('No active chat, skipping lorebook initialization');\r\n            lorebookName = null;\r\n            return null;\r\n        }\r\n\r\n        const METADATA_KEY = 'world_info';\r\n        const chatMetadata = context.chatMetadata;\r\n\r\n        if (!chatMetadata) {\r\n            debug('No chat metadata available, skipping lorebook initialization');\r\n            lorebookName = null;\r\n            return null;\r\n        }\r\n\r\n        // Check if chat already has a bound lorebook\r\n        if (chatMetadata[METADATA_KEY]) {\r\n            lorebookName = chatMetadata[METADATA_KEY];\r\n            debug(`Using existing chat lorebook: ${lorebookName}`);\r\n            return lorebookName;\r\n        }\r\n\r\n        // Create a new chat-bound lorebook name\r\n        const bookName = `NameTracker_${context.chatId}`\r\n            .replace(/[^a-z0-9 -]/gi, '_')\r\n            .replace(/_{2,}/g, '_')\r\n            .substring(0, 64);\r\n\r\n        debug(`Creating new chat lorebook: ${bookName}`);\r\n        lorebookName = bookName;\r\n\r\n        // Bind it to the chat metadata\r\n        chatMetadata[METADATA_KEY] = lorebookName;\r\n\r\n        // Save chat metadata using context API\r\n        try {\r\n            await context.saveMetadata();\r\n            debug(`Bound lorebook to chat: ${lorebookName}`);\r\n\r\n            // Ensure the lorebook file exists (create empty if needed)\r\n            const worldInfo = await context.loadWorldInfo(lorebookName);\r\n            if (!worldInfo) {\r\n                debug(`Creating initial empty lorebook file: ${lorebookName}`);\r\n                await context.saveWorldInfo(lorebookName, { entries: {} }, true);\r\n            }\r\n\r\n            // Notify user\r\n            notifications.info(`Chat lorebook \"${lorebookName}\" created and bound to this chat`, { timeOut: 5000 });\r\n        } catch (error) {\r\n            console.error('Failed to initialize lorebook:', error);\r\n            lorebookName = null;\r\n            throw new NameTrackerError(`Failed to initialize lorebook: ${error.message}`);\r\n        }\r\n\r\n        return lorebookName;\r\n    });\r\n}\r\n\r\n/**\r\n * Update or create lorebook entry for a character\r\n * @param {Object} character - Character data\r\n * @param {string} characterName - Character name\r\n * @returns {Promise<void>}\r\n */\r\nexport async function updateLorebookEntry(character, characterName) {\r\n    return withErrorBoundary('updateLorebookEntry', async () => {\r\n        debug(`updateLorebookEntry called for: ${characterName}`);\r\n        debug('  Character data:', character);\r\n\r\n        if (!lorebookName) {\r\n            debug('No lorebook initialized, skipping entry update');\r\n            return;\r\n        }\r\n\r\n        const context = stContext.getSillyTavernContext();\r\n        const lorebookConfig = settings.getLorebookConfig();\r\n\r\n        // Build the entry content in a readable format\r\n        const contentParts = [];\r\n\r\n        // Physical Age / Mental Age\r\n        if (character.physicalAge || character.mentalAge) {\r\n            const ageInfo = [];\r\n            if (character.physicalAge) ageInfo.push(`Physical: ${character.physicalAge}`);\r\n            if (character.mentalAge) ageInfo.push(`Mental: ${character.mentalAge}`);\r\n            contentParts.push(`**Age:** ${ageInfo.join(', ')}`);\r\n        }\r\n\r\n        // Physical (consolidated body description)\r\n        if (character.physical) {\r\n            contentParts.push(`\\\\n**Physical Description:**\\\\n${character.physical}`);\r\n        }\r\n\r\n        // Personality (consolidated traits, likes, dislikes)\r\n        if (character.personality) {\r\n            contentParts.push(`\\\\n**Personality:**\\\\n${character.personality}`);\r\n        }\r\n\r\n        // Sexuality\r\n        if (character.sexuality) {\r\n            contentParts.push(`\\\\n**Sexuality:**\\\\n${character.sexuality}`);\r\n        }\r\n\r\n        // Race/Ethnicity\r\n        if (character.raceEthnicity) {\r\n            contentParts.push(`**Race/Ethnicity:** ${character.raceEthnicity}`);\r\n        }\r\n\r\n        // Role & Skills\r\n        if (character.roleSkills) {\r\n            contentParts.push(`\\\\n**Role & Skills:**\\\\n${character.roleSkills}`);\r\n        }\r\n\r\n        // Last Interaction\r\n        if (character.lastInteraction) {\r\n            contentParts.push(`\\\\n**Last Interaction with {{user}}:**\\\\n${character.lastInteraction}`);\r\n        }\r\n\r\n        // Relationships\r\n        if (character.relationships && character.relationships.length > 0) {\r\n            contentParts.push('\\\\n**Relationships:**');\r\n            character.relationships.forEach(rel => {\r\n                contentParts.push(`- ${rel}`);\r\n            });\r\n        }\r\n\r\n        const content = contentParts.join('\\\\n');\r\n\r\n        // Build the keys array (name + aliases)\r\n        const keys = [character.preferredName];\r\n        if (character.aliases) {\r\n            keys.push(...character.aliases);\r\n        }\r\n\r\n        // Load the world info to check if entry exists\r\n        let worldInfo = await context.loadWorldInfo(lorebookName);\r\n\r\n        if (!worldInfo) {\r\n            debug(`WARNING: Could not load lorebook ${lorebookName}. Creating new lorebook structure.`);\r\n            // Match SillyTavern's world info structure\r\n            worldInfo = {\r\n                entries: {},\r\n            };\r\n        }\r\n\r\n        // Calculate dynamic cooldown\r\n        const messageFreq = settings.getSetting('messageFrequency', 10);\r\n        const calculatedCooldown = Math.max(1, Math.floor(messageFreq * 0.75));\r\n\r\n        let existingUid = null;\r\n\r\n        // Check if this character already has a lorebook entry\r\n        if (character.lorebookEntryId && worldInfo.entries && worldInfo.entries[character.lorebookEntryId]) {\r\n            // Update existing entry\r\n            existingUid = character.lorebookEntryId;\r\n            const existingEntry = worldInfo.entries[existingUid];\r\n\r\n            existingEntry.key = keys;\r\n            existingEntry.content = content;\r\n            existingEntry.enabled = lorebookConfig.enabled;\r\n            existingEntry.position = lorebookConfig.position;\r\n            existingEntry.probability = lorebookConfig.probability;\r\n            existingEntry.depth = lorebookConfig.depth;\r\n            existingEntry.scanDepth = lorebookConfig.scanDepth;\r\n            existingEntry.cooldown = calculatedCooldown;\r\n\r\n            debug(`Updated existing lorebook entry ${existingUid} for ${characterName}`);\r\n        } else {\r\n            // Create new entry\r\n            const newUid = generateUID();\r\n\r\n            const newEntry = {\r\n                uid: newUid,\r\n                key: keys,\r\n                keysecondary: [],\r\n                comment: `Auto-generated entry for ${character.preferredName}`,\r\n                content: content,\r\n                constant: false,\r\n                selective: true,\r\n                contextConfig: {\r\n                    prefix: '',\r\n                    suffix: '',\r\n                    tokenBudget: 0,\r\n                    reservedTokens: 0,\r\n                    budgetPriority: 400,\r\n                    trimDirection: 'doNotTrim',\r\n                    insertionOrder: 0,\r\n                    maximumTrimType: 'sentence',\r\n                    insertionPosition: 'before',\r\n                },\r\n                enabled: lorebookConfig.enabled,\r\n                position: lorebookConfig.position,\r\n                excludeRecursion: false,\r\n                preventRecursion: false,\r\n                delayUntilRecursion: false,\r\n                probability: lorebookConfig.probability,\r\n                useProbability: true,\r\n                depth: lorebookConfig.depth,\r\n                selectiveLogic: 0,\r\n                group: '',\r\n                scanDepth: lorebookConfig.scanDepth,\r\n                caseSensitive: null,\r\n                matchWholeWords: null,\r\n                useGroupScoring: null,\r\n                automationId: '',\r\n                role: 0,\r\n                vectorized: false,\r\n                sticky: 0,\r\n                cooldown: calculatedCooldown,\r\n                delay: 0,\r\n            };\r\n\r\n            // World info entries are stored as an object with UID as key\r\n            worldInfo.entries[newUid] = newEntry;\r\n            character.lorebookEntryId = newUid;\r\n\r\n            debug(`Created new lorebook entry ${newUid} for ${characterName}`);\r\n        }\r\n\r\n        // Save the lorebook\r\n        try {\r\n            await context.saveWorldInfo(lorebookName, worldInfo, true);\r\n\r\n            // Verify the save worked by reloading\r\n            const verifyWorldInfo = await context.loadWorldInfo(lorebookName);\r\n            const targetUid = existingUid || character.lorebookEntryId;\r\n\r\n            if (verifyWorldInfo && verifyWorldInfo.entries && verifyWorldInfo.entries[targetUid]) {\r\n                debug(`Verified lorebook entry ${targetUid} was saved successfully`);\r\n            } else {\r\n                console.error('[Name Tracker] WARNING: Lorebook verification failed - entries may not have been saved!');\r\n            }\r\n\r\n            debug(`Saved lorebook: ${lorebookName}`);\r\n        } catch (error) {\r\n            console.error('[Name Tracker] Error saving lorebook:', error);\r\n            debug(`Failed to save lorebook: ${error.message}`);\r\n            throw error; // Re-throw so caller knows it failed\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Create lorebook content from character data (JSON format)\r\n * @param {Object} character - Character data\r\n * @returns {string} JSON string representation\r\n */\r\nexport function createLorebookContent(character) {\r\n    return withErrorBoundary('createLorebookContent', () => {\r\n        const content = {\r\n            name: character.preferredName,\r\n            aliases: character.aliases,\r\n            physical: character.physical,\r\n            mental: character.mental,\r\n            relationships: character.relationships,\r\n        };\r\n\r\n        return JSON.stringify(content, null, 2);\r\n    });\r\n}\r\n\r\n/**\r\n * View character in lorebook editor\r\n * @param {string} characterName - Name of character to view\r\n * @returns {Promise<void>}\r\n */\r\nexport async function viewInLorebook(characterName) {\r\n    return withErrorBoundary('viewInLorebook', async () => {\r\n        const character = settings.getCharacter(characterName);\r\n\r\n        if (!character) {\r\n            throw new NameTrackerError('Character not found');\r\n        }\r\n\r\n        if (!lorebookName) {\r\n            notifications.warning('No active chat or lorebook');\r\n            return;\r\n        }\r\n\r\n        // Import the openWorldInfoEditor function from SillyTavern\r\n        const context = stContext.getSillyTavernContext();\r\n\r\n        // Open the lorebook editor\r\n        if (typeof context.openWorldInfoEditor === 'function') {\r\n            await context.openWorldInfoEditor(lorebookName);\r\n            notifications.success(`Opened lorebook for ${characterName}`);\r\n        } else {\r\n            // Fallback: show the world info panel if openWorldInfoEditor doesn't exist\r\n            $('#WorldInfo').click();\r\n            notifications.info(`Please select \"${lorebookName}\" from the World Info panel`);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Delete a character's lorebook entry\r\n * @param {Object} character - Character data\r\n * @returns {Promise<boolean>} True if deleted successfully\r\n */\r\nexport async function deleteLorebookEntry(character) {\r\n    return withErrorBoundary('deleteLorebookEntry', async () => {\r\n        if (!lorebookName || !character.lorebookEntryId) {\r\n            debug('No lorebook or entry ID to delete');\r\n            return false;\r\n        }\r\n\r\n        const context = stContext.getSillyTavernContext();\r\n\r\n        try {\r\n            const worldInfo = await context.loadWorldInfo(lorebookName);\r\n            if (worldInfo && worldInfo.entries && worldInfo.entries[character.lorebookEntryId]) {\r\n                delete worldInfo.entries[character.lorebookEntryId];\r\n                await context.saveWorldInfo(lorebookName, worldInfo, true);\r\n\r\n                debug(`Deleted lorebook entry ${character.lorebookEntryId} for ${character.preferredName}`);\r\n                return true;\r\n            }\r\n        } catch (error) {\r\n            console.error('Error deleting lorebook entry:', error);\r\n            return false;\r\n        }\r\n\r\n        return false;\r\n    });\r\n}\r\n\r\n/**\r\n * Purge all tracked character entries from lorebook\r\n * @param {Array} characters - Array of character objects to purge\r\n * @returns {Promise<number>} Number of entries deleted\r\n */\r\nexport async function purgeLorebookEntries(characters) {\r\n    return withErrorBoundary('purgeLorebookEntries', async () => {\r\n        if (!lorebookName) {\r\n            debug('No active lorebook');\r\n            return 0;\r\n        }\r\n\r\n        const context = stContext.getSillyTavernContext();\r\n        let deletedCount = 0;\r\n\r\n        try {\r\n            const worldInfo = await context.loadWorldInfo(lorebookName);\r\n\r\n            if (worldInfo && worldInfo.entries) {\r\n                // Get all entry IDs from our tracked characters\r\n                const entryIds = characters\r\n                    .map(char => char.lorebookEntryId)\r\n                    .filter(id => id !== undefined && id !== null);\r\n\r\n                // Delete each entry\r\n                for (const entryId of entryIds) {\r\n                    if (worldInfo.entries[entryId]) {\r\n                        delete worldInfo.entries[entryId];\r\n                        deletedCount++;\r\n                        debug(`Deleted lorebook entry ${entryId}`);\r\n                    }\r\n                }\r\n\r\n                // Save the lorebook\r\n                await context.saveWorldInfo(lorebookName, worldInfo, true);\r\n            }\r\n        } catch (error) {\r\n            console.error('Error purging lorebook entries:', error);\r\n            throw new NameTrackerError(`Failed to purge lorebook entries: ${error.message}`);\r\n        }\r\n\r\n        return deletedCount;\r\n    });\r\n}\r\n\r\n/**\r\n * Adopt existing lorebook entries into character cache\r\n * This allows manual entries or previous data to be imported\r\n * @returns {Promise<number>} Number of entries adopted\r\n */\r\nexport async function adoptExistingEntries() {\r\n    return withErrorBoundary('adoptExistingEntries', async () => {\r\n        if (!lorebookName) {\r\n            debug('No active lorebook for adoption');\r\n            return 0;\r\n        }\r\n\r\n        const context = stContext.getSillyTavernContext();\r\n        let adoptedCount = 0;\r\n\r\n        try {\r\n            const worldInfo = await context.loadWorldInfo(lorebookName);\r\n\r\n            if (!worldInfo || !worldInfo.entries) {\r\n                debug('No lorebook entries to adopt');\r\n                return 0;\r\n            }\r\n\r\n            const characters = settings.getCharacters();\r\n\r\n            // Look for entries that might belong to our extension\r\n            for (const [entryId, entry] of Object.entries(worldInfo.entries)) {\r\n                if (!entry.key || !Array.isArray(entry.key) || entry.key.length === 0) {\r\n                    continue;\r\n                }\r\n\r\n                const primaryName = entry.key[0];\r\n\r\n                // Check if this entry represents a character we should track\r\n                if (!characters[primaryName] && entry.comment?.includes('Auto-generated entry for')) {\r\n                    // Try to parse the content to recreate character data\r\n                    const character = {\r\n                        preferredName: primaryName,\r\n                        aliases: entry.key.slice(1),\r\n                        physical: '',\r\n                        personality: '',\r\n                        sexuality: '',\r\n                        raceEthnicity: '',\r\n                        roleSkills: '',\r\n                        lastInteraction: '',\r\n                        relationships: [],\r\n                        ignored: false,\r\n                        confidence: 50,\r\n                        lorebookEntryId: entryId,\r\n                        lastUpdated: Date.now(),\r\n                        isMainChar: false,\r\n                    };\r\n\r\n                    // Store the adopted character\r\n                    settings.setCharacter(primaryName, character);\r\n                    adoptedCount++;\r\n\r\n                    debug(`Adopted existing lorebook entry for: ${primaryName}`);\r\n                }\r\n            }\r\n\r\n            if (adoptedCount > 0) {\r\n                notifications.success(`Adopted ${adoptedCount} existing lorebook entries`);\r\n            }\r\n\r\n        } catch (error) {\r\n            console.error('Error adopting existing entries:', error);\r\n            throw new NameTrackerError(`Failed to adopt existing entries: ${error.message}`);\r\n        }\r\n\r\n        return adoptedCount;\r\n    });\r\n}\r\n\r\n/**\r\n * Get the current lorebook name\r\n * @returns {string|null} Current lorebook name\r\n */\r\nexport function getCurrentLorebookName() {\r\n    return lorebookName;\r\n}\r\n\r\n/**\r\n * Reset lorebook state (called on chat change)\r\n */\r\nexport function resetLorebookState() {\r\n    lorebookName = null;\r\n    debug('Lorebook state reset');\r\n}\r\n\r\n/**\r\n * Get lorebook statistics\r\n * @returns {Promise<Object>} Lorebook statistics\r\n */\r\nexport async function getLorebookStats() {\r\n    return withErrorBoundary('getLorebookStats', async () => {\r\n        if (!lorebookName) {\r\n            return {\r\n                name: null,\r\n                entryCount: 0,\r\n                trackedEntries: 0,\r\n                orphanedEntries: 0,\r\n            };\r\n        }\r\n\r\n        const context = stContext.getSillyTavernContext();\r\n\r\n        try {\r\n            const worldInfo = await context.loadWorldInfo(lorebookName);\r\n            const characters = settings.getCharacters();\r\n\r\n            if (!worldInfo || !worldInfo.entries) {\r\n                return {\r\n                    name: lorebookName,\r\n                    entryCount: 0,\r\n                    trackedEntries: 0,\r\n                    orphanedEntries: 0,\r\n                };\r\n            }\r\n\r\n            const totalEntries = Object.keys(worldInfo.entries).length;\r\n            const trackedIds = Object.values(characters)\r\n                .map(char => char.lorebookEntryId)\r\n                .filter(id => id);\r\n            const trackedEntries = trackedIds.length;\r\n            const orphanedEntries = totalEntries - trackedEntries;\r\n\r\n            return {\r\n                name: lorebookName,\r\n                entryCount: totalEntries,\r\n                trackedEntries,\r\n                orphanedEntries,\r\n            };\r\n        } catch (error) {\r\n            console.error('Error getting lorebook stats:', error);\r\n            return {\r\n                name: lorebookName,\r\n                entryCount: 0,\r\n                trackedEntries: 0,\r\n                orphanedEntries: 0,\r\n                error: error.message,\r\n            };\r\n        }\r\n    });\r\n}\n","/**\r\n * Message Processing Module\r\n *\r\n * Handles message analysis workflows, batch processing, and SillyTavern event handling\r\n * for the Name Tracker extension.\r\n */\r\n\r\nimport { createModuleLogger } from '../core/debug.js';\r\nimport { withErrorBoundary, NameTrackerError } from '../core/errors.js';\r\nimport { settings } from '../core/settings.js';\r\nimport { stContext } from '../core/context.js';\r\nimport { NotificationManager } from '../utils/notifications.js';\r\nimport { callLLMAnalysis, buildCharacterRoster, getMaxPromptLength, calculateMessageTokens } from './llm.js';\r\nimport { createCharacter, updateCharacter, findExistingCharacter, findPotentialMatch, isIgnoredCharacter } from './characters.js';\r\nimport { updateLorebookEntry } from './lorebook.js';\r\n\r\nconst debug = createModuleLogger('processing');\r\nconst notifications = new NotificationManager('Message Processing');\r\n\r\n// Processing state\r\nlet processingQueue = [];\r\nlet isProcessing = false;\r\nlet abortScan = false;\r\n\r\n/**\r\n * Process analysis results from LLM\r\n * @param {Array} analyzedCharacters - Array of character data from LLM\r\n * @returns {Promise<void>}\r\n */\r\nexport async function processAnalysisResults(analyzedCharacters) {\r\n    return withErrorBoundary('processAnalysisResults', async () => {\r\n        if (!analyzedCharacters || !Array.isArray(analyzedCharacters)) {\r\n            debug('No characters to process');\r\n            return;\r\n        }\r\n\r\n        debug(`Processing ${analyzedCharacters.length} analyzed characters`);\r\n\r\n        for (const analyzedChar of analyzedCharacters) {\r\n            try {\r\n                await processCharacterData(analyzedChar);\r\n            } catch (error) {\r\n                console.error(`Error processing character ${analyzedChar.name}:`, error);\r\n                // Continue with other characters\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Process individual character data from LLM analysis\r\n * @param {Object} analyzedChar - Character data from LLM\r\n * @returns {Promise<void>}\r\n */\r\nasync function processCharacterData(analyzedChar) {\r\n    return withErrorBoundary('processCharacterData', async () => {\r\n        if (!analyzedChar.name || analyzedChar.name.trim() === '') {\r\n            debug('Skipping character with empty name');\r\n            return;\r\n        }\r\n\r\n        const characterName = analyzedChar.name.trim();\r\n\r\n        // Check if character is ignored\r\n        if (isIgnoredCharacter(characterName)) {\r\n            debug(`Ignoring character: ${characterName}`);\r\n            return;\r\n        }\r\n\r\n        // Check for main character detection\r\n        const isMainChar = characterName.toLowerCase().includes('{{char}}') ||\r\n                          analyzedChar.isMainCharacter === true ||\r\n                          analyzedChar.role === 'main';\r\n\r\n        // Check if character already exists\r\n        const existingChar = findExistingCharacter(characterName);\r\n\r\n        if (existingChar) {\r\n            // Update existing character\r\n            await updateCharacter(existingChar, analyzedChar, false, isMainChar);\r\n            await updateLorebookEntry(existingChar, existingChar.preferredName);\r\n            debug(`Updated existing character: ${existingChar.preferredName}`);\r\n        } else {\r\n            // Check for potential matches (similar names)\r\n            const potentialMatch = await findPotentialMatch(analyzedChar);\r\n\r\n            if (potentialMatch) {\r\n                // Update potential match and add as alias\r\n                await updateCharacter(potentialMatch, analyzedChar, true, isMainChar);\r\n                await updateLorebookEntry(potentialMatch, potentialMatch.preferredName);\r\n                debug(`Updated potential match: ${potentialMatch.preferredName} (added alias: ${characterName})`);\r\n            } else {\r\n                // Create new character\r\n                const newCharacter = await createCharacter(analyzedChar, isMainChar);\r\n                await updateLorebookEntry(newCharacter, newCharacter.preferredName);\r\n                debug(`Created new character: ${newCharacter.preferredName}`);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Harvest and analyze messages\r\n * @param {number} messageCount - Number of recent messages to analyze\r\n * @param {boolean} showProgress - Whether to show progress notifications\r\n * @returns {Promise<void>}\r\n */\r\nexport async function harvestMessages(messageCount, showProgress = true) {\r\n    return withErrorBoundary('harvestMessages', async () => {\r\n        if (!settings.getSetting('enabled', true)) {\r\n            debug('Extension disabled, skipping harvest');\r\n            return;\r\n        }\r\n\r\n        // Check API connection for SillyTavern mode\r\n        const llmConfig = settings.getLLMConfig();\r\n        if (llmConfig.source === 'sillytavern') {\r\n            const context = stContext.getSillyTavernContext();\r\n            if (!context.onlineStatus) {\r\n                notifications.warning('Please connect to an API (OpenAI, Claude, etc.) before analyzing messages');\r\n                return;\r\n            }\r\n        }\r\n\r\n        const context = stContext.getSillyTavernContext();\r\n        if (!context.chat || context.chat.length === 0) {\r\n            debug('No chat messages to harvest');\r\n            notifications.info('No messages in chat to analyze');\r\n            return;\r\n        }\r\n\r\n        // Get the messages to analyze - count forward and check token limits\r\n        const endIdx = context.chat.length;\r\n        const startIdx = Math.max(0, endIdx - messageCount);\r\n        const messagesToAnalyze = context.chat.slice(startIdx, endIdx);\r\n\r\n        // Check if messages fit in context window\r\n        const maxPromptTokens = await getMaxPromptLength();\r\n        const availableTokens = maxPromptTokens - 1000; // Reserve for system prompt and response\r\n\r\n        // Calculate actual token count for the requested messages\r\n        const messageTokens = await calculateMessageTokens(messagesToAnalyze);\r\n\r\n        // If too large, split into batches\r\n        if (messageTokens > availableTokens) {\r\n            debug(`Requested ${messagesToAnalyze.length} messages (${messageTokens} tokens) exceeds context (${availableTokens} tokens), splitting into batches...`);\r\n\r\n            // Calculate optimal batch size based on tokens\r\n            const batches = [];\r\n            let currentBatch = [];\r\n            let currentTokens = 0;\r\n\r\n            // Build batches by adding messages until token limit\r\n            for (const msg of messagesToAnalyze) {\r\n                const msgTokens = await calculateMessageTokens([msg]);\r\n\r\n                if (currentTokens + msgTokens > availableTokens && currentBatch.length > 0) {\r\n                    // Current batch is full, start new one\r\n                    batches.push(currentBatch);\r\n                    currentBatch = [msg];\r\n                    currentTokens = msgTokens;\r\n                } else {\r\n                    // Add to current batch\r\n                    currentBatch.push(msg);\r\n                    currentTokens += msgTokens;\r\n                }\r\n            }\r\n\r\n            // Add final batch\r\n            if (currentBatch.length > 0) {\r\n                batches.push(currentBatch);\r\n            }\r\n\r\n            if (showProgress) {\r\n                notifications.info(`Splitting into ${batches.length} batches to fit context window`);\r\n            }\r\n\r\n            // Reset abort flag\r\n            abortScan = false;\r\n\r\n            // Show progress bar\r\n            showProgressBar(0, batches.length, 'Starting analysis...');\r\n\r\n            let successfulBatches = 0;\r\n            let failedBatches = 0;\r\n            const uniqueCharacters = new Set();\r\n\r\n            // Process each batch\r\n            for (let i = 0; i < batches.length; i++) {\r\n                // Check if user aborted\r\n                if (abortScan) {\r\n                    debug('Analysis aborted by user');\r\n                    hideProgressBar();\r\n                    notifications.warning('Analysis aborted');\r\n                    return;\r\n                }\r\n\r\n                const batch = batches[i];\r\n\r\n                // Calculate actual message range for this batch\r\n                const batchStartMsg = batches.slice(0, i).reduce((sum, b) => sum + b.length, 0);\r\n                const batchStart = startIdx + batchStartMsg;\r\n                const batchEnd = batchStart + batch.length;\r\n\r\n                try {\r\n                    showProgressBar(i + 1, batches.length, `Analyzing messages ${batchStart + 1}-${batchEnd}...`);\r\n\r\n                    // Build roster of characters found so far\r\n                    const characterRoster = buildCharacterRoster();\r\n\r\n                    // Call LLM for analysis\r\n                    const analysis = await callLLMAnalysis(batch, characterRoster);\r\n\r\n                    // Process the analysis\r\n                    if (analysis.characters && Array.isArray(analysis.characters)) {\r\n                        await processAnalysisResults(analysis.characters);\r\n                        analysis.characters.forEach(char => uniqueCharacters.add(char.name));\r\n                    }\r\n\r\n                    successfulBatches++;\r\n\r\n                    // Small delay between batches to avoid rate limiting\r\n                    if (i < batches.length - 1) {\r\n                        await new Promise(resolve => setTimeout(resolve, 500));\r\n                    }\r\n\r\n                } catch (error) {\r\n                    console.error(`Error processing batch ${i + 1}:`, error);\r\n                    failedBatches++;\r\n\r\n                    // Ask user if they want to continue\r\n                    const continueOnError = confirm(`Batch ${i + 1} failed.\\\\n\\\\nError: ${error.message}\\\\n\\\\nContinue with remaining batches?`);\r\n                    if (!continueOnError) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Hide progress bar\r\n            hideProgressBar();\r\n\r\n            // Show summary\r\n            const summary = `Analysis complete!\\\\n\\\\nBatches processed: ${successfulBatches}/${batches.length}\\\\nUnique characters found: ${uniqueCharacters.size}\\\\nFailed batches: ${failedBatches}`;\r\n            if (failedBatches > 0) {\r\n                notifications.warning(summary, { timeOut: 8000 });\r\n            } else {\r\n                notifications.success(summary, { timeOut: 8000 });\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // Messages fit in one batch - process normally\r\n        if (showProgress) {\r\n            notifications.info(`Analyzing ${messagesToAnalyze.length} messages for character information...`);\r\n        }\r\n\r\n        try {\r\n            // Build roster of characters found so far\r\n            const characterRoster = buildCharacterRoster();\r\n\r\n            // Call LLM for analysis with character context\r\n            const analysis = await callLLMAnalysis(messagesToAnalyze, characterRoster);\r\n\r\n            debug('Analysis result:', analysis);\r\n\r\n            // Process the analysis\r\n            if (analysis.characters && Array.isArray(analysis.characters)) {\r\n                await processAnalysisResults(analysis.characters);\r\n\r\n                if (showProgress) {\r\n                    notifications.success(`Found ${analysis.characters.length} character(s) in messages`);\r\n                }\r\n            } else {\r\n                debug('No characters found in analysis');\r\n            }\r\n\r\n        } catch (error) {\r\n            console.error('Error during harvest:', error);\r\n            notifications.error(`Analysis failed: ${error.message}`);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Handle new message event\r\n * @param {number} messageId - ID of the new message\r\n * @returns {Promise<void>}\r\n */\r\nexport async function onMessageReceived(messageId) {\r\n    return withErrorBoundary('onMessageReceived', async () => {\r\n        if (!settings.getSetting('enabled', true) || !settings.getSetting('autoAnalyze', true)) {\r\n            return;\r\n        }\r\n\r\n        const context = stContext.getSillyTavernContext();\r\n        const chat = context.chat;\r\n\r\n        if (!chat || chat.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Get the current message index\r\n        const currentMessageIndex = chat.length - 1;\r\n\r\n        // Check if this message was already scanned\r\n        const lastScannedId = settings.getSetting('lastScannedMessageId', -1);\r\n        if (currentMessageIndex <= lastScannedId) {\r\n            debug(`Message ${currentMessageIndex} already scanned (last scanned: ${lastScannedId})`);\r\n            return;\r\n        }\r\n\r\n        // Detect if messages were deleted (current index jumped backwards)\r\n        if (lastScannedId >= 0 && currentMessageIndex < lastScannedId) {\r\n            debug(`Message deletion detected: current=${currentMessageIndex}, last scanned=${lastScannedId}`);\r\n\r\n            // Prompt user for rescan decision\r\n            const shouldRescan = await showRescanModal(currentMessageIndex, lastScannedId);\r\n\r\n            if (shouldRescan.rescan) {\r\n                settings.setSetting('lastScannedMessageId', shouldRescan.fromMessage - 1);\r\n\r\n                // Queue a full scan from the specified message\r\n                addToQueue(async () => {\r\n                    await harvestMessages(currentMessageIndex - shouldRescan.fromMessage + 1, true);\r\n                });\r\n\r\n                return;\r\n            } else {\r\n                // Reset to current position without scanning\r\n                settings.setSetting('lastScannedMessageId', currentMessageIndex);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Check if we've reached the next scan milestone\r\n        const messageFreq = settings.getSetting('messageFrequency', 10);\r\n        const messagesSinceLastScan = currentMessageIndex - lastScannedId;\r\n\r\n        if (messagesSinceLastScan >= messageFreq) {\r\n            debug(`Scan milestone reached: ${messagesSinceLastScan} messages since last scan`);\r\n\r\n            // Queue harvest\r\n            addToQueue(async () => {\r\n                await harvestMessages(messageFreq, true);\r\n                // Update last scanned message ID after successful harvest\r\n                settings.setSetting('lastScannedMessageId', currentMessageIndex);\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Show rescan modal when message deletion is detected\r\n * @param {number} currentMessageIndex - Current message index\r\n * @param {number} lastScannedId - Last scanned message ID\r\n * @returns {Promise<Object>} Rescan decision\r\n */\r\nasync function showRescanModal(currentMessageIndex, lastScannedId) {\r\n    return new Promise((resolve) => {\r\n        const modal = $(`\r\n            <div class=\"name-tracker-rescan-modal\" style=\"position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--SmartThemeBodyColor); border: 2px solid var(--SmartThemeBorderColor); padding: 20px; border-radius: 10px; z-index: 9999; max-width: 500px;\">\r\n                <h3>Message History Changed</h3>\r\n                <p>Messages have been deleted or edited. Would you like to rescan the chat?</p>\r\n                <p>Current last scanned message: ${lastScannedId}<br>\r\n                Current message index: ${currentMessageIndex}</p>\r\n                <div style=\"margin-top: 15px;\">\r\n                    <label>Rescan from message: <input type=\"number\" id=\"rescan-from\" value=\"0\" min=\"0\" max=\"${currentMessageIndex}\" style=\"width: 80px; margin-left: 10px;\"></label>\r\n                </div>\r\n                <div style=\"margin-top: 15px; text-align: right;\">\r\n                    <button id=\"rescan-yes\" class=\"menu_button\">Rescan</button>\r\n                    <button id=\"rescan-no\" class=\"menu_button\">Skip</button>\r\n                </div>\r\n            </div>\r\n        `);\r\n\r\n        $('body').append(modal);\r\n\r\n        modal.find('#rescan-yes').on('click', () => {\r\n            const fromMessage = parseInt(modal.find('#rescan-from').val()) || 0;\r\n            modal.remove();\r\n            resolve({ rescan: true, fromMessage });\r\n        });\r\n\r\n        modal.find('#rescan-no').on('click', () => {\r\n            modal.remove();\r\n            resolve({ rescan: false });\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * Show progress bar for batch scanning\r\n * @param {number} current - Current batch number (1-indexed)\r\n * @param {number} total - Total number of batches\r\n * @param {string} status - Status message\r\n */\r\nfunction showProgressBar(current, total, status = '') {\r\n    const progressBarId = 'name_tracker_progress';\r\n    const $existing = $(`.${progressBarId}`);\r\n\r\n    if ($existing.length > 0) {\r\n        // Update existing progress bar\r\n        if (status) $existing.find('.title').text(status);\r\n        $existing.find('.progress').text(current);\r\n        $existing.find('.total').text(total);\r\n        $existing.find('progress').val(current).attr('max', total);\r\n        return;\r\n    }\r\n\r\n    // Create new progress bar\r\n    const bar = $(`\r\n        <div class=\"${progressBarId} name_tracker_progress_bar flex-container justifyspacebetween alignitemscenter\" style=\"\r\n            padding: 10px;\r\n            margin: 5px 0;\r\n            background: var(--SmartThemeBlurTintColor);\r\n            border: 1px solid var(--SmartThemeBorderColor);\r\n            border-radius: 5px;\r\n        \">\r\n            <div class=\"title\" style=\"flex: 1; font-weight: bold;\">${status || 'Name Tracker Scan'}</div>\r\n            <div style=\"margin: 0 10px;\">(<span class=\"progress\">${current}</span> / <span class=\"total\">${total}</span>)</div>\r\n            <progress value=\"${current}\" max=\"${total}\" style=\"flex: 2; margin: 0 10px;\"></progress>\r\n            <button class=\"menu_button fa-solid fa-stop\" title=\"Abort scan\" style=\"padding: 5px 10px;\"></button>\r\n        </div>\r\n    `);\r\n\r\n    // Add click event to abort the scan\r\n    bar.find('button').on('click', function() {\r\n        abortScan = true;\r\n        hideProgressBar();\r\n        notifications.warning('Scan aborted by user');\r\n    });\r\n\r\n    // Append to the main chat area (#sheld)\r\n    $('#sheld').append(bar);\r\n}\r\n\r\n/**\r\n * Hide and remove progress bar\r\n */\r\nfunction hideProgressBar() {\r\n    const progressBarId = 'name_tracker_progress';\r\n    const $existing = $(`.${progressBarId}`);\r\n    if ($existing.length > 0) {\r\n        $existing.fadeOut(300, function() {\r\n            $(this).remove();\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Scan entire chat in batches from oldest to newest\r\n * @returns {Promise<void>}\r\n */\r\nexport async function scanEntireChat() {\r\n    return withErrorBoundary('scanEntireChat', async () => {\r\n        const context = stContext.getSillyTavernContext();\r\n\r\n        if (!context.chat || context.chat.length === 0) {\r\n            notifications.warning('No chat messages to scan');\r\n            return;\r\n        }\r\n\r\n        // Check API connection for SillyTavern mode\r\n        const llmConfig = settings.getLLMConfig();\r\n        if (llmConfig.source === 'sillytavern') {\r\n            if (!context.onlineStatus) {\r\n                notifications.warning('Please connect to an API (OpenAI, Claude, etc.) before analyzing messages');\r\n                return;\r\n            }\r\n        }\r\n\r\n        const totalMessages = context.chat.length;\r\n\r\n        // Calculate optimal batch size based on context window\r\n        const maxPromptTokens = await getMaxPromptLength();\r\n        const availableTokens = maxPromptTokens - 1000;\r\n\r\n        // Build batches dynamically based on token counts\r\n        const batches = [];\r\n        let currentBatch = [];\r\n        let currentTokens = 0;\r\n\r\n        for (let i = 0; i < totalMessages; i++) {\r\n            const msg = context.chat[i];\r\n            const msgTokens = await calculateMessageTokens([msg]);\r\n\r\n            if (currentTokens + msgTokens > availableTokens && currentBatch.length > 0) {\r\n                // Current batch is full, save it and start new one\r\n                batches.push(currentBatch);\r\n                currentBatch = [msg];\r\n                currentTokens = msgTokens;\r\n            } else {\r\n                // Add to current batch\r\n                currentBatch.push(msg);\r\n                currentTokens += msgTokens;\r\n            }\r\n        }\r\n\r\n        // Add final batch\r\n        if (currentBatch.length > 0) {\r\n            batches.push(currentBatch);\r\n        }\r\n\r\n        const numBatches = batches.length;\r\n\r\n        const confirmed = confirm(`This will analyze all ${totalMessages} messages in ${numBatches} batches. This may take a while. Continue?`);\r\n\r\n        if (!confirmed) {\r\n            return;\r\n        }\r\n\r\n        // Reset abort flag\r\n        abortScan = false;\r\n\r\n        // Show progress bar\r\n        showProgressBar(0, numBatches, 'Starting batch scan...');\r\n\r\n        let successfulBatches = 0;\r\n        let failedBatches = 0;\r\n        const uniqueCharacters = new Set(); // Track unique character names\r\n\r\n        // Process from oldest to newest\r\n        for (let i = 0; i < numBatches; i++) {\r\n            // Check if user aborted\r\n            if (abortScan) {\r\n                debug('Scan aborted by user');\r\n                break;\r\n            }\r\n\r\n            const batchMessages = batches[i];\r\n\r\n            // Calculate message range for progress display\r\n            const startIdx = batches.slice(0, i).reduce((sum, b) => sum + b.length, 0);\r\n            const endIdx = startIdx + batchMessages.length;\r\n\r\n            try {\r\n                showProgressBar(i + 1, numBatches, `Processing messages ${startIdx + 1}-${endIdx}...`);\r\n\r\n                // Build roster of characters found so far\r\n                const characterRoster = buildCharacterRoster();\r\n\r\n                // Call LLM for analysis with character context\r\n                const analysis = await callLLMAnalysis(batchMessages, characterRoster);\r\n\r\n                // Process the analysis\r\n                if (analysis.characters && Array.isArray(analysis.characters)) {\r\n                    await processAnalysisResults(analysis.characters);\r\n                    // Track unique characters\r\n                    analysis.characters.forEach(char => uniqueCharacters.add(char.name));\r\n                }\r\n\r\n                successfulBatches++;\r\n\r\n                // Small delay between batches\r\n                if (i < numBatches - 1) {\r\n                    await new Promise(resolve => setTimeout(resolve, 1000));\r\n                }\r\n\r\n            } catch (error) {\r\n                console.error(`Error processing batch ${i + 1}:`, error);\r\n                failedBatches++;\r\n\r\n                // Auto-retry logic could be added here\r\n                const continueOnError = confirm(`Batch ${i + 1} failed.\\\\n\\\\nError: ${error.message}\\\\n\\\\nContinue with remaining batches?`);\r\n                if (!continueOnError) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Hide progress bar\r\n        hideProgressBar();\r\n\r\n        // Update scan completion status\r\n        settings.setSetting('lastScannedMessageId', totalMessages - 1);\r\n\r\n        // Show summary\r\n        const summary = `Full chat scan complete!\\\\n\\\\nMessages: ${totalMessages}\\\\nBatches: ${successfulBatches}/${numBatches}\\\\nCharacters found: ${uniqueCharacters.size}\\\\nFailed: ${failedBatches}`;\r\n        if (failedBatches > 0) {\r\n            notifications.warning(summary, { timeOut: 10000 });\r\n        } else {\r\n            notifications.success(summary, { timeOut: 10000 });\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Add task to processing queue\r\n * @param {Function} task - Async function to execute\r\n * @returns {Promise<void>}\r\n */\r\nexport async function addToQueue(task) {\r\n    return withErrorBoundary('addToQueue', async () => {\r\n        processingQueue.push(task);\r\n\r\n        if (!isProcessing) {\r\n            await processQueue();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Process queued tasks\r\n * @returns {Promise<void>}\r\n */\r\nexport async function processQueue() {\r\n    return withErrorBoundary('processQueue', async () => {\r\n        if (isProcessing || processingQueue.length === 0) {\r\n            return;\r\n        }\r\n\r\n        isProcessing = true;\r\n\r\n        while (processingQueue.length > 0) {\r\n            const task = processingQueue.shift();\r\n            try {\r\n                await task();\r\n            } catch (error) {\r\n                console.error('Error processing queue task:', error);\r\n            }\r\n        }\r\n\r\n        isProcessing = false;\r\n    });\r\n}\r\n\r\n/**\r\n * Handle chat changed event\r\n * @returns {Promise<void>}\r\n */\r\nexport async function onChatChanged() {\r\n    return withErrorBoundary('onChatChanged', async () => {\r\n        debug('Chat changed event triggered');\r\n\r\n        // Clear processing state\r\n        processingQueue = [];\r\n        isProcessing = false;\r\n        abortScan = false;\r\n\r\n        // Reset scan state\r\n        settings.setSetting('lastScannedMessageId', -1);\r\n        settings.setSetting('messageCounter', 0);\r\n\r\n        debug('Chat changed, reset processing state');\r\n    });\r\n}\r\n\r\n/**\r\n * Clear the processing queue\r\n */\r\nexport function clearProcessingQueue() {\r\n    processingQueue = [];\r\n    isProcessing = false;\r\n    debug('Processing queue cleared');\r\n}\r\n\r\n/**\r\n * Get processing status\r\n * @returns {Object} Processing status information\r\n */\r\nexport function getProcessingStatus() {\r\n    return {\r\n        isProcessing,\r\n        queueLength: processingQueue.length,\r\n        abortScan,\r\n    };\r\n}\r\n\r\n/**\r\n * Abort current scan operation\r\n */\r\nexport function abortCurrentScan() {\r\n    abortScan = true;\r\n    hideProgressBar();\r\n    debug('Scan aborted programmatically');\r\n}\n","/**\r\n * UI Management Module\r\n *\r\n * Handles user interface components, settings panel management, character lists,\r\n * modal dialogs, and progress indicators for the Name Tracker extension.\r\n */\r\n\r\nimport { createModuleLogger } from '../core/debug.js';\r\nimport { withErrorBoundary, NameTrackerError } from '../core/errors.js';\r\nimport { settings } from '../core/settings.js';\r\nimport { stContext } from '../core/context.js';\r\nimport { escapeHtml } from '../utils/helpers.js';\r\nimport { NotificationManager } from '../utils/notifications.js';\r\nimport { mergeCharacters, toggleIgnoreCharacter, createNewCharacter, purgeAllCharacters, hasUnresolvedRelationships } from './characters.js';\r\nimport { loadOllamaModels } from './llm.js';\r\nimport { harvestMessages, scanEntireChat, clearProcessingQueue } from './processing.js';\r\nimport { viewInLorebook } from './lorebook.js';\r\n\r\nconst debug = createModuleLogger('ui');\r\nconst notifications = new NotificationManager('UI Management');\r\n\r\n/**\r\n * Update character list display in settings\r\n * @returns {void}\r\n */\r\nexport function updateCharacterList() {\r\n    return withErrorBoundary('updateCharacterList', () => {\r\n        const $container = $('#name_tracker_character_list');\r\n        if ($container.length === 0) {\r\n            debug('Character list container not found');\r\n            return;\r\n        }\r\n\r\n        const characters = settings.getCharacters();\r\n        const characterNames = Object.keys(characters);\r\n\r\n        if (characterNames.length === 0) {\r\n            $container.html(`\r\n                <div class=\"name_tracker_no_characters\">\r\n                    <p style=\"text-align: center; color: var(--SmartThemeQuoteColor);\">\r\n                        No characters tracked yet. Start a conversation and character information will be extracted automatically!\r\n                    </p>\r\n                </div>\r\n            `);\r\n            return;\r\n        }\r\n\r\n        // Sort characters: Main characters first, then alphabetically\r\n        const sortedCharacters = Object.values(characters).sort((a, b) => {\r\n            if (a.isMainChar && !b.isMainChar) return -1;\r\n            if (!a.isMainChar && b.isMainChar) return 1;\r\n            return a.preferredName.localeCompare(b.preferredName);\r\n        });\r\n\r\n        let html = '<div class=\"name_tracker_character_list\">';\r\n\r\n        for (const character of sortedCharacters) {\r\n            const charIcon = character.isMainChar ? '<i class=\"fa-solid fa-user\"></i>' : '';\r\n            const ignoreIcon = character.ignored ? '<span class=\"char-ignored-badge\">IGNORED</span>' : '';\r\n            const reviewBadge = hasUnresolvedRelationships(character) ? '<span class=\"char-review-badge\">NEEDS REVIEW</span>' : '';\r\n\r\n            const aliasText = character.aliases && character.aliases.length > 0\r\n                ? `<div class=\"char-aliases\">Aliases: ${escapeHtml(character.aliases.join(', '))}</div>`\r\n                : '';\r\n\r\n            const relationshipText = character.relationships && character.relationships.length > 0\r\n                ? `<div class=\"char-relationships\">Relationships: ${escapeHtml(character.relationships.join('; '))}</div>`\r\n                : '';\r\n\r\n            const lastUpdated = character.lastUpdated\r\n                ? new Date(character.lastUpdated).toLocaleString()\r\n                : 'Never';\r\n\r\n            html += `\r\n                <div class=\"name_tracker_character_item\" data-character=\"${escapeHtml(character.preferredName)}\">\r\n                    <div class=\"char-header\">\r\n                        <span class=\"char-name\">\r\n                            ${charIcon}\r\n                            ${escapeHtml(character.preferredName)}\r\n                            ${ignoreIcon}\r\n                            ${reviewBadge}\r\n                        </span>\r\n                        <div class=\"char-actions\">\r\n                            <button class=\"char-action-btn char-action-edit\" data-name=\"${escapeHtml(character.preferredName)}\" title=\"Edit lorebook entry\">\r\n                                <i class=\"fa-solid fa-edit\"></i>\r\n                            </button>\r\n                            <button class=\"char-action-btn char-action-view\" data-name=\"${escapeHtml(character.preferredName)}\" title=\"View in lorebook\">\r\n                                <i class=\"fa-solid fa-book\"></i>\r\n                            </button>\r\n                            <button class=\"char-action-btn char-action-merge\" data-name=\"${escapeHtml(character.preferredName)}\" title=\"Merge with another character\">\r\n                                <i class=\"fa-solid fa-code-merge\"></i>\r\n                            </button>\r\n                            <button class=\"char-action-btn char-action-ignore\" data-name=\"${escapeHtml(character.preferredName)}\" title=\"${character.ignored ? 'Unignore' : 'Ignore'} character\">\r\n                                <i class=\"fa-solid ${character.ignored ? 'fa-eye' : 'fa-eye-slash'}\"></i>\r\n                            </button>\r\n                        </div>\r\n                    </div>\r\n                    ${aliasText}\r\n                    ${relationshipText}\r\n                    <div class=\"char-metadata\">\r\n                        <span>Confidence: ${character.confidence}%</span>\r\n                        <span>Updated: ${lastUpdated}</span>\r\n                    </div>\r\n                </div>\r\n            `;\r\n        }\r\n\r\n        html += '</div>';\r\n        $container.html(html);\r\n    });\r\n}\r\n\r\n/**\r\n * Update status display in settings\r\n * @returns {void}\r\n */\r\nexport function updateStatusDisplay() {\r\n    return withErrorBoundary('updateStatusDisplay', () => {\r\n        const $statusContainer = $('#name_tracker_status_display');\r\n        if ($statusContainer.length === 0) {\r\n            return;\r\n        }\r\n\r\n        const characters = settings.getCharacters();\r\n        const characterCount = Object.keys(characters).length;\r\n        const messageCounter = settings.getSetting('messageCounter', 0);\r\n        const lastScannedId = settings.getSetting('lastScannedMessageId', -1);\r\n        const messageFreq = settings.getSetting('messageFrequency', 10);\r\n\r\n        const context = stContext.getSillyTavernContext();\r\n        const currentChatLength = context.chat ? context.chat.length : 0;\r\n        const messagesToNextScan = Math.max(0, messageFreq - (currentChatLength - lastScannedId));\r\n\r\n        const statusHtml = `\r\n            <div class=\"name_tracker_status\">\r\n                <div class=\"status-item\">\r\n                    <strong>Characters tracked:</strong> ${characterCount}\r\n                </div>\r\n                <div class=\"status-item\">\r\n                    <strong>Messages in chat:</strong> ${currentChatLength}\r\n                </div>\r\n                <div class=\"status-item\">\r\n                    <strong>Last scanned message:</strong> ${lastScannedId >= 0 ? lastScannedId + 1 : 'None'}\r\n                </div>\r\n                <div class=\"status-item\">\r\n                    <strong>Messages until next scan:</strong> ${messagesToNextScan}\r\n                </div>\r\n            </div>\r\n        `;\r\n\r\n        $statusContainer.html(statusHtml);\r\n    });\r\n}\r\n\r\n/**\r\n * Show character merge dialog\r\n * @param {string} sourceName - Name of source character\r\n * @returns {Promise<void>}\r\n */\r\nexport async function showMergeDialog(sourceName) {\r\n    return withErrorBoundary('showMergeDialog', async () => {\r\n        const characters = settings.getCharacters();\r\n\r\n        // Create list of other characters\r\n        const otherChars = Object.keys(characters).filter(name => name !== sourceName);\r\n\r\n        if (otherChars.length === 0) {\r\n            notifications.warning('No other characters to merge with');\r\n            return;\r\n        }\r\n\r\n        // Simple prompt for target character\r\n        const targetName = prompt(`Merge \"${sourceName}\" into which character? Available: ${otherChars.join(', ')}`);\r\n        if (targetName && characters[targetName]) {\r\n            await mergeCharacters(sourceName, targetName);\r\n            updateCharacterList();\r\n            updateStatusDisplay();\r\n        } else if (targetName) {\r\n            notifications.error('Invalid target character name');\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Show character creation modal\r\n * @returns {Promise<void>}\r\n */\r\nexport async function showCreateCharacterModal() {\r\n    return withErrorBoundary('showCreateCharacterModal', async () => {\r\n        const characterName = prompt('Enter character name:');\r\n\r\n        if (!characterName || !characterName.trim()) {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            await createNewCharacter(characterName.trim());\r\n            updateCharacterList();\r\n            updateStatusDisplay();\r\n        } catch (error) {\r\n            notifications.error(error.message);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Show purge confirmation dialog\r\n * @returns {Promise<void>}\r\n */\r\nexport async function showPurgeConfirmation() {\r\n    return withErrorBoundary('showPurgeConfirmation', async () => {\r\n        const characters = settings.getCharacters();\r\n        const characterCount = Object.keys(characters).length;\r\n\r\n        if (characterCount === 0) {\r\n            notifications.info('No characters to purge');\r\n            return;\r\n        }\r\n\r\n        const confirmed = confirm(`This will delete all ${characterCount} tracked characters and their lorebook entries.\\\\n\\\\nThis action cannot be undone!\\\\n\\\\nContinue?`);\r\n\r\n        if (confirmed) {\r\n            try {\r\n                const deletedCount = await purgeAllCharacters();\r\n                updateCharacterList();\r\n                updateStatusDisplay();\r\n                notifications.success(`Purged ${deletedCount} characters`);\r\n            } catch (error) {\r\n                notifications.error(`Failed to purge characters: ${error.message}`);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Show system prompt editor modal\r\n * @returns {Promise<void>}\r\n */\r\nexport async function showSystemPromptEditor() {\r\n    return withErrorBoundary('showSystemPromptEditor', async () => {\r\n        const currentPrompt = settings.getSetting('systemPrompt') || '';\r\n\r\n        // Create modal dialog\r\n        const modal = $(`\r\n            <div class=\"nametracker-modal\" style=\"\r\n                position: fixed;\r\n                top: 50%;\r\n                left: 50%;\r\n                transform: translate(-50%, -50%);\r\n                background: var(--SmartThemeBlurTintColor);\r\n                border: 1px solid var(--SmartThemeBorderColor);\r\n                border-radius: 10px;\r\n                padding: 20px;\r\n                max-width: 700px;\r\n                width: 90%;\r\n                max-height: 80vh;\r\n                overflow-y: auto;\r\n                z-index: 9999;\r\n                box-shadow: 0 4px 20px rgba(0,0,0,0.5);\r\n            \">\r\n                <h3 style=\"margin-top: 0;\">Edit System Prompt</h3>\r\n                <p>Customize the system prompt used for character analysis. Leave blank to use default.</p>\r\n                <textarea id=\"system_prompt_editor\" rows=\"20\" style=\"width: 100%; margin: 10px 0;\" \r\n                          placeholder=\"Enter custom system prompt or leave blank for default...\">${escapeHtml(currentPrompt)}</textarea>\r\n                <div style=\"margin-top: 20px; text-align: right;\">\r\n                    <button class=\"menu_button\" id=\"system_prompt_save\">Save</button>\r\n                    <button class=\"menu_button\" id=\"system_prompt_reset\">Reset to Default</button>\r\n                    <button class=\"menu_button\" id=\"system_prompt_cancel\">Cancel</button>\r\n                </div>\r\n            </div>\r\n        `);\r\n\r\n        const overlay = $(`\r\n            <div class=\"nametracker-overlay\" style=\"\r\n                position: fixed;\r\n                top: 0;\r\n                left: 0;\r\n                width: 100%;\r\n                height: 100%;\r\n                background: rgba(0,0,0,0.7);\r\n                z-index: 9998;\r\n            \"></div>\r\n        `);\r\n\r\n        $('body').append(overlay).append(modal);\r\n\r\n        const removeModal = () => {\r\n            modal.remove();\r\n            overlay.remove();\r\n        };\r\n\r\n        modal.find('#system_prompt_save').on('click', () => {\r\n            const newPrompt = modal.find('#system_prompt_editor').val().trim();\r\n            settings.setSetting('systemPrompt', newPrompt || null);\r\n            notifications.success('System prompt updated');\r\n            removeModal();\r\n        });\r\n\r\n        modal.find('#system_prompt_reset').on('click', () => {\r\n            modal.find('#system_prompt_editor').val('');\r\n            settings.setSetting('systemPrompt', null);\r\n            notifications.success('Reset to default system prompt');\r\n            removeModal();\r\n        });\r\n\r\n        modal.find('#system_prompt_cancel').on('click', removeModal);\r\n        overlay.on('click', removeModal);\r\n    });\r\n}\r\n\r\n/**\r\n * Show character list modal\r\n * @returns {void}\r\n */\r\nexport function showCharacterListModal() {\r\n    return withErrorBoundary('showCharacterListModal', () => {\r\n        const characters = Object.values(settings.getCharacters() || {});\r\n\r\n        // Build character list HTML\r\n        let charactersHtml = '';\r\n\r\n        if (characters.length === 0) {\r\n            charactersHtml = '<p style=\"text-align: center; color: var(--SmartThemeQuoteColor);\">No characters tracked yet</p>';\r\n        } else {\r\n            // Sort: Main characters first, then by name\r\n            characters.sort((a, b) => {\r\n                if (a.isMainChar && !b.isMainChar) return -1;\r\n                if (!a.isMainChar && b.isMainChar) return 1;\r\n                return a.preferredName.localeCompare(b.preferredName);\r\n            });\r\n\r\n            charactersHtml = '<div style=\"max-height: 400px; overflow-y: auto;\">';\r\n            for (const char of characters) {\r\n                const badges = [];\r\n                if (char.isMainChar) badges.push('<span style=\"background: var(--SmartThemeBodyColor); padding: 2px 6px; border-radius: 3px; font-size: 0.85em; margin-left: 5px;\">MAIN</span>');\r\n                if (char.ignored) badges.push('<span style=\"background: var(--black70a); padding: 2px 6px; border-radius: 3px; font-size: 0.85em; margin-left: 5px;\">IGNORED</span>');\r\n                if (hasUnresolvedRelationships(char)) badges.push('<span style=\"background: var(--crimsonDark); padding: 2px 6px; border-radius: 3px; font-size: 0.85em; margin-left: 5px;\">NEEDS REVIEW</span>');\r\n\r\n                const aliasText = char.aliases && char.aliases.length > 0\r\n                    ? `<div style=\"font-size: 0.9em; color: var(--SmartThemeQuoteColor); margin-top: 3px;\">Aliases: ${escapeHtml(char.aliases.join(', '))}</div>`\r\n                    : '';\r\n\r\n                charactersHtml += `\r\n                    <div style=\"padding: 10px; margin: 5px 0; background: var(--SmartThemeBlurTintColor); border: 1px solid var(--SmartThemeBorderColor); border-radius: 5px;\">\r\n                        <div style=\"font-weight: bold;\">\r\n                            ${char.isMainChar ? '<i class=\"fa-solid fa-user\" style=\"margin-right: 5px;\"></i>' : ''}\r\n                            ${escapeHtml(char.preferredName)}\r\n                            ${badges.join('')}\r\n                        </div>\r\n                        ${aliasText}\r\n                    </div>\r\n                `;\r\n            }\r\n            charactersHtml += '</div>';\r\n        }\r\n\r\n        // Create and show modal\r\n        const modalHtml = `\r\n            <div class=\"name-tracker-character-modal\">\r\n                <h3 style=\"margin-top: 0;\">Tracked Characters (${characters.length})</h3>\r\n                ${charactersHtml}\r\n                <div style=\"margin-top: 15px; text-align: center;\">\r\n                    <button class=\"menu_button\" onclick=\"$('#name_tracker_settings').find('.inline-drawer-toggle').click(); $(this).closest('.popup').remove();\">\r\n                        <i class=\"fa-solid fa-gear\"></i> Open Settings\r\n                    </button>\r\n                </div>\r\n            </div>\r\n        `;\r\n\r\n        const context = stContext.getSillyTavernContext();\r\n        context.callGenericPopup(modalHtml, context.POPUP_TYPE.TEXT, '', { wider: true, okButton: 'Close' });\r\n    });\r\n}\r\n\r\n/**\r\n * Initialize UI event handlers\r\n * @returns {void}\r\n */\r\nexport function initializeUIHandlers() {\r\n    return withErrorBoundary('initializeUIHandlers', () => {\r\n        // Character action handlers\r\n        $(document).on('click', '.char-action-merge', async function() {\r\n            const sourceName = $(this).data('name');\r\n            await showMergeDialog(sourceName);\r\n        });\r\n\r\n        $(document).on('click', '.char-action-ignore', function() {\r\n            const name = $(this).data('name');\r\n            toggleIgnoreCharacter(name);\r\n            updateCharacterList();\r\n            updateStatusDisplay();\r\n        });\r\n\r\n        $(document).on('click', '.char-action-view', async function() {\r\n            const name = $(this).data('name');\r\n            await viewInLorebook(name);\r\n        });\r\n\r\n        $(document).on('click', '.char-action-edit', async function() {\r\n            const name = $(this).data('name');\r\n            await showEditLorebookModal(name);\r\n        });\r\n\r\n        debug('UI event handlers initialized');\r\n    });\r\n}\r\n\r\n/**\r\n * Show edit lorebook entry modal\r\n * @param {string} characterName - Name of character to edit\r\n * @returns {Promise<void>}\r\n */\r\nasync function showEditLorebookModal(characterName) {\r\n    return withErrorBoundary('showEditLorebookModal', async () => {\r\n        const character = settings.getCharacter(characterName);\r\n\r\n        if (!character) {\r\n            notifications.error('Character not found');\r\n            return;\r\n        }\r\n\r\n        // Build edit dialog\r\n        const currentKeys = [characterName, ...(character.aliases || [])].join(', ');\r\n\r\n        const dialogHtml = `\r\n            <div class=\"lorebook-entry-editor\">\r\n                <h3>Edit Lorebook Entry: ${escapeHtml(characterName)}</h3>\r\n                \r\n                <div class=\"editor-section\">\r\n                    <label for=\"entry-keys\">Keys (comma-separated):</label>\r\n                    <input type=\"text\" id=\"entry-keys\" class=\"text_pole\" value=\"${escapeHtml(currentKeys)}\" \r\n                           placeholder=\"${escapeHtml(characterName)}, aliases, nicknames\">\r\n                    <small>These words trigger this entry in the chat context</small>\r\n                </div>\r\n                \r\n                <div class=\"editor-section\">\r\n                    <label for=\"entry-content\">Entry Content:</label>\r\n                    <textarea id=\"entry-content\" rows=\"10\" class=\"text_pole\" \r\n                              placeholder=\"Description, personality, background, relationships...\">${escapeHtml(character.notes || '')}</textarea>\r\n                    <small>This will be injected into context when keys are mentioned</small>\r\n                </div>\r\n                \r\n                <div class=\"editor-section\">\r\n                    <label for=\"entry-relationships\">Relationships:</label>\r\n                    <textarea id=\"entry-relationships\" rows=\"3\" class=\"text_pole\" \r\n                              placeholder=\"Friend of Alice; Enemy of Bob; Works for XYZ Corp\">${escapeHtml((character.relationships || []).join('; '))}</textarea>\r\n                    <small>One relationship per line or semicolon-separated</small>\r\n                </div>\r\n            </div>\r\n        `;\r\n\r\n        // Create simple modal dialog\r\n        const modal = $(`\r\n            <div class=\"nametracker-modal\" style=\"\r\n                position: fixed;\r\n                top: 50%;\r\n                left: 50%;\r\n                transform: translate(-50%, -50%);\r\n                background: var(--SmartThemeBlurTintColor);\r\n                border: 1px solid var(--SmartThemeBorderColor);\r\n                border-radius: 10px;\r\n                padding: 20px;\r\n                max-width: 600px;\r\n                width: 90%;\r\n                max-height: 80vh;\r\n                overflow-y: auto;\r\n                z-index: 9999;\r\n                box-shadow: 0 4px 20px rgba(0,0,0,0.5);\r\n            \">\r\n                ${dialogHtml}\r\n                <div style=\"margin-top: 20px; text-align: right;\">\r\n                    <button class=\"menu_button\" id=\"entry-save\">Save</button>\r\n                    <button class=\"menu_button\" id=\"entry-cancel\">Cancel</button>\r\n                </div>\r\n            </div>\r\n        `);\r\n\r\n        const overlay = $(`\r\n            <div class=\"nametracker-overlay\" style=\"\r\n                position: fixed;\r\n                top: 0;\r\n                left: 0;\r\n                width: 100%;\r\n                height: 100%;\r\n                background: rgba(0,0,0,0.7);\r\n                z-index: 9998;\r\n            \"></div>\r\n        `);\r\n\r\n        $('body').append(overlay).append(modal);\r\n\r\n        const removeModal = () => {\r\n            modal.remove();\r\n            overlay.remove();\r\n        };\r\n\r\n        modal.find('#entry-save').on('click', async () => {\r\n            const keys = modal.find('#entry-keys').val().split(',').map(k => k.trim()).filter(k => k);\r\n            const content = modal.find('#entry-content').val();\r\n            const relationships = modal.find('#entry-relationships').val()\r\n                .split(/[;\\\\n]/)\r\n                .map(r => r.trim())\r\n                .filter(r => r);\r\n\r\n            // Update character data\r\n            const preferredName = keys[0] || characterName;\r\n            const aliases = keys.slice(1);\r\n\r\n            character.preferredName = preferredName;\r\n            character.aliases = aliases;\r\n            character.notes = content;\r\n            character.relationships = relationships;\r\n\r\n            // If preferred name changed, need to update the key in settings\r\n            if (preferredName !== characterName) {\r\n                settings.removeCharacter(characterName);\r\n            }\r\n            settings.setCharacter(preferredName, character);\r\n\r\n            updateCharacterList();\r\n            updateStatusDisplay();\r\n\r\n            notifications.success(`Updated lorebook entry for ${preferredName}`);\r\n            removeModal();\r\n        });\r\n\r\n        modal.find('#entry-cancel').on('click', removeModal);\r\n        overlay.on('click', removeModal);\r\n    });\r\n}\r\n\r\n/**\r\n * Add a menu button to the extensions menu\r\n * @param {string} text - Button text\r\n * @param {string} faIcon - Font Awesome icon classes\r\n * @param {Function} callback - Click handler\r\n * @param {string} hover - Tooltip text\r\n * @param {string} className - Optional additional CSS class\r\n * @returns {void}\r\n */\r\nexport function addMenuButton(text, faIcon, callback, hover = null, className = '') {\r\n    return withErrorBoundary('addMenuButton', () => {\r\n        const $button = $(`\r\n            <div class=\"list-group-item flex-container flexGap5 interactable ${className}\" title=\"${hover || text}\" tabindex=\"0\">\r\n                <i class=\"${faIcon}\"></i>\r\n                <span>${text}</span>\r\n            </div>\r\n        `);\r\n\r\n        const $extensionsMenu = $('#extensionsMenu');\r\n        if (!$extensionsMenu.length) {\r\n            console.error('[Name Tracker] Could not find the extensions menu');\r\n            return;\r\n        }\r\n\r\n        $button.appendTo($extensionsMenu);\r\n        $button.on('click', () => callback());\r\n    });\r\n}\r\n\r\n/**\r\n * Toggle auto-harvest on/off\r\n * @returns {void}\r\n */\r\nexport function toggleAutoHarvest() {\r\n    return withErrorBoundary('toggleAutoHarvest', () => {\r\n        const currentValue = settings.getSetting('autoAnalyze', true);\r\n        settings.setSetting('autoAnalyze', !currentValue);\r\n\r\n        // Update the settings UI\r\n        $('#name_tracker_auto_analyze').prop('checked', !currentValue);\r\n\r\n        // Update menu button icon to reflect state\r\n        const $menuButton = $('#extensionsMenu .name-tracker-toggle-harvest');\r\n        if (!currentValue) {\r\n            $menuButton.find('i').removeClass('fa-toggle-off').addClass('fa-toggle-on');\r\n        } else {\r\n            $menuButton.find('i').removeClass('fa-toggle-on').addClass('fa-toggle-off');\r\n        }\r\n\r\n        updateStatusDisplay();\r\n\r\n        notifications.success(\r\n            `Auto-harvest ${!currentValue ? 'enabled' : 'disabled'}`,\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Open the chat lorebook in the World Info editor\r\n * @returns {Promise<void>}\r\n */\r\nexport async function openChatLorebook() {\r\n    return withErrorBoundary('openChatLorebook', async () => {\r\n        const context = stContext.getSillyTavernContext();\r\n        const lorebookName = context.chatMetadata?.world_info;\r\n\r\n        if (!lorebookName) {\r\n            notifications.warning('No active chat or lorebook');\r\n            return;\r\n        }\r\n\r\n        if (typeof context.openWorldInfoEditor === 'function') {\r\n            await context.openWorldInfoEditor(lorebookName);\r\n        } else {\r\n            // Fallback: show the world info panel\r\n            $('#WorldInfo').click();\r\n            notifications.info(`Please select \"${lorebookName}\" from the World Info panel`);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Initialize extension menu buttons\r\n * @returns {void}\r\n */\r\nexport function initializeMenuButtons() {\r\n    return withErrorBoundary('initializeMenuButtons', () => {\r\n        // Add toggle auto-harvest button with visual state\r\n        const autoAnalyze = settings.getSetting('autoAnalyze', true);\r\n        const toggleIcon = autoAnalyze ? 'fa-solid fa-toggle-on' : 'fa-solid fa-toggle-off';\r\n        addMenuButton(\r\n            'Toggle Auto-Harvest',\r\n            toggleIcon,\r\n            toggleAutoHarvest,\r\n            'Toggle automatic character harvesting on/off',\r\n            'name-tracker-toggle-harvest',\r\n        );\r\n\r\n        // Add character list button\r\n        addMenuButton(\r\n            'View Characters',\r\n            'fa-solid fa-users',\r\n            showCharacterListModal,\r\n            'View all tracked characters',\r\n        );\r\n\r\n        // Add open lorebook button\r\n        addMenuButton(\r\n            'Open Chat Lorebook',\r\n            'fa-solid fa-book',\r\n            openChatLorebook,\r\n            'Open the Name Tracker chat lorebook in the World Info editor',\r\n        );\r\n\r\n        debug('Extension menu buttons initialized');\r\n    });\r\n}\r\n\r\n/**\r\n * Bind settings UI event handlers\r\n * @returns {void}\r\n */\r\nexport function bindSettingsHandlers() {\r\n    return withErrorBoundary('bindSettingsHandlers', () => {\r\n        // Main settings handlers\r\n        $('#name_tracker_enabled').on('input', (event) => {\r\n            settings.setSetting('enabled', event.target.checked);\r\n            updateStatusDisplay();\r\n        });\r\n\r\n        $('#name_tracker_auto_analyze').on('input', (event) => {\r\n            settings.setSetting('autoAnalyze', event.target.checked);\r\n            updateStatusDisplay();\r\n        });\r\n\r\n        $('#name_tracker_message_frequency').on('input', (event) => {\r\n            settings.setSetting('messageFrequency', parseInt(event.target.value) || 10);\r\n            updateStatusDisplay();\r\n        });\r\n\r\n        $('#name_tracker_llm_source').on('change', (event) => {\r\n            settings.setSetting('llmSource', event.target.value);\r\n        });\r\n\r\n        $('#name_tracker_ollama_endpoint').on('input', (event) => {\r\n            settings.setSetting('ollamaEndpoint', event.target.value);\r\n        });\r\n\r\n        $('#name_tracker_ollama_model').on('change', (event) => {\r\n            settings.setSetting('ollamaModel', event.target.value);\r\n        });\r\n\r\n        $('#name_tracker_load_models').on('click', async () => {\r\n            try {\r\n                await loadOllamaModels();\r\n                notifications.success('Ollama models loaded');\r\n            } catch (error) {\r\n                notifications.error('Failed to load Ollama models');\r\n            }\r\n        });\r\n\r\n        $('#name_tracker_confidence_threshold').on('input', (event) => {\r\n            settings.setSetting('confidenceThreshold', parseInt(event.target.value) || 70);\r\n        });\r\n\r\n        // Lorebook settings handlers\r\n        $('#name_tracker_lorebook_position').on('change', (event) => {\r\n            settings.setSetting('lorebookPosition', parseInt(event.target.value) || 0);\r\n        });\r\n\r\n        $('#name_tracker_lorebook_depth').on('input', (event) => {\r\n            settings.setSetting('lorebookDepth', parseInt(event.target.value) || 1);\r\n        });\r\n\r\n        $('#name_tracker_lorebook_cooldown').on('input', (event) => {\r\n            settings.setSetting('lorebookCooldown', parseInt(event.target.value) || 5);\r\n        });\r\n\r\n        $('#name_tracker_lorebook_probability').on('input', (event) => {\r\n            settings.setSetting('lorebookProbability', parseInt(event.target.value) || 100);\r\n        });\r\n\r\n        $('#name_tracker_lorebook_enabled').on('input', (event) => {\r\n            settings.setSetting('lorebookEnabled', event.target.checked);\r\n        });\r\n\r\n        $('#name_tracker_debug_mode').on('input', (event) => {\r\n            settings.setSetting('debugMode', event.target.checked);\r\n        });\r\n\r\n        // Action button handlers\r\n        $('#name_tracker_manual_analyze').on('click', async () => {\r\n            const messageFreq = settings.getSetting('messageFrequency', 10);\r\n            await harvestMessages(messageFreq, true);\r\n            updateCharacterList();\r\n            updateStatusDisplay();\r\n        });\r\n\r\n        $('#name_tracker_scan_all').on('click', async () => {\r\n            await scanEntireChat();\r\n            updateCharacterList();\r\n            updateStatusDisplay();\r\n        });\r\n\r\n        $('#name_tracker_create_character').on('click', () => {\r\n            showCreateCharacterModal();\r\n        });\r\n\r\n        $('#name_tracker_clear_cache').on('click', () => {\r\n            clearProcessingQueue();\r\n            notifications.info('Cache and processing queue cleared');\r\n        });\r\n\r\n        $('#name_tracker_undo_merge').on('click', async () => {\r\n            const { undoLastMerge } = await import('./characters.js');\r\n            const success = await undoLastMerge();\r\n            if (success) {\r\n                updateCharacterList();\r\n                updateStatusDisplay();\r\n            }\r\n        });\r\n\r\n        $('#name_tracker_purge_entries').on('click', () => {\r\n            showPurgeConfirmation();\r\n        });\r\n\r\n        $('#name_tracker_edit_prompt').on('click', () => {\r\n            showSystemPromptEditor();\r\n        });\r\n\r\n        debug('Settings UI handlers bound');\r\n    });\r\n}\r\n\r\n/**\r\n * Load and inject settings HTML\r\n * @param {string} extensionFolderPath - Path to extension folder\r\n * @returns {Promise<void>}\r\n */\r\nexport async function loadSettingsHTML(extensionFolderPath) {\r\n    return withErrorBoundary('loadSettingsHTML', async () => {\r\n        try {\r\n            // Load the settings HTML\r\n            const settingsHtml = await $.get(`${extensionFolderPath}/settings.html`);\r\n\r\n            // Append to the extensions settings panel\r\n            $('#extensions_settings').append(settingsHtml);\r\n\r\n            debug('Settings HTML loaded and injected');\r\n        } catch (error) {\r\n            console.error('Failed to load settings HTML:', error);\r\n            throw new NameTrackerError(`Failed to load settings HTML: ${error.message}`);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Update UI elements based on current settings\r\n * @returns {void}\r\n */\r\nexport function updateUI() {\r\n    return withErrorBoundary('updateUI', () => {\r\n        // Update all form elements with current settings\r\n        $('#name_tracker_enabled').prop('checked', settings.getSetting('enabled', true));\r\n        $('#name_tracker_auto_analyze').prop('checked', settings.getSetting('autoAnalyze', true));\r\n        $('#name_tracker_message_frequency').val(settings.getSetting('messageFrequency', 10));\r\n        $('#name_tracker_llm_source').val(settings.getSetting('llmSource', 'sillytavern'));\r\n        $('#name_tracker_ollama_endpoint').val(settings.getSetting('ollamaEndpoint', 'http://localhost:11434'));\r\n        $('#name_tracker_ollama_model').val(settings.getSetting('ollamaModel', ''));\r\n        $('#name_tracker_confidence_threshold').val(settings.getSetting('confidenceThreshold', 70));\r\n        $('#name_tracker_lorebook_position').val(settings.getSetting('lorebookPosition', 0));\r\n        $('#name_tracker_lorebook_depth').val(settings.getSetting('lorebookDepth', 1));\r\n        $('#name_tracker_lorebook_cooldown').val(settings.getSetting('lorebookCooldown', 5));\r\n        $('#name_tracker_lorebook_probability').val(settings.getSetting('lorebookProbability', 100));\r\n        $('#name_tracker_lorebook_enabled').prop('checked', settings.getSetting('lorebookEnabled', true));\r\n        $('#name_tracker_debug_mode').prop('checked', settings.getSetting('debugMode', false));\r\n\r\n        // Update character list and status\r\n        updateCharacterList();\r\n        updateStatusDisplay();\r\n\r\n        debug('UI updated with current settings');\r\n    });\r\n}\n","/**\r\n * Name Tracker Extension for SillyTavern - Modular Version\r\n * Main entry point and orchestration\r\n */\r\n\r\n// Import CSS\r\nimport '../style.css';\r\n\r\n// Core infrastructure\r\nimport debugLogger from './core/debug.js';\r\nimport { errorHandler } from './core/errors.js';\r\nimport sillyTavernContext from './core/context.js';\r\nimport settingsManager from './core/settings.js';\r\n\r\n// Utilities\r\nimport notifications from './utils/notifications.js';\r\nimport { /* escapeHtml, generateUID */ } from './utils/helpers.js';\r\n\r\n// Feature modules\r\nimport { /* initializeCharacterManager */ } from './modules/characters.js';\r\nimport { /* initializeLLMManager */ } from './modules/llm.js';\r\nimport { initializeLorebook } from './modules/lorebook.js';\r\nimport { /* initializeProcessingManager */ } from './modules/processing.js';\r\nimport { loadSettingsHTML, initializeUIHandlers, initializeMenuButtons } from './modules/ui.js';\r\n\r\n// Extension name constant - MUST match manifest\r\nconst extensionName = 'STnametracker';\r\nconst extensionFolderPath = `scripts/extensions/third-party/${extensionName}`;\r\n\r\n/**\r\n * Get extension settings - Required for SillyTavern integration\r\n * This is the pattern that SillyTavern expects\r\n * @returns {Object} Extension settings object\r\n */\r\nfunction getSettings() {\r\n    // Use global extension_settings that SillyTavern provides\r\n    return window.extension_settings?.[extensionName] || {};\r\n}\r\n\r\n// Create the logger AFTER the getSettings function is defined\r\nconst logger = debugLogger.createModuleLogger('Main');\r\n\r\n/**\r\n * Name Tracker Extension main class\r\n */\r\nclass NameTrackerExtension {\r\n    constructor() {\r\n        this.initialized = false;\r\n        this.modules = new Map();\r\n    }\r\n\r\n    /**\r\n     * Initialize the extension\r\n     * @returns {Promise<void>}\r\n     */\r\n    async initialize() {\r\n        console.log('[STnametracker] Enter initialize() method');\r\n        return errorHandler.withErrorBoundary('Main', async () => {\r\n            console.log('[STnametracker] Inside error boundary');\r\n            if (this.initialized) {\r\n                console.log('[STnametracker] Already initialized, skipping');\r\n                return;\r\n            }\r\n\r\n            console.log('[STnametracker] Starting initialization sequence');\r\n            logger.log('Starting Name Tracker Extension v2.1.0');\r\n\r\n            // Initialize core systems\r\n            console.log('[STnametracker] Step 1: Initializing core systems...');\r\n            await this.initializeCore();\r\n            console.log('[STnametracker] Step 1: Core systems completed');\r\n\r\n            // Initialize feature modules\r\n            console.log('[STnametracker] Step 2: Initializing feature modules...');\r\n            await this.initializeModules();\r\n            console.log('[STnametracker] Step 2: Feature modules completed');\r\n\r\n            // Setup UI\r\n            console.log('[STnametracker] Step 3: Initializing UI...');\r\n            await this.initializeUI();\r\n            console.log('[STnametracker] Step 3: UI completed');\r\n\r\n            // Register event listeners\r\n            console.log('[STnametracker] Step 4: Registering event listeners...');\r\n            this.registerEventListeners();\r\n            console.log('[STnametracker] Step 4: Event listeners completed');\r\n\r\n            this.initialized = true;\r\n            console.log('[STnametracker] Marking as initialized');\r\n            logger.log('Name Tracker Extension initialized successfully');\r\n            console.log('[STnametracker] Full initialization sequence completed successfully');\r\n\r\n        }, {\r\n            retries: 2,\r\n            fallback: async (error) => {\r\n                logger.error('Failed to initialize extension:', error);\r\n                notifications.error('Failed to initialize', 'Extension Error');\r\n                return false;\r\n            },\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Initialize core infrastructure\r\n     * @returns {Promise<void>}\r\n     */\r\n    async initializeCore() {\r\n        console.log('[STnametracker] initializeCore: Starting...');\r\n        logger.debug('Initializing core systems...');\r\n\r\n        // Connect debug system to settings\r\n        console.log('[STnametracker] initializeCore: Connecting debug system...');\r\n        debugLogger.isDebugEnabled = () => settingsManager.isDebugMode();\r\n        console.log('[STnametracker] initializeCore: Debug system connected');\r\n\r\n        // Initialize settings manager\r\n        console.log('[STnametracker] initializeCore: Initializing settings manager...');\r\n        await settingsManager.initialize();\r\n        console.log('[STnametracker] initializeCore: Settings manager initialized');\r\n\r\n        // Setup error recovery strategies\r\n        this.setupErrorRecovery();\r\n\r\n        logger.debug('Core systems initialized');\r\n    }\r\n\r\n    /**\r\n     * Initialize feature modules\r\n     * @returns {Promise<void>}\r\n     */\r\n    async initializeModules() {\r\n        logger.debug('Initializing feature modules...');\r\n\r\n        try {\r\n            // Initialize lorebook for current chat\r\n            await initializeLorebook();\r\n            \r\n            logger.debug('Feature modules initialized');\r\n        } catch (error) {\r\n            logger.error('Failed to initialize feature modules:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initialize UI components\r\n     * @returns {Promise<void>}\r\n     */\r\n    async initializeUI() {\r\n        console.log('[STnametracker] initializeUI: Starting UI initialization...');\r\n        logger.debug('Initializing UI...');\r\n        \r\n        try {\r\n            // Load settings HTML using proper jQuery pattern\r\n            console.log('[STnametracker] initializeUI: Loading settings HTML from:', `${extensionFolderPath}/settings.html`);\r\n            const settingsHtml = await $.get(`${extensionFolderPath}/settings.html`);\r\n            console.log('[STnametracker] initializeUI: Settings HTML loaded, length:', settingsHtml.length);\r\n            \r\n            console.log('[STnametracker] initializeUI: Finding #extensions_settings element...');\r\n            const targetElement = $('#extensions_settings');\r\n            console.log('[STnametracker] initializeUI: Target element found:', targetElement.length > 0);\r\n            \r\n            targetElement.append(settingsHtml);\r\n            console.log('[STnametracker] initializeUI: Settings HTML appended');\r\n            \r\n            // Initialize UI handlers\r\n            console.log('[STnametracker] initializeUI: Initializing UI handlers...');\r\n            initializeUIHandlers();\r\n            console.log('[STnametracker] initializeUI: UI handlers initialized');\r\n            \r\n            console.log('[STnametracker] initializeUI: Initializing menu buttons...');\r\n            initializeMenuButtons();\r\n            console.log('[STnametracker] initializeUI: Menu buttons initialized');\r\n            \r\n            logger.debug('UI initialized');\r\n        } catch (error) {\r\n            logger.error('Failed to initialize UI:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register SillyTavern event listeners\r\n     */\r\n    registerEventListeners() {\r\n        logger.debug('Registering event listeners...');\r\n        \r\n        try {\r\n            // Get event objects from SillyTavern context\r\n            const context = sillyTavernContext.getContext();\r\n            const eventSource = context.eventSource;\r\n            const event_types = context.event_types;\r\n\r\n            if (!eventSource || !event_types) {\r\n                logger.warn('SillyTavern event system not available');\r\n                return;\r\n            }\r\n\r\n            // Register for SillyTavern events\r\n            eventSource.on(event_types.MESSAGE_RECEIVED, async (messageId) => {\r\n                logger.debug('Message received event:', messageId);\r\n                // TODO: Process new message\r\n            });\r\n\r\n            eventSource.on(event_types.MESSAGE_SENT, async (messageId) => {\r\n                logger.debug('Message sent event:', messageId);\r\n                // TODO: Process new message\r\n            });\r\n\r\n            eventSource.on(event_types.CHAT_CHANGED, async () => {\r\n                logger.debug('Chat changed event received');\r\n                await settingsManager.onChatChanged();\r\n            });\r\n            \r\n            logger.debug('Event listeners registered');\r\n        } catch (error) {\r\n            logger.error('Failed to register event listeners:', error);\r\n        }\r\n    }\r\n    /**\r\n     * Setup error recovery strategies\r\n     */\r\n    setupErrorRecovery() {\r\n        // Network error recovery\r\n        errorHandler.registerRecoveryStrategy('NETWORK_ERROR', async (error) => {\r\n            logger.warn('Attempting network error recovery');\r\n            await errorHandler.delay(2000);\r\n            notifications.info('Retrying network operation...');\r\n            return null; // Signal to retry original operation\r\n        });\r\n\r\n        // Data format error recovery\r\n        errorHandler.registerRecoveryStrategy('DATA_FORMAT_ERROR', async (error) => {\r\n            logger.warn('Data format error, clearing cache');\r\n            // TODO: Clear relevant caches when modules are implemented\r\n            return null;\r\n        });\r\n\r\n        // Critical error handler\r\n        errorHandler.onCriticalError((error) => {\r\n            logger.error('Critical error occurred:', error);\r\n            // TODO: Save state for debugging when modules are implemented\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get extension status for debugging\r\n     * @returns {Object} Status information\r\n     */\r\n    getStatus() {\r\n        return {\r\n            initialized: this.initialized,\r\n            context: sillyTavernContext.getStatus(),\r\n            settings: settingsManager.getStatus(),\r\n            debug: debugLogger.getPerformanceSummary(),\r\n            errors: errorHandler.getRecentErrors(5).length,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Shutdown the extension\r\n     * @returns {Promise<void>}\r\n     */\r\n    async shutdown() {\r\n        return errorHandler.withErrorBoundary('Main', async () => {\r\n            logger.log('Shutting down Name Tracker Extension');\r\n\r\n            // TODO: Cleanup modules\r\n            // TODO: Remove event listeners\r\n            // TODO: Save state\r\n\r\n            this.initialized = false;\r\n            debugLogger.clear();\r\n\r\n            logger.log('Extension shutdown complete');\r\n        }, { silent: true });\r\n    }\r\n}\r\n\r\n// Create extension instance\r\nconst nameTrackerExtension = new NameTrackerExtension();\r\n\r\n// Initialize extension when jQuery is ready - SillyTavern pattern\r\njQuery(async () => {\r\n    console.log('[STnametracker] jQuery ready, starting extension load...');\r\n    try {\r\n        console.log('[STnametracker] Logger available, initializing...');\r\n        logger.log('Name Tracker Extension loading...');\r\n        \r\n        // Initialize extension_settings for this extension\r\n        console.log('[STnametracker] Setting up extension_settings...');\r\n        if (!window.extension_settings) {\r\n            console.log('[STnametracker] Creating window.extension_settings');\r\n            window.extension_settings = {};\r\n        }\r\n        console.log('[STnametracker] Current extension_settings keys:', Object.keys(window.extension_settings));\r\n        window.extension_settings[extensionName] = window.extension_settings[extensionName] || {};\r\n        console.log('[STnametracker] Extension settings initialized');\r\n        \r\n        console.log('[STnametracker] Starting main initialization...');\r\n        await nameTrackerExtension.initialize();\r\n        console.log('[STnametracker] Main initialization completed');\r\n\r\n        // Make extension available globally for debugging\r\n        window.nameTrackerExtension = nameTrackerExtension;\r\n\r\n        // Add debug commands to browser console\r\n        window.ntDebug = {\r\n            status: () => nameTrackerExtension.getStatus(),\r\n            errors: () => errorHandler.getRecentErrors(),\r\n            settings: () => getSettings(),\r\n            chatData: () => settingsManager.getChatData(),\r\n            clear: () => debugLogger.clear(),\r\n        };\r\n\r\n        logger.log('Name Tracker Extension loaded successfully');\r\n        console.log('[STnametracker] Extension loaded. Use ntDebug.status() for diagnostics.');\r\n\r\n    } catch (error) {\r\n        console.error('[STnametracker] Failed to initialize:', error);\r\n        notifications.error('Extension failed to load', 'Critical Error');\r\n    }\r\n});\r\n\r\nexport default nameTrackerExtension;\r\n"],"names":["logger","NameTrackerError","Error","constructor","message","code","module","recoverable","super","this","name","timestamp","Date","now","errorHandler","errorHistory","transactionStack","recoveryStrategies","Map","criticalErrorCallbacks","withErrorBoundary","moduleName","operation","options","fallback","retries","silent","operationId","lastError","startTime","trace","attempt","result","error","console","log","warn","delay","Math","pow","trackedError","trackError","duration","notifyUser","debug","fallbackError","recovery","get","recoveryError","context","categorizeError","isRecoverable","push","length","shift","includes","startTransaction","transactionId","initialState","id","state","JSON","stringify","commitTransaction","index","findIndex","t","splice","rollbackTransaction","transaction","parse","registerRecoveryStrategy","errorCode","strategy","set","onCriticalError","callback","toastr","warning","timeOut","forEach","callbackError","getRecentErrors","count","slice","clearHistory","ms","Promise","resolve","setTimeout","bind","exports","styleElement","nonce","setAttribute","stylesInDOM","getIndexByIdentifier","identifier","i","modulesToDom","list","idCountMap","identifiers","item","base","concat","indexByIdentifier","obj","css","media","sourceMap","supports","layer","references","updater","addElementStyle","byIndex","api","domAPI","update","newObj","remove","lastIdentifiers","newList","newLastIdentifiers","_i","_index","___CSS_LOADER_EXPORT___","styleSheet","cssText","firstChild","removeChild","appendChild","document","createTextNode","debugLogger","modules","performanceMarks","operationTraces","createModuleLogger","has","args","addTrace","startTimer","timerName","endTimer","level","isDebugEnabled","prefix","toLocaleTimeString","getTrace","key","performance","undefined","delete","toFixed","clear","getPerformanceSummary","activeTimers","size","activeTraces","Array","from","keys","cssWithMappingToString","toString","map","content","needLayer","join","dedupe","alreadyImportedModules","k","_k","cssMapping","btoa","base64","unescape","encodeURIComponent","data","sourceMapping","NotificationManager","defaultOptions","extendedTimeOut","closeButton","progressBar","preventDuplicates","success","title","opts","info","persistent","type","progress","notificationId","progressHtml","toastId","confirm","onConfirm","onCancel","confirmId","confirmHtml","window","nameTrackerNotifications","confirmCallbacks","handleConfirmOk","callbacks","handleConfirmCancel","getStatus","activeConfirms","Object","notifications","element","createElement","setAttributes","attributes","insert","EXTENSION_NAME","DEFAULT_SETTINGS","freeze","enabled","autoAnalyze","messageFrequency","llmSource","ollamaEndpoint","ollamaModel","confidenceThreshold","lorebookPosition","lorebookDepth","lorebookCooldown","lorebookScanDepth","lorebookProbability","lorebookEnabled","debugMode","systemPrompt","DEFAULT_CHAT_DATA","characters","messageCounter","lastHarvestMessage","lastScannedMessageId","settingsManager","_settings","_chatData","_settingsCallbacks","_chatCallbacks","_saveTimeout","_initialized","initialize","async","loadSettings","loadChatData","extensionSettings","getExtensionSettings","assign","chatMetadata","getChatMetadata","getSettings","getChatData","updateSetting","value","oldValue","saveSettings","updateChatData","saveChatData","getSetting","defaultValue","clearTimeout","saveExtensionSettings","saveChatMetadata","onSettingsChange","onChatDataChange","onChatChanged","isEnabled","isDebugMode","getAutoAnalysisConfig","frequency","lastScanned","getLLMConfig","source","getLorebookConfig","position","depth","cooldown","scanDepth","probability","reset","initialized","settingsLoaded","chatDataLoaded","charactersCount","settings","chatData","memo","style","target","styleTarget","querySelector","HTMLIFrameElement","contentDocument","head","e","getTarget","undoHistory","mergeCharacters","sourceName","targetName","chars","getCharacters","sourceChar","targetChar","undoData","sourceData","targetDataBefore","alias","aliases","preferredName","physicalAge","mentalAge","physical","personality","sexuality","raceEthnicity","roleSkills","lastInteraction","rel","relationships","lastUpdated","setCharacter","removeCharacter","undoLastMerge","lastOp","pop","toggleIgnoreCharacter","characterName","character","getCharacter","ignored","status","hasUnresolvedRelationships","knownNames","values","reduce","names","char","add","toLowerCase","Set","some","split","word","insertStyleElement","styleTagTransform","apply","parentNode","removeStyleElement","sillyTavernContext","_context","_lastUpdate","_updateInterval","getContext","SillyTavern","getChat","chat","getChatId","chatId","getCharacterId","characterId","getUserName","name1","saveSettingsDebounced","saveMetadata","generateQuietPrompt","loadWorldInfo","lorebookName","saveWorldInfo","create","saveWorldInfoEntry","entryData","getEventSource","eventSource","getEventTypes","event_types","callGenericPopup","input","isContextAvailable","clearCache","available","cached","lastUpdate","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","prop","prototype","hasOwnProperty","call","nc","locals","text","div","textContent","innerHTML","updateCharacterList","$container","$","html","sortedCharacters","sort","b","isMainChar","localeCompare","charIcon","ignoreIcon","reviewBadge","aliasText","relationshipText","toLocaleString","confidence","updateStatusDisplay","$statusContainer","characterCount","lastScannedId","messageFreq","getSillyTavernContext","currentChatLength","statusHtml","max","showCharacterListModal","charactersHtml","badges","modalHtml","POPUP_TYPE","TEXT","wider","okButton","initializeUIHandlers","on","otherChars","filter","prompt","showMergeDialog","openWorldInfoEditor","click","viewInLorebook","currentKeys","dialogHtml","notes","modal","overlay","append","removeModal","find","val","trim","r","showEditLorebookModal","addMenuButton","faIcon","hover","className","$button","$extensionsMenu","appendTo","toggleAutoHarvest","currentValue","setSetting","$menuButton","removeClass","addClass","openChatLorebook","world_info","extensionName","extensionFolderPath","nameTrackerExtension","initializeCore","initializeModules","initializeUI","registerEventListeners","setupErrorRecovery","METADATA_KEY","bookName","replace","substring","entries","initializeLorebook","settingsHtml","targetElement","MESSAGE_RECEIVED","messageId","MESSAGE_SENT","CHAT_CHANGED","errors","shutdown","jQuery","extension_settings","ntDebug"],"ignoreList":[],"sourceRoot":""}